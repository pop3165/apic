module tailf-ned-cisco-ios-xr {
  namespace "http://tail-f.com/ned/cisco-ios-xr";
  prefix "cisco-ios-xr";

  import tailf-ncs {
    prefix ncs;
  }
  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  revision "2014-02-18" {
    description "Additional config supported";
  }
  revision "2014-02-17" {
    description "Added support for route-policy in router bgp / vrf / address-family";
  }
  revision "2014-01-27" {
    description
      "Added 'mpls static' config
       Added 'interface tunnel-ip' config
       Added 'tailf:cli-explicit-exit' to top containers
       Changed references to interface(s) to non-strict leafrefs";
  }
  revision "2014-01-16" {
    description "Additional config supported";
  }
  revision "2013-12-19" {
    description "Additional config supported and bugfixes";
  }
  revision "2013-12-11" {
    description "Cleanup, improvements and bugfixes";
  }
  revision "2013-08-20" {
    description "Renamed YANG module, submodule and namespace.";
  }
  typedef month-type {
    type enumeration {
      enum "january";
      enum "february";
      enum "march";
      enum "april";
      enum "may";
      enum "june";
      enum "july";
      enum "august";
      enum "september";
      enum "october";
      enum "november";
      enum "december";
    }
  }
  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }
  typedef asn-ip-type {
    type string {
      pattern "(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+";
      tailf:info "ASN:nn or IP-address:nn";
    }
  }
  typedef ipv4-prefix {
    type string {
      pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))";
    }
    description
      "The ipv4-prefix type represents an IPv4 address prefix.
       The prefix length is given by the number following the
       slash character and must be less than or equal to 32.
       
       A prefix length value of n corresponds to an IP address
       mask that has n contiguous 1-bits from the most
       significant bit (MSB) and all other bits set to 0.
       
       The canonical format of an IPv4 prefix has all bits of
       the IPv4 address set to zero that are not part of the
       IPv4 prefix.";
  }
  typedef ipv6-prefix {
    type string {
      pattern "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))";
      pattern "(([^:]+:){6}(([^:]+:[^:]+)|(.*\\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+)";
    }
    description
      "The ipv6-prefix type represents an IPv6 address prefix.
       The prefix length is given by the number following the
       slash character and must be less than or equal 128.
       
       A prefix length value of n corresponds to an IP address
       mask that has n contiguous 1-bits from the most
       significant bit (MSB) and all other bits set to 0.
       
       The IPv6 address should have all bits that do not belong
       to the prefix set to zero.
       
       The canonical format of an IPv6 prefix has all bits of
       the IPv6 address set to zero that are not part of the
       IPv6 prefix.  Furthermore, IPv6 address is represented
       in the compressed format described in RFC 4291, Section
       2.2, item 2 with the following additional rules: the ::
       substitution must be applied to the longest sequence of
       all-zero 16-bit chunks in an IPv6 address.  If there is
       a tie, the first sequence of all-zero 16-bit chunks is
       replaced by ::.  Single all-zero 16-bit chunks are not
       compressed.  The canonical format uses lowercase
       characters and leading zeros are not allowed.";
    reference "RFC 4291: IP Version 6 Addressing Architecture";
  }
  typedef task-type {
    type enumeration {
      enum "li";
      enum "aaa";
      enum "acl";
      enum "bfd";
      enum "bgp";
      enum "cdp";
      enum "cef";
      enum "cgn";
      enum "eem";
      enum "pbr";
      enum "qos";
      enum "rib";
      enum "bcdl";
      enum "diag";
      enum "dwdm";
      enum "ipv4";
      enum "ipv6";
      enum "isis";
      enum "lpts";
      enum "ouni";
      enum "rcmd";
      enum "snmp";
      enum "vlan";
      enum "l2vpn";
      enum "bundle";
      enum "crypto";
      enum "fabric";
      enum "static";
      enum "sysmgr";
      enum "system";
      enum "tunnel";
      enum "drivers";
      enum "logging";
      enum "monitor";
      enum "netflow";
      enum "network";
      enum "pkg-mgmt";
      enum "fault-mgr";
      enum "interface";
      enum "inventory";
      enum "multicast";
      enum "route-map";
      enum "transport";
      enum "ext-access";
      enum "filesystem";
      enum "tty-access";
      enum "config-mgmt";
      enum "ip-services";
      enum "route-policy";
      enum "host-services";
      enum "config-services";
      enum "ethernet-services";
      enum "basic-services";
    }
  }
  typedef severity-type {
    type enumeration {
      enum "alerts" {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum "critical" {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum "debugging" {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum "emergencies" {
        tailf:info "System is unusable                (severity=0)";
      }
      enum "errors" {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum "info";
      enum "informational" {
        tailf:info "Informational messages            (severity=6)";
      }
      enum "notifications" {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum "warnings" {
        tailf:info "Warning conditions                (severity=4)";
      }
    }
  }
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum "af11" {
          tailf:info "AF11 dscp (001010)";
        }
        enum "af12" {
          tailf:info "AF12 dscp (001100)";
        }
        enum "af13" {
          tailf:info "AF13 dscp (001110)";
        }
        enum "af21" {
          tailf:info "AF21 dscp (010010)";
        }
        enum "af22" {
          tailf:info "AF22 dscp (010100)";
        }
        enum "af23" {
          tailf:info "AF23 dscp (010110)";
        }
        enum "af31" {
          tailf:info "AF31 dscp (011010)";
        }
        enum "af32" {
          tailf:info "AF32 dscp (011100)";
        }
        enum "af33" {
          tailf:info "AF33 dscp (011110)";
        }
        enum "af41" {
          tailf:info "AF41 dscp (100010)";
        }
        enum "af42" {
          tailf:info "AF42 dscp (100100)";
        }
        enum "af43" {
          tailf:info "AF43 dscp (100110)";
        }
        enum "cs1" {
          tailf:info "CS1(precedence 1) dscp (001000)";
        }
        enum "cs2" {
          tailf:info "CS2(precedence 2) dscp (010000)";
        }
        enum "cs3" {
          tailf:info "CS3(precedence 3) dscp (011000)";
        }
        enum "cs4" {
          tailf:info "CS4(precedence 4) dscp (100000)";
        }
        enum "cs5" {
          tailf:info "CS5(precedence 5) dscp (101000)";
        }
        enum "cs6" {
          tailf:info "CS6(precedence 6) dscp (110000)";
        }
        enum "cs7" {
          tailf:info "CS7(precedence 7) dscp (111000)";
        }
        enum "default" {
          tailf:info "Default dscp (000000)";
          tailf:code-name "dscp_default";
        }
        enum "ef" {
          tailf:info "EF dscp (101110)";
        }
      }
    }
  }
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum "critical" {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum "flash" {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum "flash-override" {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum "immediate" {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum "internet" {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control precedence (6)";
        }
        enum "network" {
          tailf:info "Set packets with network control precedence (7)";
        }
        enum "priority" {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum "routine" {
          tailf:info "Set packets with routine precedence (0)";
        }
        enum "ipv4" {
          tailf:code-name "prec_ipv4";
          tailf:info "IPV4 precedence";
        }
        enum "ipv6" {
          tailf:code-name "prec_ipv6";
          tailf:info "IPV6 precedence";
        }
      }
    }
  }
  typedef police-burst-units-type {
    type enumeration {
      enum "bytes" {
        tailf:info "Bytes (default)";
      }
      enum "gbytes" {
        tailf:info "Gigabytes";
      }
      enum "kbytes" {
        tailf:info "Kilobytes";
      }
      enum "mbytes" {
        tailf:info "Megabytes";
      }
      enum "ms" {
        tailf:info "Milliseconds";
      }
      enum "packets" {
        tailf:info "Packets";
      }
      enum "us" {
        tailf:info "Microseconds";
      }
    }
  }
  typedef police-rate-units-type {
    type enumeration {
      enum "bps" {
        tailf:info "Bits per second (default)";
      }
      enum "gbps" {
        tailf:info "Gigabits per second";
      }
      enum "kbps" {
        tailf:info "Kilobits per second";
      }
      enum "mbps" {
        tailf:info "Megabits per second";
      }
      enum "pps" {
        tailf:info "Packets per second";
      }
    }
  }
  typedef ospf-area-type {
    type union {
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }
  typedef operator-type {
    type enumeration {
      enum "eq" {
        tailf:info "Equal to";
      }
      enum "ge" {
        tailf:info "Greater than or equal to";
      }
      enum "gt" {
        tailf:info "Greater than";
      }
      enum "le" {
        tailf:info "Less than or equal to";
      }
      enum "lt" {
        tailf:info "Less than";
      }
      enum "ne" {
        tailf:info "Not equal to";
      }
      enum "rg" {
        tailf:info "Not in range";
      }
    }
  }
  grouping vrf-route-target-grouping {
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "name";
      leaf name {
        type string {
          tailf:info
            "<1-65535>:<0-4294967295>;;ASN2:index
             <65536-4294967295>:<0-65535>;;ASN4:index
             <IP address>:<0-65535>;;IPAddress:index (hex or decimal format)";
        }
      }
    }
  }
  grouping template_ncs_vrf-route-target-grouping {
    list address-list {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping router-isis-address-family-grouping {
    container ipv4 {
      tailf:info "IPV4 address family";
      container unicast {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-isis-af";
        presence "true";
        leaf metric {
          tailf:info "Configure default metric";
          type uint32;
        }
        container metric-style {
          tailf:info "Use old-style (ISO 10589) or new-style packet formats";
          leaf wide {
            tailf:info "Use new style of TLVs to carry wider metric";
            tailf:cli-full-command;
            type empty;
          }
        }
        container spf-interval {
          tailf:info "Route calculation scheduling parameters  (FSPF, ISPF, PRC)";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf maximum-wait {
            tailf:info "Maximum delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
        }
        leaf maximum-paths {
          tailf:info "Maximum number of active parallel paths per route";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-32>;;Number of paths";
            range "1..32";
          }
        }
        container mpls {
          leaf ldp {
            type enumeration {
              enum "auto-config";
            }
          }
        }
      }
    }
    container ipv6 {
      container unicast {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-isis-af";
        presence "true";
        leaf metric {
          tailf:info "Configure the metric for interface";
          tailf:cli-full-command;
          type uint32;
        }
        container metric-style {
          tailf:info "Use old-style (ISO 10589) or new-style packet formats";
          leaf wide {
            tailf:info "Use new style of TLVs to carry wider metric";
            tailf:cli-full-command;
            type empty;
          }
        }
        container spf-interval {
          tailf:info "Route calculation scheduling parameters  (FSPF, ISPF, PRC)";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf maximum-wait {
            tailf:info "Maximum delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay before running a route calculation";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
        }
        leaf maximum-paths {
          tailf:info "Maximum number of active parallel paths per route";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-32>;;Number of paths";
            range "1..32";
          }
        }
      }
    }
  }
  grouping template_ncs_router-isis-address-family-grouping {
    container ipv4 {
      container unicast {
        presence "true";
        leaf metric {
          type string;   // NCS patched all types to string
        }
        container metric-style {
          leaf wide {
            type empty;
          }
        }
        container spf-interval {
          leaf maximum-wait {
            type string;   // NCS patched all types to string
          }
          leaf initial-wait {
            type string;   // NCS patched all types to string
          }
          leaf secondary-wait {
            type string;   // NCS patched all types to string
          }
        }
        leaf maximum-paths {
          type string;   // NCS patched all types to string
        }
        container mpls {
          leaf ldp {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container ipv6 {
      container unicast {
        presence "true";
        leaf metric {
          type string;   // NCS patched all types to string
        }
        container metric-style {
          leaf wide {
            type empty;
          }
        }
        container spf-interval {
          leaf maximum-wait {
            type string;   // NCS patched all types to string
          }
          leaf initial-wait {
            type string;   // NCS patched all types to string
          }
          leaf secondary-wait {
            type string;   // NCS patched all types to string
          }
        }
        leaf maximum-paths {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16;
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16;
    }
    leaf line-template {
      tailf:cli-optional-in-sequence;
      type string;
    }
  }
  grouping template_ncs_vty-pool-grouping {
    leaf first-vty {
      type string;   // NCS patched all types to string
    }
    leaf last-vty {
      type string;   // NCS patched all types to string
    }
    leaf line-template {
      type string;   // NCS patched all types to string
    }
  }
  grouping line-grouping {
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }
    container accounting {
      tailf:info "Accounting parameters";
      tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:aaa/accounting" {
        tailf:xpath-root "3";
      }
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
    }
    container authorization {
      tailf:info "Authorization parameters";
      tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:aaa/authorization" {
        tailf:xpath-root "3";
      }
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
          }
        }
      }
    }
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence "true";
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }
    container transport {
      tailf:info "Define transport protocols for line";
      leaf-list input {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "all" {
            tailf:info "All protocols";
          }
          enum "none" {
            tailf:info "No protocols";
          }
          enum "ssh" {
            tailf:info "TCP/IP SSH protocol";
          }
          enum "telnet" {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum "lat";
          enum "pad" {
            tailf:info "X.3 PAD";
          }
          enum "udptn" {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum "rlogin" {
            tailf:info "Unix rlogin protocol";
          }
        }
      }
      leaf-list output {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "all" {
            tailf:info "All protocols";
          }
          enum "none" {
            tailf:info "No protocols";
          }
          enum "ssh" {
            tailf:info "TCP/IP SSH protocol";
          }
          enum "telnet" {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum "none" {
            tailf:info "No protocols";
          }
          enum "ssh" {
            tailf:info "Unix ssh protocol";
          }
          enum "telnet" {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf minutes {
        tailf:info "<0-35791>;;Timeout in minutes";
        tailf:cli-drop-node-name;
        type uint32;
      }
      leaf seconds {
        tailf:info "<0-2147483>;;Timeout in seconds";
        tailf:cli-drop-node-name;
        type uint32;
      }
    }
    leaf length {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
      }
    }
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
      }
    }
    container login {
      tailf:info "Enable password checking";
      tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:aaa/authentication" {
        tailf:xpath-root "3";
      }
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf output {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }
  }
  grouping template_ncs_line-grouping {
    container access-class {
      leaf egress {
        type string;   // NCS patched all types to string
      }
      leaf ingress {
        type string;   // NCS patched all types to string
      }
    }
    container password {
      leaf encryption {
        type string;   // NCS patched all types to string
      }
      leaf password {
        type string;   // NCS patched all types to string
      }
    }
    container accounting {
      leaf commands {
        type string;   // NCS patched all types to string
      }
      leaf exec {
        type string;   // NCS patched all types to string
      }
    }
    container authorization {
      leaf commands {
        type string;   // NCS patched all types to string
      }
      leaf exec {
        type string;   // NCS patched all types to string
      }
    }
    container timeout {
      container login {
        leaf response {
          type string;   // NCS patched all types to string
        }
      }
    }
    container timestamp {
      presence "true";
      leaf disable {
        type empty;
      }
    }
    container transport {
      leaf-list input {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
      leaf-list output {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
      leaf preferred {
        type string;   // NCS patched all types to string
      }
    }
    container exec-timeout {
      leaf minutes {
        type string;   // NCS patched all types to string
      }
      leaf seconds {
        type string;   // NCS patched all types to string
      }
    }
    leaf length {
      type string;   // NCS patched all types to string
    }
    leaf width {
      type string;   // NCS patched all types to string
    }
    container login {
      leaf authentication {
        type string;   // NCS patched all types to string
      }
    }
    leaf absolute-timeout {
      type string;   // NCS patched all types to string
    }
    container session-timeout {
      leaf minutes {
        type string;   // NCS patched all types to string
      }
      leaf output {
        type empty;
      }
    }
  }
  grouping lpts-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;flow type";
        }
      }
      leaf ospf-type {
        when "../name = 'ospf'" {
          tailf:xpath-root "3";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "multicast" {
            tailf:info "Multicast";
          }
          enum "unicast" {
            tailf:info "Unicast";
          }
        }
      }
      leaf ldp-type {
        when "../name = 'ldp'" {
          tailf:xpath-root "3";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "tcp" {
            tailf:info "TCP";
          }
          enum "udp" {
            tailf:info "UDP";
          }
        }
      }
      leaf rsvp-type {
        when "../name = 'rsvp'" {
          tailf:xpath-root "3";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "udp" {
            tailf:info "UDP";
          }
        }
      }
      leaf raw-type {
        when "../name = 'raw'" {
          tailf:xpath-root "3";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "listen" {
            tailf:info "Listen";
          }
        }
      }
      leaf udp-tcp-type {
        when "../name = 'udp' or ../name = 'tcp'" {
          tailf:xpath-root "3";
          tailf:dependency "../name";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "configured" {
            tailf:info "Config peer";
          }
          enum "listen" {
            tailf:info "Listen";
          }
        }
      }
      leaf icmp-type {
        when "../name = 'icmp'" {
          tailf:xpath-root "3";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "application" {
            tailf:info "Specific application packets";
          }
          enum "control" {
            tailf:info "Control packets";
          }
          enum "generic" {
            tailf:info "Generic application packets";
          }
          enum "local" {
            tailf:info "Local interest packets";
          }
        }
      }
      leaf which {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "default" {
            tailf:info "Default";
          }
          enum "known" {
            tailf:info "Known";
          }
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
    }
  }
  grouping template_ncs_lpts-grouping {
    list flow {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf ospf-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf ldp-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf rsvp-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf raw-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf udp-tcp-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf icmp-type {
        // NCS drop path statement here
        type string;   // NCS patched all types to string
      }
      leaf which {
        type string;   // NCS patched all types to string
      }
      leaf rate {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }
  grouping template_ncs_class-random-detect-grouping {
    leaf min-threshold {
      type string;   // NCS patched all types to string
    }
    leaf min-threshold-unit {
      type string;   // NCS patched all types to string
    }
    leaf max-threshold {
      type string;   // NCS patched all types to string
    }
    leaf max-threshold-unit {
      type string;   // NCS patched all types to string
    }
  }
  grouping class-map-match-grouping {
    container access-group {
      tailf:info "Match access group";
      leaf ipv4 {
        tailf:info "IPv4 access list";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf ipv6 {
        tailf:info "IPv6 access list";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv6/access-list/named-acl/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    leaf any {
      tailf:info "Any packets";
      type empty;
    }
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    container destination-address {
      tailf:info "Match based on destination address";
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }
    leaf-list dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";
      tailf:cli-flat-list-syntax;
      type union {
        type dscp-type;
        type enumeration {
          enum "ipv4" {
            tailf:info "IPV4 DSCP";
          }
          enum "ipv6" {
            tailf:info "IPV6 DSCP";
          }
        }
      }
    }
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence "true";
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }
    container packet {
      tailf:info "Layer 3 Packet length";
      container length {
        tailf:info "Layer 3 Packet length";
        leaf max {
          tailf:info "Maximum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
        leaf min {
          tailf:info "Minimum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
      }
    }
    leaf-list precedence {
      tailf:info "Match based on IP precedence values";
      tailf:cli-flat-list-syntax;
      type precedence-type;
    }
    container protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      leaf aarp {
        type empty;
        tailf:info "AppleTalk ARP";
      }
      leaf appletalk {
        type empty;
        tailf:info "AppleTalk";
      }
      leaf arp {
        type empty;
        tailf:info "IP ARP";
      }
      leaf bgp {
        type empty;
        tailf:info "Border Gateway Protocol";
      }
      leaf bridge {
        type empty;
        tailf:info "Bridging";
      }
      leaf bstun {
        type empty;
        tailf:info "Block Serial Tunnel";
      }
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }
      container citrix {
        tailf:info "Citrix Systems ICA protocol";
        presence "enable citrix system protocol matching";
        leaf ica-tag {
          tailf:info "Citrix ICA tag 0-high 1-medium 2-low 3-background";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
      }
      leaf clns {
        type empty;
        tailf:info "ISO CLNS";
      }
      leaf clns_es {
        type empty;
        tailf:info "ISO CLNS End System";
      }
      leaf clns_is {
        type empty;
        tailf:info "ISO CLNS Intermediate System";
      }
      leaf cmns {
        type empty;
        tailf:info "ISO CMNS";
      }
      leaf compressedtcp {
        type empty;
        tailf:info "Compressed TCP (VJ";
      }
      leaf cuseeme {
        type empty;
        tailf:info "CU-SeeMe desktop video conference";
      }
      leaf decnet {
        type empty;
        tailf:info "DECnet";
      }
      leaf decnet_node {
        type empty;
        tailf:info "DECnet Node";
      }
      leaf decnet_router-l1 {
        type empty;
        tailf:info "DECnet Router L1";
      }
      leaf decnet_router-l2 {
        type empty;
        tailf:info "DECnet Router L2";
      }
      leaf dhcp {
        type empty;
        tailf:info "Dynamic Host Configuration";
      }
      leaf dlsw {
        type empty;
        tailf:info "Data Link Switching (Direct encapsulation only";
      }
      leaf dns {
        type empty;
        tailf:info "Domain Name Server lookup";
      }
      leaf edonkey {
        type empty;
        tailf:info "eDonkey";
      }
      leaf egp {
        type empty;
        tailf:info "Exterior Gateway Protocol";
      }
      leaf eigrp {
        type empty;
        tailf:info "Enhanced Interior Gateway Routing Protocol";
      }
      leaf exchange {
        type empty;
        tailf:info "MS-RPC for Exchange";
      }
      container fasttrack {
        tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster";
        presence "enable fasttrack matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
      }
      leaf finger {
        type empty;
        tailf:info "Finger";
      }
      leaf ftp {
        type empty;
        tailf:info "File Transfer Protocol";
      }
      container gnutella {
        tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, Morpheus";
        presence "enable gnutella matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
      }
      leaf gopher {
        type empty;
        tailf:info "Gopher";
      }
      leaf gre {
        type empty;
        tailf:info "Generic Routing Encapsulation";
      }
      leaf h323 {
        type empty;
        tailf:info "H323 Protocol";
      }
      container http {
        tailf:info "World Wide Web traffic";
        presence "enable http traffic matching";
        leaf c-header-field {
          tailf:info "Client general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
        leaf host {
          tailf:info "Server Host Name";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
        leaf mime {
          tailf:info "Match MIME Type";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
        leaf s-header-field {
          tailf:info "Server general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
        leaf url {
          tailf:info "Match URL String";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
      }
      leaf icmp {
        type empty;
        tailf:info "Internet Control Message";
      }
      leaf imap {
        type empty;
        tailf:info "Internet Message Access Protocol";
      }
      leaf ip {
        type empty;
        tailf:info "IP";
      }
      leaf ipinip {
        type empty;
        tailf:info "IP in IP (encapsulation";
      }
      leaf ipsec {
        type empty;
        tailf:info "IP Security Protocol (ESP/AH";
      }
      leaf ipv6 {
        type empty;
        tailf:info "IPV6";
      }
      leaf ipx {
        type empty;
        tailf:info "Novell IPX";
      }
      leaf irc {
        type empty;
        tailf:info "Internet Relay Chat";
      }
      container kazaa2 {
        tailf:info "Kazaa Version 2";
        presence "enable kazaa version 2 matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
      }
      leaf kerberos {
        type empty;
        tailf:info "Kerberos";
      }
      leaf l2tp {
        type empty;
        tailf:info "L2F/L2TP tunnel";
      }
      leaf ldap {
        type empty;
        tailf:info "Lightweight Directory Access Protocol";
      }
      leaf llc2 {
        type empty;
        tailf:info "llc2";
      }
      leaf mgcp {
        type empty;
        tailf:info "Media Gateway Control Protocol";
      }
      container napster {
        tailf:info "Napster Traffic";
        presence "enable napster matching";
        leaf non-std {
          tailf:info "Non-standard port advertizements";
          type empty;
        }
      }
      leaf netbios {
        type empty;
        tailf:info "NetBIOS";
      }
      leaf netshow {
        type empty;
        tailf:info "Microsoft Netshow";
      }
      leaf nfs {
        type empty;
        tailf:info "Network File System";
      }
      leaf nntp {
        type empty;
        tailf:info "Network News Transfer Protocol";
      }
      leaf notes {
        type empty;
        tailf:info "Lotus Notes(R";
      }
      leaf novadigm {
        type empty;
        tailf:info "Novadigm EDM";
      }
      leaf ntp {
        type empty;
        tailf:info "Network Time Protocol";
      }
      leaf ospf {
        type empty;
        tailf:info "Open Shortest Path First";
      }
      leaf pad {
        type empty;
        tailf:info "PAD links";
      }
      leaf pcanywhere {
        type empty;
        tailf:info "Symantec pcANYWHERE";
      }
      leaf pop3 {
        tailf:info "Post Office Protocol";
        type empty;
      }
      leaf pppoe {
        tailf:info "PPP over Ethernet";
        type empty;
      }
      leaf pptp {
        tailf:info "Point-to-Point Tunneling Protocol";
        type empty;
      }
      leaf printer {
        tailf:info "print spooler/lpd";
        type empty;
      }
      leaf qllc {
        tailf:info "qllc protocol";
        type empty;
      }
      leaf rcmd {
        tailf:info "BSD r-commands (rsh, rlogin, rexec";
        type empty;
      }
      leaf rip {
        tailf:info "Routing Information Protocol";
        type empty;
      }
      leaf rsrb {
        tailf:info "Remote Source-Route Bridging";
        type empty;
      }
      leaf rsvp {
        tailf:info "Resource Reservation Protocol";
        type empty;
      }
      leaf rtcp {
        tailf:info "Real Time Control Protocol";
        type empty;
      }
      container rtp {
        tailf:info "Real Time Protocol";
        presence "enable rtp matching";
        leaf audio {
          tailf:info "Match voice packets";
          type empty;
        }
        leaf payload-type {
          tailf:info "Match an explicit PT";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol parameter";
          }
        }
        leaf video {
          tailf:info "Match video packets";
          type empty;
        }
      }
      leaf rtsp {
        type empty;
        tailf:info "Real Time Streaming Protocol";
      }
      leaf secure-ftp {
        type empty;
        tailf:info "FTP over TLS/SSL";
      }
      leaf secure-http {
        type empty;
        tailf:info "Secured HTTP";
      }
      leaf secure-imap {
        type empty;
        tailf:info "Internet Message Access Protocol over TLS/SSL";
      }
      leaf secure-irc {
        type empty;
        tailf:info "Internet Relay Chat over TLS/SSL";
      }
      leaf secure-ldap {
        type empty;
        tailf:info "Lightweight Directory Access Protocol over TLS/SSL";
      }
      leaf secure-nntp {
        type empty;
        tailf:info "Network News Transfer Protocol over TLS/SSL";
      }
      leaf secure-pop3 {
        type empty;
        tailf:info "Post Office Protocol over TLS/SSL";
      }
      leaf secure-telnet {
        type empty;
        tailf:info "Telnet over TLS/SSL";
      }
      leaf sip {
        type empty;
        tailf:info "Session Initiation Protocol";
      }
      leaf skinny {
        type empty;
        tailf:info "Skinny Protocol";
      }
      leaf smtp {
        type empty;
        tailf:info "Simple Mail Transfer Protocol";
      }
      leaf snapshot {
        type empty;
        tailf:info "Snapshot routing support";
      }
      leaf snmp {
        type empty;
        tailf:info "Simple Network Management Protocol";
      }
      leaf socks {
        type empty;
        tailf:info "SOCKS";
      }
      leaf sqlnet {
        type empty;
        tailf:info "SQL*NET for Oracle";
      }
      leaf sqlserver {
        type empty;
        tailf:info "MS SQL Server";
      }
      leaf ssh {
        type empty;
        tailf:info "Secured Shell";
      }
      leaf streamwork {
        type empty;
        tailf:info "Xing Technology StreamWorks player";
      }
      leaf stun {
        type empty;
        tailf:info "Serial Tunnel";
      }
      leaf sunrpc {
        type empty;
        tailf:info "Sun RPC";
      }
      leaf syslog {
        type empty;
        tailf:info "System Logging Utility";
      }
      leaf telnet {
        type empty;
        tailf:info "Telnet";
      }
      leaf tftp {
        type empty;
        tailf:info "Trivial File Transfer Protocol";
      }
      leaf vdolive {
        type empty;
        tailf:info "VDOLive streaming video";
      }
      leaf vofr {
        type empty;
        tailf:info "voice over Frame Relay packets";
      }
      leaf winmx {
        type empty;
        tailf:info "WinMx file-sharing application";
      }
      leaf xwindows {
        type empty;
        tailf:info "X-Windows remote access";
      }
    }
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }
    container source-address {
      tailf:info "Match based on source address";
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
  }
  grouping template_ncs_class-map-match-grouping {
    container access-group {
      leaf ipv4 {
        type string;   // NCS patched all types to string
      }
      leaf ipv6 {
        type string;   // NCS patched all types to string
      }
    }
    leaf any {
      type empty;
    }
    container cos {
      leaf-list cos-value {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
      leaf-list inner {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
    }
    container destination-address {
      leaf mac {
        type string;   // NCS patched all types to string
      }
    }
    leaf-list discard-class {
      ordered-by "user";  // NCS patched to keep predictable order
      type string;   // NCS patched all types to string
    }
    leaf-list dscp {
      ordered-by "user";  // NCS patched to keep predictable order
      type string;   // NCS patched all types to string
    }
    container fr-de {
      presence "true";
      leaf fr-de-value {
        type string;   // NCS patched all types to string
      }
    }
    container frame-relay {
      leaf-list dlci {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
    }
    container mpls {
      container experimental {
        leaf-list topmost {
          ordered-by "user";  // NCS patched to keep predictable order
          type string;   // NCS patched all types to string
        }
      }
    }
    container packet {
      container length {
        leaf max {
          type string;   // NCS patched all types to string
        }
        leaf min {
          type string;   // NCS patched all types to string
        }
      }
    }
    leaf-list precedence {
      ordered-by "user";  // NCS patched to keep predictable order
      type string;   // NCS patched all types to string
    }
    container protocol {
      leaf aarp {
        type empty;
      }
      leaf appletalk {
        type empty;
      }
      leaf arp {
        type empty;
      }
      leaf bgp {
        type empty;
      }
      leaf bridge {
        type empty;
      }
      leaf bstun {
        type empty;
      }
      leaf cdp {
        type empty;
      }
      container citrix {
        presence "enable citrix system protocol matching";
        leaf ica-tag {
          type string;   // NCS patched all types to string
        }
      }
      leaf clns {
        type empty;
      }
      leaf clns_es {
        type empty;
      }
      leaf clns_is {
        type empty;
      }
      leaf cmns {
        type empty;
      }
      leaf compressedtcp {
        type empty;
      }
      leaf cuseeme {
        type empty;
      }
      leaf decnet {
        type empty;
      }
      leaf decnet_node {
        type empty;
      }
      leaf decnet_router-l1 {
        type empty;
      }
      leaf decnet_router-l2 {
        type empty;
      }
      leaf dhcp {
        type empty;
      }
      leaf dlsw {
        type empty;
      }
      leaf dns {
        type empty;
      }
      leaf edonkey {
        type empty;
      }
      leaf egp {
        type empty;
      }
      leaf eigrp {
        type empty;
      }
      leaf exchange {
        type empty;
      }
      container fasttrack {
        presence "enable fasttrack matching";
        leaf file-transfer {
          type string;   // NCS patched all types to string
        }
      }
      leaf finger {
        type empty;
      }
      leaf ftp {
        type empty;
      }
      container gnutella {
        presence "enable gnutella matching";
        leaf file-transfer {
          type string;   // NCS patched all types to string
        }
      }
      leaf gopher {
        type empty;
      }
      leaf gre {
        type empty;
      }
      leaf h323 {
        type empty;
      }
      container http {
        presence "enable http traffic matching";
        leaf c-header-field {
          type string;   // NCS patched all types to string
        }
        leaf host {
          type string;   // NCS patched all types to string
        }
        leaf mime {
          type string;   // NCS patched all types to string
        }
        leaf s-header-field {
          type string;   // NCS patched all types to string
        }
        leaf url {
          type string;   // NCS patched all types to string
        }
      }
      leaf icmp {
        type empty;
      }
      leaf imap {
        type empty;
      }
      leaf ip {
        type empty;
      }
      leaf ipinip {
        type empty;
      }
      leaf ipsec {
        type empty;
      }
      leaf ipv6 {
        type empty;
      }
      leaf ipx {
        type empty;
      }
      leaf irc {
        type empty;
      }
      container kazaa2 {
        presence "enable kazaa version 2 matching";
        leaf file-transfer {
          type string;   // NCS patched all types to string
        }
      }
      leaf kerberos {
        type empty;
      }
      leaf l2tp {
        type empty;
      }
      leaf ldap {
        type empty;
      }
      leaf llc2 {
        type empty;
      }
      leaf mgcp {
        type empty;
      }
      container napster {
        presence "enable napster matching";
        leaf non-std {
          type empty;
        }
      }
      leaf netbios {
        type empty;
      }
      leaf netshow {
        type empty;
      }
      leaf nfs {
        type empty;
      }
      leaf nntp {
        type empty;
      }
      leaf notes {
        type empty;
      }
      leaf novadigm {
        type empty;
      }
      leaf ntp {
        type empty;
      }
      leaf ospf {
        type empty;
      }
      leaf pad {
        type empty;
      }
      leaf pcanywhere {
        type empty;
      }
      leaf pop3 {
        type empty;
      }
      leaf pppoe {
        type empty;
      }
      leaf pptp {
        type empty;
      }
      leaf printer {
        type empty;
      }
      leaf qllc {
        type empty;
      }
      leaf rcmd {
        type empty;
      }
      leaf rip {
        type empty;
      }
      leaf rsrb {
        type empty;
      }
      leaf rsvp {
        type empty;
      }
      leaf rtcp {
        type empty;
      }
      container rtp {
        presence "enable rtp matching";
        leaf audio {
          type empty;
        }
        leaf payload-type {
          type string;   // NCS patched all types to string
        }
        leaf video {
          type empty;
        }
      }
      leaf rtsp {
        type empty;
      }
      leaf secure-ftp {
        type empty;
      }
      leaf secure-http {
        type empty;
      }
      leaf secure-imap {
        type empty;
      }
      leaf secure-irc {
        type empty;
      }
      leaf secure-ldap {
        type empty;
      }
      leaf secure-nntp {
        type empty;
      }
      leaf secure-pop3 {
        type empty;
      }
      leaf secure-telnet {
        type empty;
      }
      leaf sip {
        type empty;
      }
      leaf skinny {
        type empty;
      }
      leaf smtp {
        type empty;
      }
      leaf snapshot {
        type empty;
      }
      leaf snmp {
        type empty;
      }
      leaf socks {
        type empty;
      }
      leaf sqlnet {
        type empty;
      }
      leaf sqlserver {
        type empty;
      }
      leaf ssh {
        type empty;
      }
      leaf streamwork {
        type empty;
      }
      leaf stun {
        type empty;
      }
      leaf sunrpc {
        type empty;
      }
      leaf syslog {
        type empty;
      }
      leaf telnet {
        type empty;
      }
      leaf tftp {
        type empty;
      }
      leaf vdolive {
        type empty;
      }
      leaf vofr {
        type empty;
      }
      leaf winmx {
        type empty;
      }
      leaf xwindows {
        type empty;
      }
    }
    leaf-list qos-group {
      ordered-by "user";  // NCS patched to keep predictable order
      type string;   // NCS patched all types to string
    }
    container source-address {
      leaf mac {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum "infinite" {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum "infinite" {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }
  grouping template_ncs_interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        leaf valid-lifetime {
          type string;   // NCS patched all types to string
        }
        leaf preferred-lifetime {
          type string;   // NCS patched all types to string
        }
      }
      leaf no-adv {
        type empty;
      }
      container options {
        leaf no-autoconfig {
          type empty;
        }
        leaf off-link {
          type empty;
        }
      }
    }
  }
  grouping interface-ipv6-nd-grouping {
    container nd {
      tailf:info "IPv6 interface Neighbor Discovery subcommands";
      leaf cache-limit {
        tailf:info "Set Cache Limit for neighbor entry";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-10000>;;Cache Limit";
          range "1..10000";
        }
      }
      container dad {
        tailf:info "Duplicate Address Detection";
        leaf attempts {
          tailf:info "Set IPv6 Duplicate Address Detection Transmits";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-600>;;Number of attempts";
            range "0..600";
          }
        }
      }
      leaf managed-config-flag {
        tailf:info "Hosts should use stateful protocol for address config";
        tailf:cli-full-command;
        type empty;
      }
      leaf ns-interval {
        tailf:info "Set advertised NS retransmission interval";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1000-4294967295>;;Retransmission interval in milliseconds";
          range "1000..4294967295";
        }
      }
      leaf other-config-flag {
        tailf:info "Hosts should use stateful protocol for non-address config";
        tailf:cli-full-command;
        type empty;
      }
      container prefix {
        tailf:info "Configure IPv6 Routing Prefix Advertisement";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key "prefix";
          leaf prefix {
            type ipv6-prefix {
              tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
            }
          }
          uses interface-ipv6-nd-prefix-list-grouping;
        }
        container default {
          tailf:info "Specify prefix default parameters";
          uses interface-ipv6-nd-prefix-list-grouping;
        }
      }
      container ra {
        tailf:info "IPv6 interface ND RA subcommands";
        leaf hoplimit {
          tailf:info "IPv6 ND RA hoplimit";
          tailf:cli-full-command;
          type enumeration {
            enum "unspecified" {
              tailf:info "Unspecified IPv6 ND RA hop-limit value";
            }
          }
        }
        leaf mtu {
          tailf:info "IPv6 ND RA mtu option configuration";
          tailf:cli-full-command;
          type enumeration {
            enum "unspecified" {
              tailf:info "Unspecified IPv6 ND RA hop-limit value";
            }
          }
        }
      }
      leaf ra-interval {
        tailf:info "Set IPv6 Router Advertisement Interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<4-1800>;;Maximum RA Interval (sec)";
          range "4..1800";
        }
      }
      leaf ra-lifetime {
        tailf:info "Set IPv6 Router Advertisement Lifetime";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-9000>;;RA Lifetime (seconds)";
          range "0..9000";
        }
      }
      leaf reachable-time {
        tailf:info "Set advertised reachability time";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-3600000>;;Reachability time in milliseconds";
          range "0..3600000";
        }
      }
      leaf redirects {
        tailf:info "Enable sending of ICMP Redirect messages";
        tailf:cli-full-command;
        type empty;
      }
      leaf suppress-ra {
        tailf:info "Suppress IPv6 Router Advertisements";
        tailf:cli-full-command;
        type empty;
      }
    }
  }
  grouping template_ncs_interface-ipv6-nd-grouping {
    container nd {
      leaf cache-limit {
        type string;   // NCS patched all types to string
      }
      container dad {
        leaf attempts {
          type string;   // NCS patched all types to string
        }
      }
      leaf managed-config-flag {
        type empty;
      }
      leaf ns-interval {
        type string;   // NCS patched all types to string
      }
      leaf other-config-flag {
        type empty;
      }
      container prefix {
        list prefix-list {
          ordered-by "user";  // NCS patched to keep predictable order
          key "prefix";
          leaf prefix {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_interface-ipv6-nd-prefix-list-grouping;
        }
        container default {
          uses template_ncs_interface-ipv6-nd-prefix-list-grouping;
        }
      }
      container ra {
        leaf hoplimit {
          type string;   // NCS patched all types to string
        }
        leaf mtu {
          type string;   // NCS patched all types to string
        }
      }
      leaf ra-interval {
        type string;   // NCS patched all types to string
      }
      leaf ra-lifetime {
        type string;   // NCS patched all types to string
      }
      leaf reachable-time {
        type string;   // NCS patched all types to string
      }
      leaf redirects {
        type empty;
      }
      leaf suppress-ra {
        type empty;
      }
    }
  }
  grouping interface-service-policy-grouping {
    container service-policy {
      tailf:info "Configure QoS Service Policy";
      list input {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name";
        leaf name {
          type leafref {
            tailf:info "WORD;;Name of the service policy";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
      list output {
        tailf:info "direction of service policy application";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name";
        leaf name {
          type leafref {
            tailf:info "WORD;;Name of the service policy";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
      container type {
        tailf:info "Enter service policy type (default: qos)";
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
        }
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum "input" {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum "output" {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container test {
          tailf:info "Configure Test Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root "3";
              }
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum "input" {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum "output" {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container pbr {
          leaf input {
            type string;
          }
        }
      }
    }
  }
  grouping template_ncs_interface-service-policy-grouping {
    container service-policy {
      list input {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
      list output {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
      container type {
        container lan-queuing {
          leaf input {
            type string;   // NCS patched all types to string
          }
          leaf output {
            type string;   // NCS patched all types to string
          }
        }
        container performance-monitor {
          leaf input {
            type string;   // NCS patched all types to string
          }
          leaf output {
            type string;   // NCS patched all types to string
          }
          leaf inline {
            type string;   // NCS patched all types to string
          }
        }
        container test {
          leaf input {
            type string;   // NCS patched all types to string
          }
          leaf output {
            type string;   // NCS patched all types to string
          }
          leaf inline {
            type string;   // NCS patched all types to string
          }
        }
        container pbr {
          leaf input {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
  }
  grouping interface-isis-grouping {
    container isis {
      tailf:info "IS-IS commands";
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-compact-syntax;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "md5" {
                tailf:info "Keyed message digest";
              }
              enum "text" {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "level-1" {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum "level-2" {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        leaf key-chain {
          tailf:info "Authentication key-chain";
          type leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
              tailf:xpath-root "3";
            }
          }
        }
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence "true";
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "level-1" {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum "level-2" {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum "level-1" {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum "level-1-2" {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum "level-2-only" {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum "maximum" {
                tailf:info "Maximum metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum "level-1" {
                tailf:info "Apply metric to level-1 links";
              }
              enum "level-2" {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:xpath-root "3";
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum "level-1" {
                tailf:info "Apply metric to level-1 links";
              }
              enum "level-2" {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:xpath-root "3";
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum "level-1" {
                tailf:info "Apply metric to level-1 links";
              }
              enum "level-2" {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:xpath-root "3";
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum "level-1" {
                tailf:info "Apply metric to level-1 links";
              }
              enum "level-2" {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }
  grouping template_ncs_interface-isis-grouping {
    container isis {
      container authentication {
        container mode {
          leaf crypt {
            type string;   // NCS patched all types to string
          }
          leaf level {
            type string;   // NCS patched all types to string
          }
        }
        leaf key-chain {
          type string;   // NCS patched all types to string
        }
        container send-only {
          presence "true";
          leaf level {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf circuit-type {
        type string;   // NCS patched all types to string
      }
      container hello {
        leaf padding {
          type empty;
        }
      }
      container metric {
        leaf metric {
          type string;   // NCS patched all types to string
        }
        leaf delay {
          type string;   // NCS patched all types to string
        }
        leaf expense {
          // NCS drop path statement here
          type string;   // NCS patched all types to string
        }
        leaf error {
          // NCS drop path statement here
          type string;   // NCS patched all types to string
        }
        leaf rest {
          // NCS drop path statement here
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping interface-switch-grouping {
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum "active" {
            tailf:info "Enable LACP unconditionally";
          }
          enum "auto" {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum "desirable" {
            tailf:info "Enable PAgP unconditionally";
          }
          enum "on" {
            tailf:info "Enable Etherchannel only";
          }
          enum "passive" {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }
    container switch {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }
    container switchport-conf {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:cli-boolean-no;
        type boolean;
      }
    }
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-no;
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:vlan/vlan-list" {
            tailf:xpath-root "3";
          }
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode";
            range "1..4094";
          }
        }
      }
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access or trunk mode";
            type enumeration {
              enum "auto" {
                tailf:info "Set trunking mode dynamic negotiation parameter to AUTO";
              }
              enum "desirable" {
                tailf:info "Set trunking mode dynamic negotiation parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        type empty;
      }
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum "tag" {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum "disable" {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum "enable" {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum "disable" {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum "enable" {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum "loop" {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum "none" {
            tailf:info "Set guard mode to none";
          }
          enum "root" {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum "disable" {
            tailf:info "Disable portfast for this interface";
          }
          enum "edge" {
            tailf:info "Enable portfast edge on the interface";
          }
          enum "network" {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }
  }
  grouping template_ncs_interface-switch-grouping {
    container channel-protocol {
      leaf number {
        type string;   // NCS patched all types to string
      }
      leaf mode {
        type string;   // NCS patched all types to string
      }
    }
    container switch {
      container virtual {
        leaf link {
          type string;   // NCS patched all types to string
        }
      }
    }
    container switchport-conf {
      leaf switchport {
        type string;   // NCS patched all types to string
      }
    }
    container switchport {
      container access {
        leaf vlan {
          type string;   // NCS patched all types to string
        }
      }
      container block {
        leaf multicast {
          type empty;
        }
        leaf unicast {
          type empty;
        }
      }
      container mode {
        choice mode-choice {
          leaf access {
            type empty;
          }
          leaf dot1q-tunnel {
            type empty;
          }
          leaf dynamic {
            type string;   // NCS patched all types to string
          }
          leaf trunk {
            type empty;
          }
        }
      }
      leaf nonegotiate {
        type empty;
      }
      container trunk {
        container allowed {
          container vlan {
            choice vlan-choice {
              leaf-list vlans {
                ordered-by "user";  // NCS patched to keep predictable order
                type string;   // NCS patched all types to string
              }
              leaf all {
                type empty;
              }
              leaf-list except {
                ordered-by "user";  // NCS patched to keep predictable order
                type string;   // NCS patched all types to string
              }
              leaf none {
                type empty;
              }
            }
          }
        }
        container native {
          leaf vlan {
            type string;   // NCS patched all types to string
          }
        }
        container pruning {
          container vlan {
            choice vlan-choice {
              leaf-list vlans {
                ordered-by "user";  // NCS patched to keep predictable order
                type string;   // NCS patched all types to string
              }
              leaf-list except {
                ordered-by "user";  // NCS patched to keep predictable order
                type string;   // NCS patched all types to string
              }
              leaf none {
                type empty;
              }
            }
          }
        }
      }
    }
    container spanning-tree {
      leaf bpdufilter {
        type string;   // NCS patched all types to string
      }
      leaf bpduguard {
        type string;   // NCS patched all types to string
      }
      leaf guard {
        type string;   // NCS patched all types to string
      }
      leaf portfast {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping interface-bundle-grouping {
    container bundle {
      tailf:info "Bundle interface commands";
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds (default: 2000)";
          range "0..2000";
        }
      }
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only effective on links with LACP enabled)";
            type empty;
          }
        }
      }
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";
        leaf links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
          }
        }
      }
    }
    container lacp {
      tailf:info "Bundle interface LACP commands";
      container switchover {
        tailf:info "Modify behavior for switching between links in this bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }
    }
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which this bundle should operate.";
          range "1..4294967295";
        }
      }
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value is higher priority.";
          range "1..65535";
        }
      }
      container switchover {
        tailf:info "Set the parameters for performing a switchover to/from the mLACP peer";
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence "true";
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }
        leaf type {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum "brute-force" {
              tailf:info "Force switchover by disabling all local member links";
            }
            enum "revertive" {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }
  grouping template_ncs_interface-bundle-grouping {
    container bundle {
      leaf wait-while {
        type string;   // NCS patched all types to string
      }
      container maximum-active {
        container links {
          leaf number {
            type string;   // NCS patched all types to string
          }
          leaf hot-standby {
            type empty;
          }
        }
      }
      container minimum-active {
        leaf links {
          type string;   // NCS patched all types to string
        }
      }
    }
    container lacp {
      container switchover {
        leaf suppress-flaps {
          type string;   // NCS patched all types to string
        }
      }
    }
    container mlacp {
      leaf iccp-group {
        type string;   // NCS patched all types to string
      }
      leaf port-priority {
        type string;   // NCS patched all types to string
      }
      container switchover {
        container maximize {
          container links {
            presence "true";
            leaf threshold {
              type string;   // NCS patched all types to string
            }
          }
        }
        leaf recovery-delay {
          type string;   // NCS patched all types to string
        }
        leaf type {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping interface-non-bundle-grouping {
    container bundle {
      tailf:info "Link aggregation per-interface commands";
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum "active" {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum "on" {
              tailf:info "Do not run LACP over the port.";
            }
            enum "passive" {
              tailf:info "Run LACP in passive mode over the port.";
            }
          }
        }
      }
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. Lower value is higher priority.";
          range "1..65535";
        }
      }
    }
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period (in milliseconds) for the partner system (must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-delete-when-empty;
          presence "true";
        }
      }
    }
  }
  grouping template_ncs_interface-non-bundle-grouping {
    container bundle {
      container id {
        leaf id-value {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
      }
      leaf port-priority {
        type string;   // NCS patched all types to string
      }
    }
    container lacp {
      container period {
        leaf period-value {
          type string;   // NCS patched all types to string
        }
        container short {
          presence "true";
        }
      }
    }
  }
  grouping interface-pointtopoint-grouping {
    container keepalive {
      choice keepalive-choice {
        container values {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval (default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count (default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }
    leaf encapsulation {
      tailf:info "Set the encapsulation on an interface";
      type enumeration {
        enum "frame-relay" {
          tailf:info "Frame Relay networks";
        }
        enum "hdlc" {
          tailf:info "Serial HDLC synchronous";
        }
        enum "mfr" {
          tailf:info "Multilink Frame Relay Member Link";
        }
        enum "ppp" {
          tailf:info "Point-to-Point protocol";
        }
      }
    }
  }
  grouping template_ncs_interface-pointtopoint-grouping {
    container keepalive {
      choice keepalive-choice {
        container values {
          leaf interval {
            type string;   // NCS patched all types to string
          }
          leaf retry {
            type string;   // NCS patched all types to string
          }
        }
        leaf disable {
          type empty;
        }
      }
    }
    leaf encapsulation {
      type string;   // NCS patched all types to string
    }
  }
  grouping interface-ethernet-grouping {
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum "full" {
          tailf:code-name "duplex_full";
          tailf:info "Full duplex";
        }
        enum "half" {
          tailf:code-name "duplex_half";
          tailf:info "Half duplex";
        }
      }
    }
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-udld";
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum "aggressive" {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum "normal" {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }
      }
    }
    container ethernet-services {
      tailf:info "Ethernet related services";
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "direction";
        leaf direction {
          type enumeration {
            enum "egress" {
              tailf:info "Filter outgoing packets";
            }
            enum "ingress" {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type leafref {
            tailf:info "WORD;;Access-list name";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ethernet-services/access-list/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
    }
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
      }
    }
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "10" {
          tailf:info "Ethernet is 10Mb";
        }
        enum "100" {
          tailf:info "Ethernet is 100Mb";
        }
        enum "1000" {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info "permit";
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info "all";
            type empty;
          }
        }
      }
    }
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-nV";
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-satellite-fabric-link";
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        container remote-ports {
          tailf:cli-break-sequence-commands;
          tailf:info "Remote ports configuration";
          leaf GigabitEthernet {
            tailf:info "Remote ports type";
            type string {
              tailf:info "Slot/Subslot/Port(s)";
            }
          }
        }
      }
    }
  }
  grouping template_ncs_interface-ethernet-grouping {
    container carrier-delay {
      leaf up {
        type string;   // NCS patched all types to string
      }
      leaf down {
        type string;   // NCS patched all types to string
      }
    }
    leaf duplex {
      type string;   // NCS patched all types to string
    }
    container ethernet {
      container udld {
        leaf mode {
          type string;   // NCS patched all types to string
        }
      }
    }
    container ethernet-services {
      list access-group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "direction";
        leaf direction {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
    }
    leaf mac-address {
      type string;   // NCS patched all types to string
    }
    leaf speed {
      type string;   // NCS patched all types to string
    }
    container transceiver {
      container permit {
        container pid {
          leaf all {
            type empty;
          }
        }
      }
    }
    container nv {
      container satellite-fabric-link {
        leaf satellite {
          type string;   // NCS patched all types to string
        }
        container remote-ports {
          leaf GigabitEthernet {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
  }
  grouping interface-common-grouping {
    leaf description {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }
    container frequency {
      tailf:info "Frequency Synchronization configuration";
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-freqsync";
        container quality {
          tailf:info "Quality level configuration";
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            container highest {
              tailf:info "Specify the highest acceptable QL value";
              container itu-t {
                tailf:info "ITU-T QL options";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf option {
                  tailf:info "ITU-T QL options";
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum "1" {
                      tailf:info "ITU-T QL option 1";
                    }
                    enum "2" {
                      tailf:info "ITU-T QL option 2";
                    }
                  }
                }
                leaf generation {
                  tailf:info "ITU-T QL option 2 generation";
                  tailf:cli-incomplete-command;
                  when "../option = '2'" {
                    tailf:xpath-root "3";
                  }
                  type enumeration {
                    enum "1" {
                      tailf:info "ITU-T QL option 2, generation 1";
                    }
                    enum "2" {
                      tailf:info "ITU-T QL option 2, generation 2";
                    }
                  }
                }
                leaf ql2 {
                  tailf:cli-no-keyword;
                  tailf:cli-drop-node-name;
                  when "../option = '2'" {
                    tailf:xpath-root "3";
                  }
                  type enumeration {
                    enum "DUS" {
                      tailf:info "This signal should not be used for synchronization";
                    }
                    enum "PRS" {
                      tailf:info "ITU-T Option 2, Primary reference source";
                    }
                    enum "SMC" {
                      tailf:info "ITU-T Option 2, SONET clock self timed";
                    }
                    enum "ST2" {
                      tailf:info "ITU-T Option 2, Stratum 2";
                    }
                    enum "ST3" {
                      tailf:info "ITU-T Option 2, Stratum 3";
                    }
                    enum "ST3E" {
                      tailf:info "ITU-T Option 2, Stratum 3E";
                    }
                    enum "STU" {
                      tailf:info "ITU-T Option 2, Synchronized - traceability unknown";
                    }
                    enum "TNC" {
                      tailf:info "ITU-T Option 2, Transit node clock";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container ipv4 {
      tailf:info "IPv4 interface subcommands";
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }
      container address {
        tailf:info "Set the IPv4 address of an interface";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf ip {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
        leaf secondary {
          tailf:info "Make this IPv4 address a secondary address";
          type empty;
        }
      }
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "direction";
        leaf direction {
          type enumeration {
            enum "egress" {
              tailf:info "Filter outgoing packets";
            }
            enum "ingress" {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type leafref {
            tailf:info "WORD;;access-list name";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        choice helper-address-choice {
          leaf local {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          container vrf {
            tailf:info "VRF name for helper-address (if different from interface VRF)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP destination address";
              }
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;  IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;  IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "100..65535";
                }
                must "../msec" {
                  tailf:xpath-root "3";
                }
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence "true";
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf list {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }
                  }
                }
                leaf route-map {
                  tailf:info "Route-map";
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence "true";
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container notification {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }
          container source {
            tailf:info "Validation of source address";
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum "any" {
                  tailf:info "Source is reachable via any interface";
                }
                enum "rx" {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
          }
        }
      }
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence "true";
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses interface-name-grouping;
      }
    }
    container ipv6 {
      tailf:info "IPv6 interface subcommands";
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "direction";
        leaf direction {
          type enumeration {
            enum "egress" {
              tailf:info "Filter outgoing packets";
            }
            enum "ingress" {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type leafref {
            tailf:info "WORD;;access-list name";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv6/access-list/named-acl/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          key "prefix";
          leaf prefix {
            type ipv6-prefix {
              tailf:info "X:X::X/length;;IPv6 prefix";
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }
      uses interface-ipv6-nd-grouping;
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum "any" {
                  tailf:info "Source is reachable via any interface";
                }
                enum "rx" {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }
    }
    uses interface-isis-grouping;
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step "30";
        }
      }
    }
    container logging {
      tailf:info "Configure logging for interface";
      container events {
        tailf:info "Interface events";
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          presence "true";
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is transitioning";
            type empty;
          }
        }
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }
      }
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info "Access-list";
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-mpls";
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the stack";
          tailf:cli-full-command;
          type enumeration {
            enum "drop" {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }
    uses interface-service-policy-grouping;
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-full-command;
      type empty;
    }
    container storm-control {
      tailf:info "storm configuration";
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits "2";
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits "2";
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits "2";
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits "2";
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
    }
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:vrf/vrf-list" {
        tailf:xpath-root "3";
      }
      type string {
        tailf:info "WORD;;VRF name";
      }
    }
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence "true";
      leaf half-life {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }
  }
  grouping template_ncs_interface-common-grouping {
    leaf description {
      type string;   // NCS patched all types to string
    }
    leaf bandwidth {
      type string;   // NCS patched all types to string
    }
    container frequency {
      container synchronization {
        container quality {
          container transmit {
            container highest {
              container itu-t {
                leaf option {
                  type string;   // NCS patched all types to string
                }
                leaf generation {
                  // NCS drop path statement here
                  type string;   // NCS patched all types to string
                }
                leaf ql2 {
                  // NCS drop path statement here
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
        }
      }
    }
    container ipv4 {
      leaf point-to-point {
        type empty;
      }
      container address {
        leaf ip {
          type string;   // NCS patched all types to string
        }
        leaf mask {
          type string;   // NCS patched all types to string
        }
        leaf secondary {
          type empty;
        }
      }
      list access-group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "direction";
        leaf direction {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
      container helper-address {
        choice helper-address-choice {
          leaf local {
            type string;   // NCS patched all types to string
          }
          leaf global {
            type string;   // NCS patched all types to string
          }
          container vrf {
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf address {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      leaf mtu {
        type string;   // NCS patched all types to string
      }
      container pim {
        leaf bidir-neighbor-filter {
          type string;   // NCS patched all types to string
        }
        leaf bsr-border {
          type empty;
        }
        leaf dr-priority {
          type string;   // NCS patched all types to string
        }
        leaf nbma-mode {
          type empty;
        }
        leaf neighbor-filter {
          type string;   // NCS patched all types to string
        }
        container query-interval {
          choice interval-choice {
            case secs {
              leaf secs {
                type string;   // NCS patched all types to string
              }
            }
            case msec {
              leaf msecs {
                type string;   // NCS patched all types to string
                // NCS drop path statement here
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            type empty;
          }
          container dense-mode {
            presence "true";
            container proxy-register {
              choice proxy-mode {
                leaf list {
                  type string;   // NCS patched all types to string
                }
                leaf route-map {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
          leaf sparse-mode {
            type empty;
          }
        }
        container state-refresh {
          container origination-interval {
            presence "true";
            leaf secs {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container verify {
        container unicast {
          container notification {
            leaf threshold {
              type string;   // NCS patched all types to string
            }
          }
          container source {
            leaf reachable-via {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container router {
        container isis {
          presence "true";
          leaf routing-process {
            type string;   // NCS patched all types to string
          }
        }
      }
      container unnumbered {
        uses template_ncs_interface-name-grouping;
      }
    }
    container ipv6 {
      list access-group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "direction";
        leaf direction {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
      container address {
        list prefix-list {
          ordered-by "user";  // NCS patched to keep predictable order
          key "prefix";
          leaf prefix {
            type string;   // NCS patched all types to string
          }
          leaf eui-64 {
            type empty;
          }
          leaf route-tag {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf enable {
        type empty;
      }
      uses template_ncs_interface-ipv6-nd-grouping;
      container verify {
        container unicast {
          container source {
            leaf reachable-via {
              type string;   // NCS patched all types to string
            }
            leaf allow-default {
              type empty;
            }
            leaf allow-self-ping {
              type empty;
            }
          }
        }
      }
    }
    uses template_ncs_interface-isis-grouping;
    leaf load-interval {
      type string;   // NCS patched all types to string
    }
    container logging {
      container events {
        leaf bundle-status {
          type empty;
        }
        leaf link-status {
          type empty;
        }
        leaf nfas-status {
          type empty;
        }
        container spanning-tree {
          leaf status {
            type empty;
          }
        }
        container subif-link-status {
          presence "true";
          leaf ignore-bulk {
            type empty;
          }
        }
        leaf trunk-status {
          type empty;
        }
      }
      container ip {
        container access-list {
          container cache {
            leaf in {
              type empty;
            }
            leaf out {
              type empty;
            }
          }
        }
      }
    }
    container mpls {
      leaf ip {
        type empty;
      }
      container label-security {
        leaf rpf {
          type empty;
        }
        leaf multi-label-packet {
          type string;   // NCS patched all types to string
        }
      }
      leaf mtu {
        type string;   // NCS patched all types to string
      }
    }
    leaf mtu {
      type string;   // NCS patched all types to string
    }
    leaf proxy-arp {
      type empty;
    }
    uses template_ncs_interface-service-policy-grouping;
    leaf shutdown {
      type empty;
    }
    container storm-control {
      container action {
        leaf level {
          type string;   // NCS patched all types to string
        }
      }
      container broadcast {
        leaf level {
          type string;   // NCS patched all types to string
        }
      }
      container multicast {
        leaf level {
          type string;   // NCS patched all types to string
        }
      }
      container unicast {
        leaf level {
          type string;   // NCS patched all types to string
        }
      }
    }
    leaf vrf {
      type string;   // NCS patched all types to string
    }
    container dampening {
      presence "true";
      leaf half-life {
        type string;   // NCS patched all types to string
      }
      leaf reuse {
        type string;   // NCS patched all types to string
      }
      leaf suppress {
        type string;   // NCS patched all types to string
      }
      leaf max-suppress-time {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping subinterface-common-grouping {
    container encapsulation {
      tailf:info "Specify which packets will be matched by this sub-interface";
      choice encapsulation-choice {
        leaf default {
          tailf:info "Packets unmatched by other service instances";
          type empty;
        }
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence "true";
        }
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf vlan-id {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string;
              type enumeration {
                enum "any" {
                  tailf:info "Match any VLAN id";
                }
                enum "priority-tagged" {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf second-dot1q {
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string;
              type enumeration {
                enum "any" {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf vlan-id {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string;
              type enumeration {
                enum "any" {
                  tailf:info "Match any VLAN id";
                }
                enum "priority-tagged" {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string;
              type enumeration {
                enum "any" {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
        }
      }
    }
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf pop {
            tailf:info "Remove one or more tags";
            type uint16;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "symmetric";
            }
          }
        }
      }
    }
    container dot1q {
      leaf vlan {
        type uint16 {
          tailf:info "<1-4094>;;VLAN ID";
          range "1..4094";
        }
      }
    }
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        tailf:cli-full-command;
        type enumeration {
          enum "drop" {
            tailf:info "Drop these protocol packets";
          }
          enum "reverse-tunnel" {
            tailf:info "Tunnel at egress";
          }
          enum "tunnel" {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }
  }
  grouping template_ncs_subinterface-common-grouping {
    container encapsulation {
      choice encapsulation-choice {
        leaf default {
          type empty;
        }
        container untagged {
          presence "true";
        }
        container dot1q {
          leaf vlan-id {
            type string;   // NCS patched all types to string
          }
          leaf second-dot1q {
            type string;   // NCS patched all types to string
          }
          leaf exact {
            type empty;
          }
          container ingress {
            leaf source-mac {
              type string;   // NCS patched all types to string
            }
          }
        }
        container dot1ad {
          leaf vlan-id {
            type string;   // NCS patched all types to string
          }
          leaf dot1q {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container rewrite {
      container ingress {
        container tag {
          leaf pop {
            type string;   // NCS patched all types to string
          }
          leaf mode {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container dot1q {
      leaf vlan {
        type string;   // NCS patched all types to string
      }
    }
    container l2protocol {
      leaf cpsv {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping non-subinterface-common-grouping {
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }
    container bfd {
      tailf:info "BFD interface configuration commands";
      container address-family {
        tailf:info "Set configuration for a given address family";
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD session";
              range "2..50";
            }
          }
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            tailf:cli-full-command;
            type empty;
          }
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD session";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-30000>;;The preferred minimum interval (in ms) for the BFD session";
              range "15..30000";
            }
          }
        }
      }
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      type empty;
      tailf:cli-full-command;
    }
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its configuration submode";
      presence "true";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-l2";
    }
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default "true";
          tailf:cli-trim-default;
        }
      }
    }
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }
    uses interface-switch-grouping;
  }
  grouping template_ncs_non-subinterface-common-grouping {
    container backup {
      container interface {
        uses template_ncs_interface-name-grouping;
      }
    }
    container bfd {
      container address-family {
        container ipv4 {
          leaf multiplier {
            type string;   // NCS patched all types to string
          }
          leaf destination {
            type string;   // NCS patched all types to string
          }
          leaf fast-detect {
            type empty;
          }
          leaf minimum-interval {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf echo {
        type empty;
      }
      container interval {
        leaf msecs {
          type string;   // NCS patched all types to string
        }
        leaf min_rx {
          type string;   // NCS patched all types to string
        }
        leaf multiplier {
          type string;   // NCS patched all types to string
        }
      }
    }
    leaf cdp {
      type empty;
    }
    container dual-active {
      leaf fast-hello {
        type empty;
      }
    }
    container l2transport {
      presence "true";
    }
    container platform {
      container qos {
        leaf channel-consistency {
          type string;   // NCS patched all types to string
          // NCS drop  (default) statement
        }
      }
    }
    container xconnect {
      leaf vfi {
        type string;   // NCS patched all types to string
      }
    }
    uses template_ncs_interface-switch-grouping;
  }
  grouping interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Bundle-Ether/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/BVI/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/GigabitEthernet/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf HundredGigE {
        tailf:info "HundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/HundredGigE/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<0-2147483647>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Loopback/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/MgmtEth/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Multilink/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-0>";
          pattern "0";
        }
      }
      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-512>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Port-channel/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/POS/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Serial/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-ip/id" {
            tailf:xpath-root "3";
          }
        }
      }
      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-te/id" {
            tailf:xpath-root "3";
          }
        }
      }
    }
  }
  grouping template_ncs_interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        type string;   // NCS patched all types to string
      }
      leaf BVI {
        type string;   // NCS patched all types to string
      }
      leaf GigabitEthernet {
        type string;   // NCS patched all types to string
      }
      leaf HundredGigE {
        type string;   // NCS patched all types to string
      }
      leaf Loopback {
        type string;   // NCS patched all types to string
      }
      leaf MgmtEth {
        type string;   // NCS patched all types to string
      }
      leaf Multilink {
        type string;   // NCS patched all types to string
      }
      leaf Null {
        type string;   // NCS patched all types to string
      }
      leaf Port-channel {
        type string;   // NCS patched all types to string
      }
      leaf POS {
        type string;   // NCS patched all types to string
      }
      leaf Serial {
        type string;   // NCS patched all types to string
      }
      leaf tunnel-ip {
        type string;   // NCS patched all types to string
      }
      leaf tunnel-te {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping interface-grouping {
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }
    container Bundle-Ether-subinterface {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key "id";
        leaf id {
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "l2transport";
            enum "symmetric";
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern ".+/.+/.+/.+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container TenGigE-subinterface {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key "id";
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "l2transport";
            enum "symmetric";
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list HundredGigE {
      tailf:info "HundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container HundredGigE-subinterface {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key "id";
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "l2transport";
            enum "symmetric";
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container GigabitEthernet-subinterface {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key "id";
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "l2transport";
            enum "symmetric";
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
    }
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pos";
        leaf crc {
          tailf:cli-full-command;
          type enumeration {
            enum "16" {
              tailf:info "16-bit CRC mode ";
            }
            enum "32" {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      container tunnel {
        container mode {
          leaf gre {
            type enumeration {
              enum "ipv4";
            }
          }
        }
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string;
        }
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Ip Address";
          }
        }
      }
    }
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-autobw";
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          container threshold {
            tailf:info "Set the bandwidth change percent to trigger an overflow";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percentage {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>  Bandwidth change percent to trigger an overflow";
                range "1..100";
              }
            }
            leaf min {
              tailf:info "Set the bandwidth change value to trigger an overflow";
              tailf:cli-optional-in-sequence;
              type uint32 {
                tailf:info "<10-4294967295>;;Bandwidth change value to trigger an overflow (kbps)";
                range "10..4294967295";
              }
            }
            leaf limit {
              tailf:info "Set the number of consecutive collections exceeding threshold";
              type uint8 {
                tailf:info "<1-10>;;Number of consecutive collections exceeding threshold";
                range "1..10";
              }
            }
          }
        }
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger adjustment";
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Bandwidth change percent to trigger adjustment";
              range "1..100";
            }
          }
          leaf min {
            tailf:info "Set the bandwidth change value to trigger adjustment";
            type uint32 {
              tailf:info "<10-4294967295>;;Bandwidth change value to trigger adjustment (kbps)";
              range "10..4294967295";
            }
          }
        }
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";
        leaf announce {
          tailf:info "Announce tunnel to IGP";
          type empty;
        }
      }
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;Destination address";
        }
      }
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container path-selection {
        tailf:info "Path Selection Configuration";
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum "igp" {
                tailf:info "Use IGP metric";
              }
              enum "te" {
                tailf:info "Use TE metric";
              }
            }
          }
        }
      }
      container priority {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf setup {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-7>;;Setup Priority";
            range "0..7";
          }
        }
        leaf hold-value {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;Hold Priority";
          }
        }
      }
      leaf fast-reroute {
        tailf:info "Specify MPLS tunnel can be fast-rerouted";
        tailf:cli-full-command;
        type empty;
      }
      leaf record-route {
        tailf:info "Record the route used by the tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container path-option {
        tailf:info "Primary or fallback path setup option";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf preference-priority {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1000>;;Preference for this path option";
            range "1..1000";
          }
        }
        container dynamic {
          tailf:info "Setup based on dynamically allocated path";
          tailf:cli-compact-syntax;
          presence "true";
        }
      }
    }
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
    }
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key "id";
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink";
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }
    }
  }
  grouping template_ncs_interface-grouping {
    list Loopback {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
    }
    list Bundle-Ether {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-bundle-grouping;
    }
    container Bundle-Ether-subinterface {
      list Bundle-Ether {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_interface-common-grouping;
        uses template_ncs_interface-ethernet-grouping;
        uses template_ncs_subinterface-common-grouping;
      }
    }
    list MgmtEth {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-non-bundle-grouping;
    }
    list TenGigE {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-non-bundle-grouping;
    }
    container TenGigE-subinterface {
      list TenGigE {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_interface-common-grouping;
        uses template_ncs_interface-ethernet-grouping;
        uses template_ncs_subinterface-common-grouping;
      }
    }
    list HundredGigE {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-non-bundle-grouping;
    }
    container HundredGigE-subinterface {
      list HundredGigE {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_interface-common-grouping;
        uses template_ncs_interface-ethernet-grouping;
        uses template_ncs_subinterface-common-grouping;
      }
    }
    list GigabitEthernet {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-non-bundle-grouping;
    }
    container GigabitEthernet-subinterface {
      list GigabitEthernet {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_interface-common-grouping;
        uses template_ncs_interface-ethernet-grouping;
        uses template_ncs_subinterface-common-grouping;
      }
    }
    list Port-channel {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_interface-ethernet-grouping;
      uses template_ncs_non-subinterface-common-grouping;
    }
    list POS {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-pointtopoint-grouping;
      container pos {
        leaf crc {
          type string;   // NCS patched all types to string
        }
      }
    }
    list BVI {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
    }
    list Vlan {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
    }
    list tunnel-ip {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      container tunnel {
        container mode {
          leaf gre {
            type string;   // NCS patched all types to string
          }
        }
        leaf source {
          type string;   // NCS patched all types to string
        }
        leaf destination {
          type string;   // NCS patched all types to string
        }
      }
    }
    list tunnel-te {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      container auto-bw {
        container bw-limit {
          leaf min {
            type string;   // NCS patched all types to string
          }
          leaf max {
            type string;   // NCS patched all types to string
          }
        }
        container overflow {
          container threshold {
            leaf percentage {
              type string;   // NCS patched all types to string
            }
            leaf min {
              type string;   // NCS patched all types to string
            }
            leaf limit {
              type string;   // NCS patched all types to string
            }
          }
        }
        container adjustment-threshold {
          leaf percentage {
            type string;   // NCS patched all types to string
          }
          leaf min {
            type string;   // NCS patched all types to string
          }
        }
        leaf application {
          type string;   // NCS patched all types to string
        }
      }
      container autoroute {
        leaf announce {
          type empty;
        }
      }
      leaf destination {
        type string;   // NCS patched all types to string
      }
      leaf soft-preemption {
        type empty;
      }
      container path-selection {
        container metric {
          leaf metric-type {
            type string;   // NCS patched all types to string
          }
        }
      }
      container priority {
        leaf setup {
          type string;   // NCS patched all types to string
        }
        leaf hold-value {
          type string;   // NCS patched all types to string
        }
      }
      leaf fast-reroute {
        type empty;
      }
      leaf record-route {
        type empty;
      }
      container path-option {
        leaf preference-priority {
          type string;   // NCS patched all types to string
        }
        container dynamic {
          presence "true";
        }
      }
    }
    list Multilink {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-pointtopoint-grouping;
    }
    list Serial {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_interface-common-grouping;
      uses template_ncs_non-subinterface-common-grouping;
      uses template_ncs_interface-pointtopoint-grouping;
      container multilink {
        leaf group {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping bgp-address-family-ipv46-grouping {
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }
    }
    container additional-paths {
      tailf:info "Additional paths configuration";
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }
      container selection {
        tailf:info "Additional paths selection";
        list route-policy {
          tailf:info "Route-policy for additional paths selection";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                tailf:xpath-root "3";
              }
            }
          }
        }
      }
    }
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type enumeration {
        enum "reset-on-import" {
          tailf:info "Reset weight of paths on import";
        }
      }
    }
    container nexthop {
      tailf:info "Nexthop";
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value (only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "true";
        leaf metric {
          tailf:info "Metric for redistributed routes";
          type uint32 {
            tailf:info "<0-4294967295>;;Default metric";
          }
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type leafref {
            tailf:info "WORD;;Name of the policy";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "true";
        leaf metric {
          tailf:info "Metric for redistributed routes";
          type uint32 {
            tailf:info "<0-4294967295>;;Default metric";
          }
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type leafref {
            tailf:info "WORD;;Name of the policy";
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root "3";
            }
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update generation configuration";
      container limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
        }
      }
    }
  }
  grouping template_ncs_bgp-address-family-ipv46-grouping {
    container retain {
      leaf local-label {
        type string;   // NCS patched all types to string
      }
    }
    container additional-paths {
      leaf receive {
        type empty;
      }
      container selection {
        list route-policy {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    leaf weight {
      type string;   // NCS patched all types to string
    }
    container nexthop {
      container resolution {
        container prefix-length {
          leaf minimum {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf route-policy {
        type string;   // NCS patched all types to string
      }
    }
    container redistribute {
      container connected {
        presence "true";
        leaf metric {
          type string;   // NCS patched all types to string
        }
        leaf route-policy {
          type string;   // NCS patched all types to string
        }
      }
      container static {
        presence "true";
        leaf metric {
          type string;   // NCS patched all types to string
        }
        leaf route-policy {
          type string;   // NCS patched all types to string
        }
      }
    }
    container update {
      container limit {
        leaf address-family {
          type string;   // NCS patched all types to string
        }
        container sub-group {
          leaf ebgp {
            type string;   // NCS patched all types to string
          }
          leaf ibgp {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
  }
  grouping bgp-address-family-ipv4-grouping {
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key "net";
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    uses bgp-address-family-ipv46-grouping;
  }
  grouping template_ncs_bgp-address-family-ipv4-grouping {
    list network {
      ordered-by "user";  // NCS patched to keep predictable order
      key "net";
      leaf net {
        type string;   // NCS patched all types to string
      }
      leaf backdoor {
        type empty;
      }
      leaf route-policy {
        type string;   // NCS patched all types to string
      }
    }
    uses template_ncs_bgp-address-family-ipv46-grouping;
  }
  grouping bgp-address-family-ipv6-grouping {
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key "net";
      leaf net {
        type ipv6-prefix {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    uses bgp-address-family-ipv46-grouping;
  }
  grouping template_ncs_bgp-address-family-ipv6-grouping {
    list network {
      ordered-by "user";  // NCS patched to keep predictable order
      key "net";
      leaf net {
        type string;   // NCS patched all types to string
      }
      leaf backdoor {
        type empty;
      }
      leaf route-policy {
        type string;   // NCS patched all types to string
      }
    }
    uses template_ncs_bgp-address-family-ipv46-grouping;
  }
  grouping bgp-address-family-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv6 {
        tailf:info "VPNv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv6-grouping;
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv6-grouping;
        }
      }
    }
  }
  grouping template_ncs_bgp-address-family-grouping {
    container address-family {
      container ipv4 {
        container labeled-unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
        container mdt {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
      }
      container l2vpn {
        container vpls-vpws {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv4 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv6 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv6-grouping;
        }
      }
      container ipv6 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv6-grouping;
        }
      }
    }
  }
  grouping bgp-neighbor-grouping {
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<15-30000>;;hello interval in milli-seconds";
          range "15..30000";
        }
      }
    }
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern "[0-9]+\\.[0-9]+";
        }
      }
    }
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
          container accept-own {
            tailf:info "Handle self-originated routes with Accept-Own community";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence "true";
            leaf inheritance-disable {
              tailf:info "Prevent item being inherited from a parent group";
              type empty;
            }
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv6-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence "true";
          uses bgp-address-family-ipv6-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
    }
    leaf ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      type uint8 {
        range "1..255";
      }
    }
    leaf keychain {
      tailf:info "Set keychain based authentication";
      type leafref {
        path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
          tailf:xpath-root "3";
        }
      }
    }
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence "true";
      leaf group-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "clear";
          enum "encrypted";
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }
    container update-source {
      tailf:info "Source of routing updates";
      tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface" {
        tailf:xpath-root "3";
      }
      uses interface-name-grouping;
    }
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      choice use-choice {
        leaf af-group {
          tailf:info "Inherit configuration from an af-group";
          type string;
        }
        leaf neighbor-group {
          tailf:info "Inherit configuration from a neighbor-group";
          type string;
        }
        leaf session-group {
          tailf:info "Inherit address-family independent config from a session-group";
          type string;
        }
      }
    }
  }
  grouping template_ncs_bgp-neighbor-grouping {
    leaf description {
      type string;   // NCS patched all types to string
    }
    container bfd {
      leaf multiplier {
        type string;   // NCS patched all types to string
      }
      leaf minimum-interval {
        type string;   // NCS patched all types to string
      }
    }
    container timers {
      leaf keepalive {
        type string;   // NCS patched all types to string
      }
      leaf holdtime {
        type string;   // NCS patched all types to string
      }
      leaf min-holdtime {
        type string;   // NCS patched all types to string
      }
    }
    leaf remote-as {
      type string;   // NCS patched all types to string
    }
    container address-family {
      container ipv4 {
        container labeled-unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
        container mdt {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
        container rt-filter {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
      }
      container l2vpn {
        container vpls-vpws {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv4 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv4-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
          container accept-own {
            presence "true";
            leaf inheritance-disable {
              type empty;
            }
          }
        }
      }
      container ipv6 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv6-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv6 {
        container unicast {
          presence "true";
          uses template_ncs_bgp-address-family-ipv6-grouping;
          uses template_ncs_bgp-neighbor-address-family-grouping;
        }
      }
    }
    leaf ebgp-multihop {
      type string;   // NCS patched all types to string
    }
    leaf keychain {
      type string;   // NCS patched all types to string
    }
    container peer-group {
      presence "true";
      leaf group-name {
        type string;   // NCS patched all types to string
      }
    }
    container password {
      leaf enc-type {
        type string;   // NCS patched all types to string
      }
      leaf password {
        type string;   // NCS patched all types to string
      }
    }
    container update-source {
      uses template_ncs_interface-name-grouping;
    }
    container graceful-restart {
      leaf suppress {
        type empty;
      }
      leaf disable {
        type empty;
      }
    }
    container use {
      choice use-choice {
        leaf af-group {
          type string;   // NCS patched all types to string
        }
        leaf neighbor-group {
          type string;   // NCS patched all types to string
        }
        leaf session-group {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping bgp-neighbor-address-family-grouping {
    list route-policy {
      tailf:info "Apply route policy to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "direction";
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Apply route policy to inbound routes";
          }
          enum "out" {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type leafref {
          tailf:info "WORD;;Name of the policy";
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence "true";
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-sequence-commands;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
    }
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence "true";
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the parent";
        type empty;
      }
    }
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence "true";
    }
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence "true";
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited from the parent";
        type empty;
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an af-group";
        tailf:cli-full-command;
        type string;
      }
    }
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf prefix {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum "both" {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to this neighbor";
            }
            enum "none" {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to this neighbor";
            }
            enum "receive" {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum "send" {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }
  }
  grouping template_ncs_bgp-neighbor-address-family-grouping {
    list route-policy {
      ordered-by "user";  // NCS patched to keep predictable order
      key "direction";
      leaf direction {
        type string;   // NCS patched all types to string
      }
      leaf name {
        type string;   // NCS patched all types to string
      }
    }
    container as-override {
      presence "true";
      leaf inheritance-disable {
        type empty;
      }
    }
    container maximum-prefix {
      leaf max-prefix-limit {
        type string;   // NCS patched all types to string
      }
      leaf threshold {
        type string;   // NCS patched all types to string
      }
    }
    container next-hop-self {
      presence "true";
      leaf inheritance-disable {
        type empty;
      }
    }
    leaf route-reflector-client {
      type empty;
    }
    container default-originate {
      presence "true";
    }
    container send-community-ebgp {
      presence "true";
      leaf inheritance-disable {
        type empty;
      }
    }
    container use {
      leaf af-group {
        type string;   // NCS patched all types to string
      }
    }
    container capability {
      container orf {
        leaf prefix {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping router-bgp-cmd-grouping {
    container bgp {
      tailf:info "BGP specific commands";
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay is enforced";
          type empty;
        }
      }
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence "true";
        tailf:cli-display-separated;
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
      }
      container bestpath {
        tailf:info "Change default route selection criteria";
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }
        container med {
          tailf:info "MED related";
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          leaf changes {
            type enumeration {
              enum "detail";
              enum "disable";
            }
          }
        }
      }
      container default {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); default is 512 MB";
          range "16..2048";
        }
      }
    }
    uses bgp-address-family-grouping;
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name "config-bgp-afgrp";
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum "ipv4" {
            tailf:info "IPv4 Address Family";
          }
          enum "ipv6" {
            tailf:info "IPv6 Address Family";
          }
          enum "l2vpn" {
            tailf:info "L2VPN Address Family";
          }
          enum "vpnv4" {
            tailf:info "VPNv4 Address Family";
          }
          enum "vpnv6" {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum "labeled-unicast" {
            tailf:info "Address Family modifier";
          }
          enum "mdt" {
            tailf:info "Address Family modifier";
          }
          enum "multicast" {
            tailf:info "Address Family modifier";
          }
          enum "mvpn" {
            tailf:info "Address Family modifier";
          }
          enum "rt-filter" {
            tailf:info "Address Family modifier";
          }
          enum "tunnel" {
            tailf:info "Address Family modifier";
          }
          enum "unicast" {
            tailf:info "Address Family modifier";
          }
        }
      }
      uses bgp-neighbor-address-family-grouping;
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name "config-bgp-nbr";
      key "id";
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      uses bgp-neighbor-grouping;
    }
    container socket {
      tailf:info "set socket parameters";
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
      }
    }
  }
  grouping template_ncs_router-bgp-cmd-grouping {
    container bgp {
      leaf router-id {
        type string;   // NCS patched all types to string
      }
      leaf cluster-id {
        type string;   // NCS patched all types to string
      }
      leaf scan-time {
        type string;   // NCS patched all types to string
      }
      container update-delay {
        leaf update-delay-value {
          type string;   // NCS patched all types to string
        }
        leaf always {
          type empty;
        }
      }
      container graceful-restart {
        presence "true";
        leaf extended {
          type empty;
        }
        leaf restart-time {
          type string;   // NCS patched all types to string
        }
        leaf stalepath-time {
          type string;   // NCS patched all types to string
        }
      }
      container bestpath {
        leaf compare-routerid {
          type empty;
        }
        container cost-community {
          leaf ignore {
            type empty;
          }
        }
        container med {
          leaf always {
            type empty;
          }
          leaf missing-as-worst {
            type empty;
          }
        }
      }
      container log {
        container neighbor {
          leaf changes {
            type string;   // NCS patched all types to string
          }
        }
      }
      container default {
        leaf local-preference {
          type string;   // NCS patched all types to string
        }
      }
    }
    container update {
      leaf limit {
        type string;   // NCS patched all types to string
      }
    }
    uses template_ncs_bgp-address-family-grouping;
    list af-group {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name address-family af-modifier";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf address-family {
        type string;   // NCS patched all types to string
      }
      leaf af-modifier {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_bgp-neighbor-address-family-grouping;
    }
    list neighbor {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_bgp-neighbor-grouping;
    }
    container socket {
      container receive-buffer-size {
        leaf socket-size {
          type string;   // NCS patched all types to string
        }
        leaf bgp-size {
          type string;   // NCS patched all types to string
        }
      }
      container send-buffer-size {
        leaf socket-size {
          type string;   // NCS patched all types to string
        }
        leaf bgp-size {
          type string;   // NCS patched all types to string
        }
      }
    }
  }
  grouping router-bgp-grouping {
    uses router-bgp-cmd-grouping;
    leaf nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-full-command;
      type empty;
    }
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name "config-bgp-nbrgrp";
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses bgp-neighbor-grouping;
    }
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name "config-bgp-sngrp";
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }
      container update-source {
        tailf:info "Source of routing updates";
        tailf:cli-diff-dependency "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface" {
          tailf:xpath-root "3";
        }
        uses interface-name-grouping;
      }
    }
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name "config-bgp-vrf";
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type union {
          type string {
            tailf:info "<1-4294967295>:<0-4294967295>;;AS number";
          }
        }
      }
      uses router-bgp-cmd-grouping;
    }
  }
  grouping template_ncs_router-bgp-grouping {
    uses template_ncs_router-bgp-cmd-grouping;
    leaf nsr {
      type empty;
    }
    list neighbor-group {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_bgp-neighbor-grouping;
    }
    list session-group {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf remote-as {
        type string;   // NCS patched all types to string
      }
      container advertisement-interval {
        leaf seconds {
          type string;   // NCS patched all types to string
        }
        leaf milliseconds {
          type string;   // NCS patched all types to string
        }
      }
      container update-source {
        uses template_ncs_interface-name-grouping;
      }
    }
    list vrf {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf rd {
        type string;   // NCS patched all types to string
      }
      uses template_ncs_router-bgp-cmd-grouping;
    }
  }
  grouping police-set-grouping {
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }
  }
  grouping template_ncs_police-set-grouping {
    leaf atm-clp {
      type empty;
    }
    container cos {
      leaf cos-value {
        type string;   // NCS patched all types to string
      }
      leaf inner {
        type string;   // NCS patched all types to string
      }
    }
    leaf dei {
      type string;   // NCS patched all types to string
    }
    leaf discard-class {
      type string;   // NCS patched all types to string
    }
    container dscp {
      leaf outer {
        type string;   // NCS patched all types to string
      }
      leaf tunnel {
        type string;   // NCS patched all types to string
      }
    }
    leaf fr-de {
      type string;   // NCS patched all types to string
    }
    container mpls {
      container experimental {
        leaf imposition {
          type string;   // NCS patched all types to string
        }
        leaf topmost {
          type string;   // NCS patched all types to string
        }
      }
    }
    container precedence {
      leaf outer {
        type string;   // NCS patched all types to string
      }
      leaf tunnel {
        type string;   // NCS patched all types to string
      }
    }
    leaf qos-group {
      type string;   // NCS patched all types to string
    }
  }
  grouping police-action-grouping {
    container conform-action {
      tailf:info "Action for conforming traffic";
      tailf:cli-break-sequence-commands;
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }
  grouping template_ncs_police-action-grouping {
    container conform-action {
      leaf drop {
        type empty;
      }
      container set {
        uses template_ncs_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
    container exceed-action {
      leaf drop {
        type empty;
      }
      container set {
        uses template_ncs_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
    container violate-action {
      leaf drop {
        type empty;
      }
      container set {
        uses template_ncs_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
  }
  grouping policy-map-class-grouping {
    container shape {
      tailf:info "Configure shaping for this class";
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              type enumeration {
                enum "bps" {
                  tailf:info "Bits per second (default)";
                }
                enum "cellsps" {
                  tailf:info "Cells per second";
                }
                enum "gbps" {
                  tailf:info "Gigabits per second";
                }
                enum "kbps" {
                  tailf:info "Kilobits per second";
                }
                enum "mbps" {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
        }
        leaf burst {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          type union {
            type police-burst-units-type;
            type enumeration {
              enum "cells" {
                tailf:info "Cells";
              }
            }
          }
        }
      }
    }
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf units {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }
    choice police-choice {
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in percentage of link bandwidth";
                      range "1..100";
                    }
                  }
                }
              }
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst" {
                  tailf:xpath-root "3";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range 7-10,000,000,000";
                  range "7..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate" {
                  tailf:xpath-root "3";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:xpath-root "3";
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst" {
                  tailf:xpath-root "3";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              uses police-action-grouping;
            }
          }
        }
      }
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            uses police-action-grouping;
          }
        }
      }
    }
    container set {
      tailf:info "Configure marking for this class";
      uses police-set-grouping;
    }
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-3>;;Priority level";
          range "1..3";
        }
      }
    }
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf queue-limit-value {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Max Threshold for tail drop";
          range "1..4294967295";
        }
      }
      leaf queue-limit-unit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "bytes" {
            tailf:info "Bytes";
          }
          enum "kbytes" {
            tailf:info "Kilobytes";
          }
          enum "mbytes" {
            tailf:info "Megabytes";
          }
          enum "ms" {
            tailf:info "Milliseconds";
          }
          enum "packets" {
            tailf:info "Packets (default)";
          }
          enum "us" {
            tailf:info "Microseconds";
          }
        }
      }
    }
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "accounting" {
            tailf:info "Accounting policymap";
          }
          enum "control" {
            tailf:info "Control policy-map";
          }
          enum "none" {
            tailf:info "Untyped policymap";
          }
          enum "pbr" {
            tailf:info "PBR policymap";
          }
          enum "performance-traffic" {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum "qos" {
            tailf:info "QoS policymap (default)";
          }
          enum "redirect" {
            tailf:info "Redirect policymap";
          }
          enum "traffic" {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type leafref {
          tailf:info "WORD;;Name of the child service policy";
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
            tailf:xpath-root "3";
          }
        }
      }
    }
    container random-detect {
      tailf:info "Enable Random Early Detection";
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "name";
        leaf name {
          type string {
            tailf:info
              "<0-63>;;Differentiated services codepoint value
               af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43
               cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "name";
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental valueand ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "name";
        leaf name {
          type string {
            tailf:info
              "<0-7>;;Precedence value
               critical,flash,flash-override,immediate,
               internet,network,priority,routine and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
    }
  }
  grouping template_ncs_policy-map-class-grouping {
    container shape {
      container average {
        choice average-choice {
          case percent-case {
            leaf percent {
              type string;   // NCS patched all types to string
            }
          }
          case unit-case {
            leaf rate {
              type string;   // NCS patched all types to string
            }
            leaf rate-unit {
              type string;   // NCS patched all types to string
            }
          }
        }
        leaf burst {
          type string;   // NCS patched all types to string
        }
        leaf burst-unit {
          type string;   // NCS patched all types to string
        }
      }
    }
    container bandwidth {
      container bandwidth-units {
        leaf rate {
          type string;   // NCS patched all types to string
        }
        leaf units {
          type string;   // NCS patched all types to string
        }
      }
      leaf percent {
        type string;   // NCS patched all types to string
      }
      container remaining {
        leaf percent {
          type string;   // NCS patched all types to string
        }
        leaf ratio {
          type string;   // NCS patched all types to string
        }
      }
    }
    choice police-choice {
      case police-rate-unit-case {
        container police-rate-unit {
          container police {
            container rate {
              choice rate-choice {
                case units-case {
                  leaf cir {
                    type string;   // NCS patched all types to string
                  }
                  leaf cir-unit {
                    type string;   // NCS patched all types to string
                  }
                }
                case percent-case {
                  leaf percent {
                    type string;   // NCS patched all types to string
                  }
                }
              }
              leaf burst {
                type string;   // NCS patched all types to string
              }
              leaf burst-units {
                // NCS drop path statement here
                type string;   // NCS patched all types to string
              }
              leaf peak-rate {
                type string;   // NCS patched all types to string
              }
              leaf peak-rate-units {
                // NCS drop path statement here
                type string;   // NCS patched all types to string
              }
              container peak-rate-percent {
                // NCS drop path statement here
                container peak-rate {
                  leaf percent {
                    type string;   // NCS patched all types to string
                  }
                }
              }
              leaf peak-burst {
                type string;   // NCS patched all types to string
              }
              leaf peak-burst-units {
                // NCS drop path statement here
                type string;   // NCS patched all types to string
              }
              uses template_ncs_police-action-grouping;
            }
          }
        }
      }
      case police-unit-case {
        container police-unit {
          container police {
            leaf cir {
              type string;   // NCS patched all types to string
            }
            leaf bc {
              type string;   // NCS patched all types to string
            }
            leaf be {
              type string;   // NCS patched all types to string
            }
            uses template_ncs_police-action-grouping;
          }
        }
      }
    }
    container set {
      uses template_ncs_police-set-grouping;
    }
    container priority {
      leaf level {
        type string;   // NCS patched all types to string
      }
    }
    container queue-limit {
      leaf queue-limit-value {
        type string;   // NCS patched all types to string
      }
      leaf queue-limit-unit {
        type string;   // NCS patched all types to string
      }
    }
    container service-policy {
      leaf type {
        type string;   // NCS patched all types to string
      }
      leaf name {
        type string;   // NCS patched all types to string
      }
    }
    container random-detect {
      list dscp {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_class-random-detect-grouping;
      }
      list exp {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_class-random-detect-grouping;
      }
      list precedence {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_class-random-detect-grouping;
      }
    }
  }
  grouping performance-mgmt-grouping {
    container AverageCpuUsed {
      tailf:info "Average %CPU utilization";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf op {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type operator-type;
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;Threshold value";
          range "0..100";
        }
      }
      leaf percent {
        tailf:info "Specify that threshold value is percent of previous sample";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      container rearm {
        tailf:info "Specify Rearm parameters (default - always)";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        choice rearm-choice {
          leaf toggle {
            tailf:info "Rearm after the first period when condition is not met";
            type empty;
          }
          leaf window {
            tailf:info "Rearm after the window of sampling periods";
            type uint8 {
              tailf:info "<1-100>;;Rearm window size";
              range "1..100";
            }
          }
        }
      }
    }
    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }
  grouping template_ncs_performance-mgmt-grouping {
    container AverageCpuUsed {
      leaf op {
        type string;   // NCS patched all types to string
      }
      leaf threshold {
        type string;   // NCS patched all types to string
      }
      leaf percent {
        type empty;
      }
      container rearm {
        choice rearm-choice {
          leaf toggle {
            type empty;
          }
          leaf window {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    leaf sample-interval {
      type string;   // NCS patched all types to string
    }
  }
  grouping ospf-area-grouping {
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence "true";
      choice authentication-choice {
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence "true";
          leaf keychain {
            tailf:info "Specify keychain name";
            type string {
              tailf:info "WORD;;The keychain name";
            }
          }
        }
        leaf null {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "id";
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        choice md5-choice {
          leaf key {
            tailf:cli-drop-node-name;
            tailf:cli-no-keyword;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED password (key)";
            }
          }
        }
      }
    }
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence "true";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }
      }
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum "broadcast" {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum "non-broadcast" {
          tailf:info "Specify OSPF NBMA network";
        }
        enum "point-to-multipoint" {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum "point-to-point" {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence "true";
        leaf disable {
          tailf:info "Prevent bfd settings from being inherited from the parent";
          type empty;
        }
      }
    }
    container fast-reroute {
      tailf:info "IP Fast Reroute";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      container per-link {
        tailf:info "Per-link Computation";
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        presence "true";
        leaf enable {
          type empty;
        }
      }
    }
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence "true";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "disable" {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum "enable" {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }
    container passive {
      tailf:info "Enable/Disable passive";
      presence "true";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "disable" {
            tailf:info "Disable passive";
          }
          enum "enable" {
            tailf:info "Enable passive";
          }
        }
      }
    }
  }
  grouping template_ncs_ospf-area-grouping {
    leaf cost {
      type string;   // NCS patched all types to string
    }
    container authentication {
      presence "true";
      choice authentication-choice {
        container message-digest {
          presence "true";
          leaf keychain {
            type string;   // NCS patched all types to string
          }
        }
        leaf null {
          type empty;
        }
      }
    }
    list message-digest-key {
      ordered-by "user";  // NCS patched to keep predictable order
      key "id";
      leaf id {
        type string;   // NCS patched all types to string
      }
      container md5 {
        choice md5-choice {
          leaf key {
            type string;   // NCS patched all types to string
          }
          leaf clear {
            type string;   // NCS patched all types to string
          }
          leaf encrypted {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container mpls {
      container ldp {
        container sync {
          presence "true";
          leaf disable {
            type empty;
          }
        }
      }
      leaf traffic-eng {
        type empty;
      }
    }
    leaf network {
      type string;   // NCS patched all types to string
    }
    container bfd {
      container fast-detect {
        presence "true";
        leaf disable {
          type empty;
        }
      }
    }
    container fast-reroute {
      container per-link {
        presence "true";
        leaf enable {
          type empty;
        }
      }
    }
    leaf priority {
      type string;   // NCS patched all types to string
    }
    container mtu-ignore {
      presence "true";
      leaf mode {
        type string;   // NCS patched all types to string
      }
    }
    container passive {
      presence "true";
      leaf mode {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping arp-grouping {
    list arp-list {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "address";
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
        }
      }
      leaf type {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "ARPA" {
            tailf:info "Encapsulation type ARPA";
          }
          enum "SRP" {
            tailf:info "Encapsulation type SRP";
          }
          enum "SRPA" {
            tailf:info "Encapsulation type SRPA";
          }
          enum "SRPB" {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        type empty;
      }
    }
  }
  grouping template_ncs_arp-grouping {
    list arp-list {
      ordered-by "user";  // NCS patched to keep predictable order
      key "address";
      leaf address {
        type string;   // NCS patched all types to string
      }
      leaf mac {
        type string;   // NCS patched all types to string
      }
      leaf type {
        type string;   // NCS patched all types to string
      }
      leaf alias {
        type empty;
      }
    }
  }
  grouping tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "af";
      leaf af {
        type enumeration {
          enum "ipv4" {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum "ipv6" {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum "no-limit" {
              tailf:info "No limit to number of allowable tftp server processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }
  grouping template_ncs_tftp-server-grouping {
    list tftp-server-list {
      ordered-by "user";  // NCS patched to keep predictable order
      key "af";
      leaf af {
        type string;   // NCS patched all types to string
      }
      leaf server {
        type empty;
      }
      leaf homedir {
        type string;   // NCS patched all types to string
      }
      leaf max-servers {
        type string;   // NCS patched all types to string
      }
      leaf access-list {
        type string;   // NCS patched all types to string
      }
    }
  }
  grouping telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "af";
      leaf af {
        type enumeration {
          enum "ipv4" {
            tailf:info "IPv4 configuration";
          }
          enum "ipv6" {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set number of allowable telnet sessions";
        type uint8 {
          tailf:info "<1-100>;;Set number of allowable telnet sessions";
          range "1..100";
        }
      }
      leaf access-list {
        tailf:info "Access list for telnet server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }
  grouping template_ncs_telnet-server-grouping {
    list telnet-server-list {
      ordered-by "user";  // NCS patched to keep predictable order
      key "af";
      leaf af {
        type string;   // NCS patched all types to string
      }
      leaf server {
        type empty;
      }
      leaf max-servers {
        type string;   // NCS patched all types to string
      }
      leaf access-list {
        type string;   // NCS patched all types to string
      }
    }
  }
  augment /ncs:devices/ncs:device/ncs:config {
    container service {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify use of network based services";
      tailf:cli-explicit-exit;
      container alignment {
        tailf:info "Control alignment correction and logging";
        leaf detection {
          tailf:info "Enable detection of alignment issues";
          tailf:cli-full-command;
          type empty;
        }
        leaf logging {
          tailf:info "Enable logging of alignment issues";
          tailf:cli-full-command;
          type empty;
        }
      }
      leaf call-home {
        tailf:info "Enable call-home service";
        tailf:cli-full-command;
        type empty;
      }
      leaf compress-config {
        tailf:info "Compress the nvram configuration file";
        type empty;
        tailf:cli-full-command;
      }
      container counters {
        tailf:info "Control aging of interface counters";
        container max {
          tailf:info "Maximum counter aging threshold";
          leaf age {
            tailf:info "Aging threshold";
            type uint8 {
              tailf:info "<0-60>;;Aging threshold value in seconds";
            }
          }
        }
      }
      leaf dhcp {
        tailf:info "Enable DHCP server and relay agent";
        tailf:cli-full-command;
        type empty;
      }
      leaf disable-ip-fast-frag {
        tailf:info "Disable IP particle-based fast fragmentation";
        type empty;
      }
      leaf exec-callback {
        tailf:info "Enable exec callback";
        type empty;
      }
      leaf exec-wait {
        tailf:info "Delay EXEC startup on noisy lines";
        type empty;
      }
      leaf finger {
        tailf:info "Allow responses to finger requests";
        type empty;
      }
      container heartbeat {
        tailf:info "Enable heartbeat processing";
        leaf fatal-count {
          tailf:info "Set heartbeat fatal count";
          type uint8 {
            range "1..60";
            tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          }
        }
        leaf interrupt-interval {
          tailf:info "Set heartbeat interrupt test interval";
          type uint8 {
            range "0..60";
            tailf:info "<0-60>;;Interval between interrupt level tests";
          }
        }
        leaf interrupt-max {
          tailf:info "Set maximum message count from interrupt test";
          type uint8 {
            tailf:info "<0-60>;;Maximum number of messages from interrupt test";
            range "0..60";
          }
        }
        leaf transmit-interval {
          tailf:info "Set heartbeat transmit interval";
          type uint8 {
            tailf:info "<1-30>;;Interval between heartbeat transmissions";
            range "1..30";
          }
        }
        leaf warning-timeout {
          tailf:info "Set heartbeat warning timeout interval";
          type uint8 {
            tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
            range "5..60";
          }
        }
      }
      leaf hide-telnet-addresses {
        tailf:info "Hide destination addresses in telnet command";
        type empty;
      }
      leaf linenumber {
        tailf:info "enable line number banner for each exec";
        type empty;
      }
      leaf nagle {
        tailf:info "Enable Nagle's congestion control algorithm";
        type empty;
      }
      leaf old-slip-prompts {
        tailf:info "Allow old scripts to operate with slip/ppp";
        type empty;
      }
      container pad {
        tailf:info "Enable PAD commands";
        presence "true";
        leaf cmns {
          tailf:info "Enable PAD over CMNS connections";
          type empty;
        }
        leaf from-xot {
          tailf:info "Accept XOT to PAD connections";
          type empty;
        }
        leaf to-xot {
          tailf:info "Allow outgoing PAD over XOT connections";
          type empty;
        }
      }
      leaf password-encryption {
        tailf:info "Encrypt system passwords";
        type empty;
      }
      container prompt {
        tailf:info "Enable mode specific prompt";
        leaf config {
          tailf:info "Enable configuration mode prompt";
          type empty;
        }
      }
      leaf pt-vty-logging {
        tailf:info "Log significant VTY-Async events";
        type empty;
      }
      leaf sequence-numbers {
        tailf:info "Stamp logger messages with a sequence number";
        type empty;
      }
      leaf slave-log {
        tailf:info "Enable log capability of slave IPs";
        type empty;
      }
      leaf tcp-keepalives-in {
        tailf:info "Generate keepalives on idle incoming network connections";
        type empty;
        tailf:cli-full-command;
      }
      leaf tcp-keepalives-out {
        tailf:info "Generate keepalives on idle outgoing network connections";
        type empty;
        tailf:cli-full-command;
      }
      container tcp-small-servers {
        tailf:info "Enable small TCP servers (e.g., ECHO)";
        presence "true";
        leaf max-servers {
          tailf:info "Set number of allowable TCP small servers";
          type union {
            type uint32 {
              tailf:info "<1-2147483647>;;Maximum TCP small servers";
              range "1..2147483647";
            }
            type enumeration {
              enum "no-limit" {
                tailf:info "No limit to number of allowable TCP small servers";
              }
            }
          }
        }
      }
      leaf telnet-zeroidle {
        tailf:info "Set TCP window 0 when connection is idle";
        type empty;
      }
      container timestamps {
        tailf:info "Timestamp debug/log messages";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "true";
        container debug {
          tailf:info "Timestamp debug messages";
          choice log-time-choice {
            container datetime {
              tailf:info "Timestamp with date and time";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence "true";
              leaf localtime {
                tailf:info "Use local time zone for timestamps";
                type empty;
              }
              leaf msec {
                tailf:info "Include milliseconds in timestamp";
                type empty;
              }
              leaf show-timezone {
                tailf:info "Add time zone information to timestamp";
                type empty;
              }
              leaf year {
                tailf:info "Include year in timestamp";
                type empty;
              }
            }
            leaf uptime {
              tailf:info "Timestamp with system uptime";
              type empty;
            }
          }
        }
        container log {
          tailf:info "Timestamp log messages";
          choice log-time-choice {
            container datetime {
              tailf:info "Timestamp with date and time";
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence "true";
              leaf localtime {
                tailf:info "Use local time zone for timestamps";
                type empty;
              }
              leaf msec {
                tailf:info "Include milliseconds in timestamp";
                type empty;
              }
              leaf show-timezone {
                tailf:info "Add time zone information to timestamp";
                type empty;
              }
              leaf year {
                tailf:info "Include year in timestamp";
                type empty;
              }
            }
            leaf uptime {
              tailf:info "Timestamp with system uptime";
              type empty;
            }
          }
        }
      }
      container udp-small-servers {
        tailf:info "Enable small UDP servers (e.g., ECHO)";
        presence "true";
        leaf max-servers {
          tailf:info "Set number of allowable UDP small servers";
          type union {
            type uint32 {
              tailf:info "<1-2147483647>;;Maximum UDP small servers";
              range "1..2147483647";
            }
          }
        }
      }
      leaf unsupported-transceiver {
        tailf:cli-full-command;
        type empty;
      }
    }
    container configuration {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configuration related settings";
      tailf:cli-explicit-exit;
      container display {
        tailf:info "Display mode";
        container interface {
          tailf:info "hardware interfaces";
          leaf slot-order {
            tailf:info "Display interfaces in the slot-order in show run output";
            type empty;
          }
        }
      }
    }
    leaf hostname {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Set system's network name";
      type string {
        tailf:info "WORD;;This system's network name";
      }
    }
    container clock {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure time-of-day clock";
      tailf:cli-explicit-exit;
      leaf calendar-valid {
        tailf:info "Calendar time is authoritative";
        type empty;
      }
      container summer-time {
        tailf:info "Configure summer (daylight savings) time";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;name of time zone in summer";
          }
        }
        choice summer {
          case a {
            container date {
              tailf:info "Configure absolute summer time";
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to start";
                  range "1..4";
                }
                type enumeration {
                  enum "first" {
                    tailf:info "First week of the month";
                  }
                  enum "last" {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "monday";
                enum "tuesday";
                enum "wednesday";
                enum "thursday";
                enum "friday";
                enum "saturday";
                enum "sunday";
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to end";
                  range "1..4";
                }
                type enumeration {
                  enum "first" {
                    tailf:info "First week of the month";
                  }
                  enum "last" {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf end-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "monday";
                enum "tuesday";
                enum "wednesday";
                enum "thursday";
                enum "friday";
                enum "saturday";
                enum "sunday";
              }
            }
            leaf end-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf end-time {
              tailf:cli-drop-node-name;
              type string {
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
          }
        }
      }
      container timezone {
        tailf:info "Configure time zone";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;name of time zone";
          }
        }
        leaf offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<-23 - 23>;;Hours offset from UTC";
            range "-23..23";
          }
        }
      }
    }
    container banner {
      tailf:ncs-device-type cli-ned;
      presence "In NCS this element is now optional";
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a login banner";
      container login {
        tailf:info "Set login banner";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf start-marker {
          tailf:cli-drop-node-name;
          type string;
        }
        leaf message {
          tailf:cli-drop-node-name;
          type string;
        }
        leaf end-marker {
          tailf:cli-drop-node-name;
          type string;
          must "../end-marker = ../start-marker" {
            tailf:xpath-root "3";
            tailf:dependency "../start-marker";
          }
        }
      }
    }
    container exception {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Coredump configuration commands";
      tailf:cli-explicit-exit;
      container exception-filepath {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf choice {
          tailf:info "Preference for the following dump location";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-3>;;Order of preference";
            range "1..3";
          }
        }
        leaf compress {
          tailf:info "Compress the dump files";
          tailf:cli-incomplete-command;
          type enumeration {
            enum "off" {
              tailf:info "Do not compress core files dumped on this path";
            }
            enum "on" {
              tailf:info "Compress core files dumped on this path";
            }
          }
        }
        container filename {
          tailf:info "Dump file name";
          tailf:cli-optional-in-sequence;
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Filename";
            }
          }
          leaf limit {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "lowlimit-highlimit";
            }
          }
        }
        leaf filepath {
          tailf:info "Give the dump location next";
          type string {
            tailf:info "WORD;;Protocol and directory";
          }
        }
      }
      leaf sparse {
        tailf:info "control sparse core dump";
        tailf:cli-full-command;
        type enumeration {
          enum "off" {
            tailf:info "Disable sparse core dump";
          }
          enum "on" {
            tailf:info "Enable sparse core dump by default";
          }
        }
      }
      leaf sprsize {
        tailf:info "Switch to sparse core dump at this size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
          range "1..4095";
        }
      }
      leaf coresize {
        tailf:info "Only print out stack trace and create no core file beyond this size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4095>;;Core file size max limit in MB";
          range "1..4095";
        }
      }
    }
    container vrf {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "VRF configuration commands";
      tailf:cli-explicit-exit;
      list vrf-list {
        tailf:cli-mode-name "config-vrf";
        tailf:cli-drop-node-name;
        key "name";
        leaf name {
          tailf:info "WORD;;VRF name";
          type string;
        }
        leaf description {
          tailf:info "A description for the VRF";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description for this VRF";
          }
        }
        leaf rd {
          tailf:info "Specify Route Distinguisher";
          tailf:cli-full-command;
          type union {
            type inet:ipv4-address;
            type string {
              tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
            }
          }
        }
        container address-family {
          tailf:info "AFI/SAFI configuration";
          container ipv4 {
            tailf:info "IPv4 address family";
            container unicast {
              tailf:info "Unicast topology";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-vrf-af";
              presence "true";
              container import {
                tailf:info "VRF import";
                container route-target {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-vrf-import-rt";
                  uses vrf-route-target-grouping;
                }
              }
              container export {
                tailf:info "VRF export";
                container route-target {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-vrf-export-rt";
                  uses vrf-route-target-grouping;
                }
              }
              container maximum {
                tailf:info "Set maximum prefix limit";
                container prefix {
                  tailf:info "Set table's maximum prefix limit";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf limit {
                    tailf:cli-drop-node-name;
                    type uint32 {
                      tailf:info "<32-5000000>;;Maximum table's prefix limit";
                      range "32..5000000";
                    }
                  }
                  leaf mid-thresh {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-100>;;mid-thresh (% of max)";
                      range "1..100";
                    }
                  }
                }
              }
            }
          }
          container ipv6 {
            tailf:info "IPv6 address family";
            container unicast {
              tailf:info "Unicast topology";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-vrf-af";
              presence "true";
              container import {
                tailf:info "VRF import";
                container route-target {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-vrf-import-rt";
                  uses vrf-route-target-grouping;
                }
              }
              container export {
                tailf:info "VRF export";
                container route-target {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-vrf-export-rt";
                  uses vrf-route-target-grouping;
                }
              }
              container maximum {
                tailf:info "Set maximum prefix limit";
                container prefix {
                  tailf:info "Set table's maximum prefix limit";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf limit {
                    tailf:cli-drop-node-name;
                    type uint32 {
                      tailf:info "<32-5000000>;;Maximum table's prefix limit";
                      range "32..5000000";
                    }
                  }
                  leaf mid-thresh {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-100>;;mid-thresh (% of max)";
                      range "1..100";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container logging {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify message logging facilities";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:vrf/vrf-list";
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container buffered {
        tailf:info "Set buffered logging parameters";
        leaf type {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<4096-2147483647>;;Logging buffer size";
              range "4096..2147483647";
            }
            type severity-type;
          }
        }
      }
      container cns-events {
        tailf:info "Set CNS Event logging level";
        presence "true";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        leaf severity {
          type severity-type;
        }
      }
      leaf console {
        tailf:info "Set console logging parameters";
        tailf:cli-full-command;
        type union {
          type severity-type;
          type enumeration {
            enum "disable" {
              tailf:info "Disable logging";
            }
          }
        }
      }
      leaf count {
        tailf:info "Count every log message and timestamp last occurance";
        tailf:cli-full-command;
        type empty;
      }
      container events {
        tailf:info "Global interface events";
        leaf level {
          type severity-type;
        }
        leaf link-status {
          type enumeration {
            enum "software-interfaces";
          }
        }
      }
      leaf facility {
        tailf:info "Facility parameter for syslog messages";
        tailf:cli-full-command;
        type union {
          type enumeration {
            enum "local0";
            enum "local1";
            enum "local2";
            enum "local3";
            enum "local4";
            enum "local5";
            enum "local6";
            enum "local7";
          }
          type string;
        }
      }
      leaf history {
        tailf:info "Set history logging";
        tailf:cli-full-command;
        type severity-type;
      }
      leaf monitor {
        tailf:info "Set terminal line (monitor) logging parameters";
        tailf:cli-full-command;
        type severity-type;
      }
      container persistent {
        tailf:info "Set persistent logging parameters";
        presence "true";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        leaf url {
          tailf:info "URL to store logging messages";
          type string;
        }
        leaf size {
          tailf:info "Set disk space for writing log messages";
          type uint32 {
            tailf:info "<16384-1024557056>;;Logging filesystem size";
            range "16384..1024557056";
          }
        }
        leaf filesize {
          tailf:info "Set size of individual log files";
          type uint32 {
            tailf:info "<8192-1024557056>;;Logging file size";
            range "8192..1024557056";
          }
        }
        leaf batch {
          tailf:info "Set batch size for writing to persistent storage";
          type uint32 {
            tailf:info "<4096-1024557056>;;Batch size for writing to persistent storage";
            range "4096..1024557056";
          }
        }
      }
      container source-interface {
        tailf:info "Specify interface for source address in logging transactions";
        uses interface-name-grouping;
      }
      container suppress {
        tailf:info "Configure properties for the event suppression";
        leaf duplicates {
          tailf:info "Suppress consecutive duplicate messages";
          tailf:cli-full-command;
          type empty;
        }
        list rule {
          tailf:info "Configure a specified suppression rule";
          tailf:cli-mode-name "config-suppr-rule";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }
          list alarm {
            tailf:info "Specify alarm: Category/Group/Code combos";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "msg-category group-name msg-code";
            leaf msg-category {
              type string {
                tailf:info "WORD;;Message category of the suppressed message";
              }
            }
            leaf group-name {
              type string {
                tailf:info "WORD;;Group name of suppressed message";
              }
            }
            leaf msg-code {
              type string {
                tailf:info "WORD;;Message code of suppressed message";
              }
            }
          }
        }
        container apply {
          tailf:info "Apply suppression rule";
          list rule {
            tailf:info "Apply suppression rule";
            tailf:cli-mode-name "config-suppr-apply-rule";
            key "name";
            leaf name {
              type leafref {
                tailf:info "WORD;;Rule name";
                path "../../../../../cisco-ios-xr:logging/suppress/rule/name";
              }
            }
            leaf all-of-router {
              tailf:info "Apply the rule to all of the router";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }
      leaf trap {
        tailf:info "Set syslog server logging level";
        tailf:cli-full-command;
        type severity-type;
      }
      leaf hostnameprefix {
        tailf:info "Hostname prefix to add on msgs to servers";
        tailf:cli-full-command;
        type string;
      }
      list host {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "address";
        leaf address {
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;IP v4/v6 address of the logging host";
          }
        }
        leaf vrf {
          tailf:info "Set VRF option";
          type string {
            tailf:info "WORD  VPN Routing/Forwarding instance name";
          }
        }
        leaf severity {
          tailf:info "Set severity of  messages for particular remote host/vrf";
          type severity-type;
        }
      }
    }
    container event {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Event related commands";
      tailf:cli-explicit-exit;
      container manager {
        tailf:info "Event Manager configuration commands";
        container directory {
          tailf:info "Set Embedded Event Manager directory information";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          container user {
            tailf:info "Set Embedded Event Manager user directory information";
            choice emdu-choice {
              leaf policy {
                tailf:info "Set Embedded Event Manager user policy directory";
                type string;
              }
              leaf library {
                tailf:info "Set Embedded Event Manager user library directory";
                type string;
              }
            }
          }
        }
        list policy {
          tailf:info "Register an Event Manager policy";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy file";
            }
          }
          leaf username {
            tailf:info "Username under whom this policy will execute";
            type string;
          }
          leaf persist-time {
            tailf:info "Time of validity (in seconds) for cached AAA taskmap of username (default is 3600)";
            tailf:cli-break-sequence-commands;
            type union {
              type enumeration {
                enum "infinite" {
                  tailf:info "Cached AAA taskmap of username is always treated valid";
                }
              }
              type uint32 {
                tailf:info "<0-4294967294>;;Integer value for this policy's persist-time";
              }
            }
          }
          leaf type {
            tailf:info "The Event Manager type of this policy";
            type enumeration {
              enum "system" {
                tailf:info "Event Manager system policy";
              }
              enum "user" {
                tailf:info "Event Manager user policy";
              }
            }
          }
        }
        list environment {
          tailf:info "Set an Embedded Event Manager global variable for policies";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Name of the global variable";
            }
          }
          leaf var-value {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;Value of the global variable";
            }
          }
        }
      }
    }
    container domain {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Domain service related commands";
      tailf:cli-explicit-exit;
      container ipv6 {
        tailf:info "Ipv6 hosts";
        list host {
          tailf:info "Add an entry to the ipv6 hostname table";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "host-name";
          leaf host-name {
            type string;
          }
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            ordered-by "user";
            max-elements "4";
            type string;
          }
        }
      }
      container lookup {
        tailf:info "Enable Domain Name System hostname translation";
        leaf disable {
          tailf:info "Disable Domain Name System hostname translation";
          tailf:cli-full-command;
          type empty;
        }
        container source-interface {
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-diff-dependency "../../../cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
      leaf name {
        tailf:info "Define the default domain name";
        type string;
      }
      list name-server {
        tailf:info "Specify address of name server to use";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key "address";
        leaf address {
          type inet:host;
        }
      }
      list vrf {
        tailf:info "VRF name for domain services";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "id";
        leaf id {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        leaf name {
          tailf:info "Define the default domain name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Default domain name";
          }
        }
        container lookup {
          tailf:info "Enable Domain Name System hostname translation";
          tailf:cli-reset-container;
          leaf disable {
            tailf:info "Disable Domain Name System hostname translation";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
    list taskgroup {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure task group";
      tailf:cli-mode-name "config-tg";
      tailf:cli-explicit-exit;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Taskgroup name";
        }
      }
      container task {
        tailf:info "Specify a task ID to be part of this group";
        list execute {
          tailf:info "Specify a execute-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type task-type;
          }
        }
        list read {
          tailf:info "Specify a read-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type task-type;
          }
        }
      }
      container inherit {
        tailf:info "Inherit to include into this taskgroup";
        list taskgroup {
          tailf:info "Specify a taskgroup to inherit from";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Name of the task group to include";
            }
          }
        }
      }
      leaf description {
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string;
      }
    }
    list usergroup {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure user group";
      tailf:cli-mode-name "config-ug";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:taskgroup";
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Usergroup name";
        }
      }
      leaf-list taskgroup {
        tailf:info "Task group associated with this group";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Name of the task group";
        }
      }
    }
    container cdp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable CDP, or configure global CDP subcommands";
      presence "true";
      tailf:cli-display-separated;
      leaf timer {
        tailf:info "Specify the rate at which CDP packets are sent (in sec)";
        type uint8 {
          tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec)";
          range "5..254";
        }
      }
    }
    container netconf {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "NETCONF configuration commands";
      tailf:cli-explicit-exit;
      container agent {
        tailf:info "NETCONF agent configuration commands";
        container tty {
          tailf:info "Enable NETCONF agent over TTY";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-netconf-tty";
          container session {
            tailf:info "Session timeout for transport agents";
            leaf timeout {
              tailf:info "Session timeout for agents";
              type uint16 {
                tailf:info "<1-1440>;;Timeout in minutes";
              }
            }
          }
          container throttle {
            tailf:info "Configuration for throttling NETCONF agent";
            leaf memory {
              tailf:info "Memory usage";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<100-600>;;Size of the memory usage in Mbytes per session (default 300 Mbytes)";
                range "100..600";
              }
            }
            leaf process-rate {
              tailf:info "Process rate";
              type uint16 {
                tailf:info "<1000-30000>;;Number of tags to process per sec";
                range "1000..30000";
              }
            }
          }
        }
        leaf ssh {
          tailf:info "Enable NETCONF agent over SSH connection";
          type empty;
        }
      }
    }
    container nsr {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global NSR configuration commands";
      tailf:cli-explicit-exit;
      leaf process-failures {
        tailf:info "Recovery action for Process failures on active RP/DRP";
        type enumeration {
          enum "switchover" {
            tailf:info "Switch over to standby RP/DRP to maintain NSR";
          }
        }
      }
    }
    container ftp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global FTP configuration commands";
      tailf:cli-explicit-exit;
      container client {
        tailf:info "FTP client configuration commands";
        leaf passive {
          tailf:info "Connect using passive mode";
          type empty;
        }
        container source-interface {
          tailf:info "Specify interface for source address in FTP connections";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-diff-dependency "../../../cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }
    container icmp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "ICMP options";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "IPv4 specific";
        container source {
          tailf:info "source address selection policy";
          leaf rfc {
            tailf:info "Enable RFC compliance for source address selection";
            tailf:cli-full-command;
            type empty;
          }
          leaf vrf {
            tailf:info "Enable Strct VRF source address selection";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
    container ntp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Go into NTP submode";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv4/access-list/named-acl/name";
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv6/access-list/named-acl/name";
      leaf max-associations {
        tailf:info "Set maximum number of associations";
        type uint32 {
          tailf:info "<0-4294967295>;;Number of associations";
        }
      }
      list server {
        tailf:info "Configure NTP server";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key "address";
        leaf address {
          type inet:host {
            tailf:info "Peer/server address";
          }
        }
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        leaf ip-version {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum "ipv4" {
              tailf:info "Specify IPv4 address or hostname";
            }
            enum "ipv6" {
              tailf:info "Specify IPv6 address or host name";
            }
          }
        }
        leaf version {
          tailf:info "Configure NTP version";
          type uint8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }
        container source {
          tailf:info "Interface for source address";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          uses interface-name-grouping;
        }
      }
      list access-group {
        tailf:info "Control NTP access";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key "type name";
        leaf type {
          type enumeration {
            enum "peer" {
              tailf:info "Provide full access";
            }
            enum "query-only" {
              tailf:info "Allow only control queries";
            }
            enum "serve" {
              tailf:info "Provide server and query access";
            }
            enum "serve-only" {
              tailf:info "Provide only server access";
            }
          }
        }
        leaf name {
          type string {
            tailf:info "WORD;;Access list name - maximum 32 characters";
          }
        }
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        leaf version {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum "ipv4" {
              tailf:info "Configure IPv4 access";
            }
            enum "ipv6" {
              tailf:info "Configure IPv6 access";
            }
          }
        }
      }
      leaf master {
        tailf:info "Choose a refclock as master clock for NTP";
        tailf:cli-full-command;
        type uint16;
      }
      container source {
        tailf:info "Configure default interface";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        uses interface-name-grouping;
      }
      leaf update-calendar {
        tailf:info "Periodically update calendar with NTP time";
        tailf:cli-full-command;
        type empty;
      }
    }
    list alias {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Create an alias for entity";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE  Alias body with optional parameters e.g,(name) show $name";
        }
      }
    }
    container bfd {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global BFD configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-bfd";
      tailf:cli-explicit-exit;
      container echo {
        tailf:info "Configure BFD echo parameters";
        leaf disable {
          tailf:info "Disable BFD echo mode";
          tailf:cli-reset-container;
          tailf:cli-full-command;
          type empty;
        }
      }
      container trap {
        tailf:info "Configure BFD trap parameters";
        container singlehop {
          tailf:info "Configure BFD mode";
          leaf pre-mapped {
            tailf:info "Configure BFD trap pre-mapped";
            type empty;
          }
        }
      }
    }
    container tftp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global TFTP configuration commands";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv4/access-list/named-acl";
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container client {
        tailf:info "TFTP client configuration commands";
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          uses interface-name-grouping;
        }
      }
      uses tftp-server-grouping;
      list vrf {
        tailf:info "VRF name for tftp server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../cisco-ios-xr:vrf/vrf-list";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }
        uses tftp-server-grouping;
      }
    }
    container nv {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Network Virtualisation configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-nV";
      tailf:cli-explicit-exit;
      container optical {
        tailf:cli-add-mode;
        list satellite {
          tailf:info "Satellite configuration";
          key "name";
          leaf name {
            tailf:info "Satellite ID";
            type uint32;
          }
          container ipv6 {
            leaf address {
              type inet:ipv6-address;
            }
          }
          leaf username {
            type string;
          }
          leaf password {
            type string;
          }
          container trunk {
            list slot {
              key "slot-number";
              leaf slot-number {
                type uint32;
              }
              leaf port {
                type uint32;
              }
              leaf local-port {
                type string;
              }
            }
          }
        }
      }
      container controller {
        list dwdm {
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          key "id";
          leaf id {
            type string {
              pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
            }
          }
          leaf admin-state {
            type enumeration {
              enum "in-service";
              enum "maintenance";
              enum "out-of-service";
            }
          }
          leaf description {
            tailf:cli-multi-value;
            type string;
          }
          container g709 {
            tailf:cli-add-mode;
            leaf fec {
              type enumeration {
                enum "high-gain";
                enum "disable";
                enum "enhanced";
                enum "standard";
              }
            }
          }
          container proactive {
            tailf:cli-add-mode;
            container revert {
              container threshold {
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf x-coefficient {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    range "1..9";
                  }
                }
                leaf y-power {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    range "3..9";
                  }
                }
              }
              leaf window {
                type uint32;
              }
            }
            container trigger {
              container threshold {
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf x-coefficient {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    range "1..9";
                  }
                }
                leaf y-power {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    range "3..9";
                  }
                }
              }
              leaf window {
                type uint32;
              }
            }
          }
          leaf transmit-power {
            type int16 {
              range "-190..10";
            }
          }
          leaf transmit-shutdown {
            type empty;
          }
          container wavelength {
            tailf:cli-compact-syntax;
            leaf channel-number {
              tailf:cli-drop-node-name;
              type uint32;
            }
            leaf frequency {
              type uint32;
            }
            leaf update {
              type uint32;
            }
          }
        }
        list HundredGigE {
          tailf:cli-allow-join-with-key;
          key "id";
          leaf id {
            type string {
              pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
            }
          }
          leaf admin-state {
            type enumeration {
              enum "in-service";
              enum "maintenance";
              enum "out-of-service";
            }
          }
        }
      }
      list satellite {
        tailf:info "ICPE satellite configuration";
        tailf:cli-mode-name "config-satellite";
        key "id";
        leaf id {
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        leaf type {
          tailf:info "Satellite type";
          type string {
            tailf:info "WORD;;Satellite type";
          }
        }
        container ipv4 {
          tailf:info "IPv4 address";
          leaf address {
            tailf:info "IPv4 address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
        }
      }
    }
    container tcp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global TCP configuration commands";
      tailf:cli-explicit-exit;
      leaf mss {
        tailf:info "Set the TCP initial maximum segment size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-10000>;;TCP initial maximum segment size";
          range "68..10000";
        }
      }
      container path-mtu-discovery {
        tailf:info "Enable Path MTU Discovery on new TCP connections";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence "true";
        leaf age-timer {
          type union {
            type uint8 {
              tailf:info "<10-30>;;Aging time (in minutes)";
            }
            type enumeration {
              enum "infinite" {
                tailf:info "Disable Path MTU aging timer";
              }
            }
          }
        }
      }
      container directory {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf directory {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Place debug files in this directory";
          }
        }
        leaf files {
          tailf:cli-break-sequence-commands;
          tailf:info "Set maximum debug files";
          type uint16 {
            tailf:info "<1-10000>;;Maximum debug files";
          }
        }
        leaf size {
          tailf:info "Set maximum file size";
          type uint32 {
            tailf:info "<1024-4294967295>;;Maximum file size in bytes";
            range "1024..4294967295";
          }
        }
      }
    }
    container enable {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify enable password parameters";
      tailf:cli-explicit-exit;
      container password {
        tailf:info "Assign the privileged level password (MAX of 25 characters)";
      }
      container secret {
        tailf:info "Assign the privileged level secret (MAX of 25 characters)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies an ENCRYPTED secret will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
          }
        }
      }
    }
    list username {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure user name";
      tailf:cli-mode-name "config-un";
      tailf:cli-explicit-exit;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;User name";
        }
      }
      list group {
        tailf:info "User group in which this user will be a member of";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name";
        leaf name {
          type string {
            tailf:info "Name of the user group";
          }
        }
      }
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "7" {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf privilege {
        tailf:info "Set user privilege level";
        type uint8 {
          tailf:info "<0-15>;;User privilege level";
          range "0..15";
        }
      }
      container secret {
        tailf:info "Specify the secure password for the user";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies that an encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The user password string";
          }
        }
      }
    }
    container tacacs-server {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "TACACS+ server definition";
      tailf:cli-explicit-exit;
      list host {
        tailf:info "Specify a TACACS+ server";
        tailf:cli-compact-syntax;
        tailf:cli-mode-name "config-tacacs-host";
        key "name port";
        leaf name {
          type inet:host {
            tailf:info "Hostname or A.B.C.D  IP address of TACACS+ server";
          }
        }
        leaf port {
          tailf:info "TCP port for TACACS+ server (default is 49)";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;Port number";
            range "1..65535";
          }
        }
        container key {
          tailf:info "per-server encryption key (overrides default)";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf encryption {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "0" {
                tailf:info "Specifies that an UNENCRYPTED key will follow";
              }
              enum "7" {
                tailf:info "Specifies that an encrypted key will follow";
              }
            }
          }
          leaf key {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
            }
          }
        }
      }
      container key {
        tailf:info "Set TACACS+ encryption key";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "0" {
              tailf:info "Specifies that an UNENCRYPTED key will follow";
            }
            enum "7" {
              tailf:info "Specifies that an encrypted key will follow";
            }
          }
        }
        leaf key {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
          }
        }
      }
      leaf timeout {
        tailf:info "Time to wait for a TACACS server to reply";
        type uint16 {
          tailf:info "<1-1000>;;Wait time (default 5 seconds)";
          range "1..1000";
        }
      }
    }
    container tacacs {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "TACACS+ configuration commands";
      tailf:cli-explicit-exit;
      container source-interface {
        tailf:info "Specify interface for source address in TACACS+ packets";
        tailf:cli-diff-dependency "../../cisco-ios-xr:interface";
        tailf:cli-diff-dependency "../../cisco-ios-xr:vrf/vrf-list";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
        leaf vrf {
          tailf:info "VRF for this source interface configuration";
          type string {
            tailf:info "WORD;;Name of the VRF";
          }
        }
      }
    }
    container aaa {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Authentication, Authorization and Accounting.";
      tailf:cli-explicit-exit;
      leaf new-model {
        tailf:info "Enable NEW access control commands and functions. (Disables OLD commands.)";
        tailf:cli-full-command;
        type empty;
      }
      container group {
        tailf:info "AAA group definitions";
        container server {
          tailf:info "AAA Server group definitions";
          list radius {
            tailf:info "Radius server-group definition";
            key "name";
            leaf name {
              type string {
                tailf:info "WORD;;Server-group name";
              }
            }
            container server {
              tailf:info "Specify a RADIUS server";
              list name {
                tailf:info "Name of radius server";
                key "name";
                leaf name {
                  type leafref {
                    path "../../../../../../../cisco-ios-xr:aaa/group/server/radius/name";
                  }
                }
              }
              list direct {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                key "name";
                leaf name {
                  type inet:host {
                    tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                  }
                  tailf:cli-disallow-value "name";
                }
                leaf auth-port {
                  tailf:info "UDP port for RADIUS authentication server (default is 1645)";
                  type uint16 {
                    tailf:info "<0-65535>;;Port number";
                    range "0..65535";
                  }
                }
                leaf acct-port {
                  tailf:info "UDP port for RADIUS accounting server (default is 1646)";
                  type uint16 {
                    tailf:info "<0-65535>;;Port number";
                    range "0..65535";
                  }
                }
              }
            }
            container ip {
              tailf:info "Internet Protocol config commands";
              container vrf {
                tailf:info "Set VPN Routing Forwarding to use with the servers";
                leaf forwarding {
                  tailf:info "Configure forwarding table";
                  type string {
                    tailf:info "WORD;;Table name";
                  }
                }
              }
            }
          }
          list tacacs {
            tailf:alt-name "tacacs+";
            tailf:info "tacacs+  TACACS+ server-group definition";
            tailf:cli-mode-name "config-sg-tacacs";
            key "name";
            leaf name {
              type string {
                tailf:info "WORD;;Server group name";
              }
            }
            leaf-list server {
              tailf:info "Specify a TACACS+ server";
              tailf:cli-list-syntax;
              type inet:host {
                tailf:info "Hostname or A.B.C.D IP address or Hostname of TACACS+ server";
              }
            }
            leaf vrf {
              tailf:info "VRF to which this server group belongs to";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the VRF";
              }
            }
          }
        }
      }
      container authentication {
        tailf:info "Authentication configurations parameters.";
        list login {
          tailf:info "Set authentication lists for logins.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Named authentication list (max 31 characters,longer will be rejected).";
              length "1..31";
            }
          }
          leaf local {
            tailf:info "Use local username authentication.";
            type empty;
          }
          leaf group {
            tailf:info "Use Server-group";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum "ldap" {
                  tailf:info "Use list of all LDAP hosts.";
                }
                enum "radius" {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum "tacacs" {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf none {
            tailf:cli-full-command;
            tailf:info "NO authentication.";
            type empty;
          }
        }
      }
      container authorization {
        tailf:info "Authorization configurations parameters.";
        list commands {
          tailf:info "For EXEC (shell) commands";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum "ldap" {
                  tailf:info "Use list of all LDAP hosts.";
                }
                enum "radius" {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum "tacacs" {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
        list exec {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum "ldap" {
                  tailf:info "Use list of all LDAP hosts.";
                }
                enum "radius" {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum "tacacs" {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
        list eventmanager {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          tailf:cli-delete-when-empty;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum "ldap" {
                  tailf:info "Use list of all LDAP hosts.";
                }
                enum "radius" {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum "tacacs" {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container accounting {
        tailf:info "Accounting configurations parameters.";
        list exec {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type enumeration {
              enum "start-stop" {
                tailf:info "start and stop records";
              }
              enum "stop-only" {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum "radius" {
                  tailf:info "Use list of all Radius hosts";
                }
                enum "tacacs+" {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list system {
          tailf:info "For System events";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf start-stop {
            tailf:info "start and stop records";
            type empty;
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum "radius" {
                  tailf:info "Use list of all Radius hosts";
                }
                enum "tacacs+" {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list network {
          tailf:info "For network services (such as IKE, PPP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type enumeration {
              enum "start-stop" {
                tailf:info "start and stop records";
              }
              enum "stop-only" {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum "radius" {
                  tailf:info "Use list of all Radius hosts";
                }
                enum "tacacs+" {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list commands {
          tailf:info "For EXEC (shell) commands";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            type enumeration {
              enum "start-stop" {
                tailf:info "start and stop records";
              }
              enum "stop-only" {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum "radius" {
                  tailf:info "Use list of all Radius hosts";
                }
                enum "tacacs+" {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
      }
      leaf session-id {
        tailf:info "AAA Session ID";
        tailf:cli-full-command;
        type enumeration {
          enum "common" {
            tailf:info "Common Session ID";
          }
          enum "unique" {
            tailf:info "Unique Session ID for different accounting types";
          }
        }
      }
      leaf default-taskgroup {
        tailf:info "Default taskgroup to be used for remote authentication";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of the taskgroup to be used";
        }
      }
    }
    container aps {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure SONET Automatic Protection Switching (APS)";
      tailf:cli-explicit-exit;
      list group {
        tailf:info "APS group to configure";
        tailf:cli-mode-name "config-aps";
        key "id";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Group number";
            range "1..255";
          }
        }
        container timers {
          tailf:info "Set APS W-P communication timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf hello {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;Hello timer in seconds (default 1)";
              range "1..255";
            }
          }
          leaf hold {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Hold timer in seconds (default 3)";
              range "1..255";
            }
          }
        }
        list channel {
          tailf:info "Assign a channel to an APS group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "id location";
          leaf id {
            type uint8 {
              tailf:info "<0-1>;;Channel number (0 = Protect, 1 = Working)";
              range "0..1";
            }
          }
          leaf location {
            type enumeration {
              enum "local" {
                tailf:info "Channel assignment to a local port";
              }
            }
          }
          leaf preconfigure {
            tailf:info "Specify a preconfig";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf sonet {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "SONET;;SONET/SDH Port controller(s)";
            }
          }
        }
      }
    }
    container platform {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "platform specific configuration";
      tailf:cli-explicit-exit;
      container ip {
        tailf:info "ip keyword";
        container cef {
          tailf:info "cef keyword";
          leaf load-sharing {
            tailf:info "load balancing";
            type enumeration {
              enum "dst-only" {
                tailf:info "load balancing algorithm to include destination IP/L4 port";
              }
              enum "full" {
                tailf:info "default load balancing algorithm to include src/dst IPs/L4 ports";
              }
              enum "ip-only" {
                tailf:info "load balancing algorithm to include src/dst IP";
              }
            }
          }
        }
      }
      container qos {
        tailf:info "qos keyword";
        leaf qos-10g-only {
          tailf:alt-name "10g-only";
          tailf:info "qos pure 10G mode";
          type empty;
        }
        list protocol {
          tailf:info "protocol keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key "proto";
          leaf proto {
            type enumeration {
              enum "isis";
              enum "eigrp";
              enum "ldp";
              enum "ospf";
              enum "rip";
              enum "bgp";
              enum "hsrp";
              enum "bfd";
              enum "ospfv3";
              enum "bgpv2";
              enum "ripng";
              enum "neigh-discover";
              enum "wlccp";
              enum "rsvp";
              enum "rsvpv6";
              enum "arp";
              enum "gre" {
                tailf:info "gre (ipv4 and ipv6)";
              }
              enum "mpls" {
                tailf:info "mpls packet";
              }
            }
          }
          choice proto-choice {
            leaf pass-through {
              tailf:info "pass-through keyword";
              type empty;
            }
            container police {
              tailf:info "police keyword";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-sequence-commands;
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint64 {
                  tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) (postfix k, m, g optional; decimal point allo";
                  range "32000..128000000000";
                }
              }
              leaf burst {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2000000000>;;Normal burst bytes";
                  range "1..2000000000";
                }
              }
            }
            container precedence {
              tailf:info "change ip-precedence(used to map the dscp to cos value)";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-sequence-commands;
              leaf cos {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-7>;;new cos value";
                  range "0..7";
                }
              }
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint64 {
                  tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) (postfix k, m, g optional; decimal point allo";
                  range "32000..128000000000";
                }
              }
              leaf burst {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2000000000>;;Normal burst bytes";
                  range "1..2000000000";
                }
              }
            }
          }
        }
      }
    }
    container ip {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IP configuration subcommands";
      tailf:cli-explicit-exit;
      container domain-lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        leaf do-lookup {
          tailf:cli-drop-node-name;
          type boolean;
          tailf:cli-boolean-no;
          default "true";
          tailf:cli-trim-default;
        }
        leaf nsap {
          tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
          type empty;
        }
      }
      leaf domain-name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }
      container forward-protocol {
        tailf:info "Controls forwarding of physical and directed IP broadcasts";
        leaf nd {
          tailf:info "Sun's Network Disk protocol";
          type empty;
        }
        leaf sdns {
          tailf:info "Network Security Protocol";
          type empty;
        }
        leaf spanning-tree {
          tailf:info "Use transparent bridging to flood UDP broadcasts";
          type empty;
        }
        leaf turbo-flood {
          tailf:info "Fast flooding of UDP broadcasts";
          type empty;
        }
        leaf udp {
          tailf:info "Packets to a specific UDP port";
          type empty;
        }
      }
      container http {
        tailf:info "HTTP server configuration";
        leaf server {
          tailf:info "Enable http server";
          type boolean;
          tailf:cli-boolean-no;
          default "true";
          tailf:cli-trim-default;
        }
        leaf secure-server {
          tailf:info "Enable https server";
          type boolean;
          tailf:cli-boolean-no;
          default "true";
          tailf:cli-trim-default;
        }
      }
      container pim {
        tailf:info "PIM global commands";
        container ssm {
          tailf:info "Configure Source Specific Multicast";
          choice ssm-choice {
            leaf default {
              tailf:info "Use 232/8 group range for SSM";
              type empty;
            }
            leaf range {
              tailf:info "ACL for group range to be used for SSM";
              type union {
                type uint8 {
                  tailf:info "<1-99>;;Access list number";
                  range "1..99";
                }
                type string {
                  tailf:info "WORD;;IP named access list";
                }
              }
            }
          }
        }
      }
      container route {
        tailf:info "Establish static routes";
        container vrf {
          tailf:info "Configure static route for a VPN Routing/Forwarding instance";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          leaf dest {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination prefix";
            }
          }
          leaf dest-mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination prefix mask";
            }
          }
          choice vrf-choice {
            leaf forwarding-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            leaf GigabitEthernet {
              tailf:info "GigabitEthernet IEEE 802.3z";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type leafref {
                path "../../../../cisco-ios-xr:interface/GigabitEthernet/id";
              }
            }
          }
        }
      }
      container multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        presence "true";
        tailf:cli-display-separated;
        leaf-list vrf {
          tailf:info "Select VPN Routing/Forwarding instance";
          tailf:cli-list-syntax;
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
      }
      container multicast {
        tailf:info "Global IP Multicast Commands";
        list vrf {
          tailf:info "Select VPN Routing/Forwarding instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "id";
          leaf id {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          container route-limit {
            tailf:info "Maximum number of multicast routes";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf nr-routes {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;number of routes";
                range "1..2147483647";
              }
            }
            leaf threshold {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
                range "1..2147483647";
              }
            }
          }
        }
      }
      container tftp {
        tailf:info "tftp configuration commands";
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          tailf:cli-diff-dependency "../../../cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
      container ssh {
        tailf:info "Configure ssh options";
        leaf logging {
          tailf:info "Configure logging for SSH";
          type enumeration {
            enum "events" {
              tailf:info "Log SSH events";
            }
          }
        }
        leaf version {
          tailf:info "Specify protocol version to be supported";
          type uint8 {
            tailf:info "<1-2>;;Protocol version";
            range "1..2";
          }
        }
      }
    }
    container ipv4 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IPv4 configuration commands";
      tailf:cli-explicit-exit;
      container access-list {
        tailf:info "Configure access lists";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        list named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-ipv4-acl";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this access list";
            }
          }
          list rule {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "id";
            leaf id {
              type uint32 {
                tailf:info "<1-2147483644>;;Sequence number for this entry";
              }
            }
            leaf line {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info
                  "deny;;Specify packets to reject
                   permit;;Specify packets to forward
                   remark;;Comment for access list";
                pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
              }
            }
          }
        }
      }
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          container traffic-eng {
            tailf:info "IPv4 commands for MPLS Traffic Engineering";
            tailf:cli-diff-dependency "../../../../cisco-ios-xr:interface";
            uses interface-name-grouping;
          }
        }
      }
      container virtual {
        tailf:info "IPv4 virtual address for management interfaces options";
        container address-src {
          tailf:cli-drop-node-name;
          tailf:cli-no-keyword;
          container address {
            leaf use-as-src-addr {
              tailf:info "Use as default src address on sourced packets?";
              type empty;
            }
          }
        }
        container address {
          tailf:info "IPv4 virtual address for management interfaces";
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address mask";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              type inet:ipv4-address {
                tailf:info "IP subnet mask  IPv4 address/prefix or IPv4 address and Mask";
              }
            }
          }
          list vrf {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "name";
            leaf name {
              type string {
                tailf:info "Select VRF for which the virtual ip address is configured";
              }
            }
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "address mask";
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
              leaf mask {
                type inet:ipv4-address {
                  tailf:info "IP subnet mask  IPv4 address/prefix or IPv4 address and Mask";
                }
              }
            }
          }
        }
      }
      leaf conflict-policy {
        tailf:info "ipv4 address conflict algorithm selection";
        tailf:cli-full-command;
        type enumeration {
          enum "highest-ip" {
            tailf:info "Keeps the highest ip address in the conflict set UP";
          }
          enum "longest-prefix" {
            tailf:info "Keeps the longest prefix match in the conflict set UP";
          }
          enum "static" {
            tailf:info "Keeps the existing interface UP across new address configs";
          }
        }
      }
    }
    container ipv6 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IPv6 configuration commands";
      tailf:cli-explicit-exit;
      container access-list {
        tailf:info "Configure access lists";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        list named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-ipv6-acl";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this access list";
            }
          }
          list rule {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "id";
            leaf id {
              type uint32 {
                tailf:info "<1-2147483644>;;Sequence number for this entry";
              }
            }
            leaf line {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info
                  "deny;;Specify packets to reject
                   permit;;Specify packets to forward
                   remark;;Comment for access list";
                pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
              }
            }
          }
        }
      }
      container multicast {
        tailf:info "Configure multicast related commands";
        container rpf {
          tailf:info "Configure multicast RPF related commands";
          container backoff {
            tailf:info "Backoff delay after unicast routing change";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf initial {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<200-65535>;;Initial RPF backoff delay in milliseconds";
                range "200..65535";
              }
            }
            leaf max-backoff-delay {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<200-65535>;;Maximum RPF backoff delay in milliseconds";
                range "200..65535";
              }
            }
          }
          leaf use-bgp {
            tailf:info "Use BGP routes for multicast RPF lookup";
            type empty;
          }
        }
      }
      leaf unicast-routing {
        tailf:info "Enable unicast routing";
        type empty;
      }
    }
    container frequency {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Frequency Synchronization configuration";
      tailf:cli-explicit-exit;
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-freqsync";
        container quality {
          tailf:info "Quality level option selection";
          container itu-t {
            tailf:info "ITU-T QL options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf option {
              tailf:info "ITU-T QL options";
              type enumeration {
                enum "1" {
                  tailf:info "ITU-T QL option 1";
                }
                enum "2" {
                  tailf:info "ITU-T QL option 2";
                }
              }
            }
            leaf generation {
              tailf:info "ITU-T QL option 2 generation";
              when "../option = '2'" {
                tailf:xpath-root "3";
              }
              type enumeration {
                enum "1" {
                  tailf:info "ITU-T QL option 2, generation 1";
                }
                enum "2" {
                  tailf:info "ITU-T QL option 2, generation 2";
                }
              }
            }
          }
        }
        container clock-interface {
          tailf:info "Clock interface configuration";
          leaf timing-mode {
            tailf:info "Clock interface timing mode";
            type enumeration {
              enum "independent" {
                tailf:info "Use the line interfaces for clock-interface output, which is not looped back to the clock-interface input";
              }
              enum "system" {
                tailf:info "Use the system's selected timing source for clock-interface output";
              }
            }
          }
        }
        container system {
          tailf:info "System timing configuration";
          leaf timing-mode {
            tailf:info "System timing mod";
            type enumeration {
              enum "clock-only" {
                tailf:info "Use only clock-interfaces for system timing";
              }
              enum "line-only" {
                tailf:info "Use only line-interfaces for system timing";
              }
            }
          }
        }
      }
    }
    container error-disable {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure error-disable";
      container recovery {
        tailf:info "Configure auto-recovery";
        container cause {
          tailf:info "Configure auto-recovery for a specific cause";
          container udld-timeout {
            tailf:info "Used when all UDLD neigbors on the link have timed out";
            tailf:cli-delete-when-empty;
            presence "true";
            leaf interval {
              tailf:info "Configure an interval for the auto-recovery period";
              type uint32 {
                tailf:info "<30-1000000>;;Specify an interval for the auto-recovery period in seconds";
                range "30..1000000";
              }
            }
          }
        }
      }
    }
    container vtp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure global VTP state";
      tailf:cli-explicit-exit;
      leaf mode {
        tailf:info "Configure VTP device mode";
        type enumeration {
          enum "client" {
            tailf:info "Set the device to client mode.";
          }
          enum "off" {
            tailf:info "Set the device to off mode.";
          }
          enum "server" {
            tailf:info "Set the device to server mode.";
          }
          enum "transparent" {
            tailf:info "Set the device to transparent mode.";
          }
        }
      }
    }
    container vty-pool {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "VTY Pools";
      tailf:cli-explicit-exit;
      container default {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses vty-pool-grouping;
      }
      container eem {
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        uses vty-pool-grouping;
      }
      list pool-name-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        key "pool-name";
        leaf pool-name {
          type string;
          tailf:cli-disallow-value "(eem|default)";
        }
        uses vty-pool-grouping;
      }
    }
    container arp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global ARP configuration for Static and Alias ARP entries";
      uses arp-grouping;
      list vrf {
        tailf:info "vrf;;Specify a non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../cisco-ios-xr:vrf/vrf-list";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses arp-grouping;
      }
    }
    container telnet {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global Telnet configuration commands";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "IPv4 configuration";
        container client {
          tailf:info "Telnet client configuration commands";
          container source-interface {
            tailf:info "Source interface for telnet sessions";
            tailf:cli-diff-dependency "../../../../cisco-ios-xr:interface";
            uses interface-name-grouping;
          }
        }
      }
      uses telnet-server-grouping;
      list vrf {
        tailf:info "VRF name for telnet server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../cisco-ios-xr:vrf/vrf-list";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }
        uses telnet-server-grouping;
      }
    }
    container cinetd {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global Cisco inetd configuration commands";
      tailf:cli-explicit-exit;
      leaf rate-limit {
        tailf:info "Cisco inetd rate-limit of service requests";
        type uint8 {
          tailf:info "<1-100>;;Number of service requests accepted per second (default 1)";
          range "1..100";
        }
      }
    }
    container xxml {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configuration for XML related services";
      tailf:alt-name "xml";
      tailf:cli-explicit-exit;
      container tty-agent {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-no;
        container agent {
          tailf:info "Enable default agent for XML requests";
          tailf:cli-incomplete-no;
          container tty {
            tailf:info "Enable tty agent for XML requests";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-xml-tty";
            container iteration {
              tailf:info "Iterator of the xml response";
              leaf off {
                tailf:info "Turn off the xml response iterator";
                type empty;
              }
            }
            leaf ipv4 {
              tailf:info "IPv4 Transport";
              type enumeration {
                enum "enable";
                enum "disable";
              }
            }
            leaf ipv6 {
              tailf:info "IPv6 Transport";
              type enumeration {
                enum "enable";
                enum "disable";
              }
            }
          }
        }
      }
      container other-agent {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-no;
        container agent {
          tailf:cli-add-mode;
          leaf ipv4 {
            type enumeration {
              enum "enable";
              enum "disable";
            }
          }
          leaf ipv6 {
            type enumeration {
              enum "enable";
              enum "disable";
            }
          }
        }
      }
    }
    container switch {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure switch command";
      tailf:cli-explicit-exit;
      container virtual {
        tailf:info "Virtual switch configuration mode";
        list domain {
          tailf:info "Virtual switch domain";
          key "id";
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Virtual switch domain number";
              range "1..255";
            }
          }
          leaf mac-address {
            tailf:info "router mac address scheme";
            type union {
              type string {
                tailf:info "H.H.H;;Manually set router mac address";
              }
              type enumeration {
                enum "use-virtual" {
                  tailf:info "Use mac-address range reserved for Virtual Switch System ";
                }
              }
            }
          }
          container switch {
            tailf:info "Configure switch command";
            leaf mode {
              type enumeration {
                enum "virtual";
              }
            }
            list nr {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "id";
              leaf id {
                type uint8 {
                  tailf:info "<1-2>;;Virtual switch number";
                  range "1..2";
                }
              }
              leaf location {
                tailf:info "Virtual switch location";
                type string {
                  tailf:info "WORD;;Virtual switch location string. If you include spaces, you must enclose your entry in quotes (\"\").";
                }
              }
              leaf priority {
                tailf:info "Virtual switch priority";
                type uint8 {
                  tailf:info "<1-255>;;Virtual switch priority value";
                  range "1..255";
                }
              }
            }
          }
        }
      }
    }
    container mpls {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure MPLS parameters";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv4/access-list/named-acl";
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Set platform default label distribution protocol";
          type enumeration {
            enum "ldp" {
              tailf:info "Use LDP (default)";
            }
            enum "tdp" {
              tailf:info "Use TDP";
            }
          }
        }
        container range {
          tailf:info "Label range";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf min {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<16-524287>;;Minimum label value for dynamic label range";
              range "16..524287";
            }
          }
          leaf max {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<11000-524287>;;Maximum label value for dynamic label range";
              range "11000..524287";
            }
          }
        }
      }
      container ldp {
        tailf:info "Label Distribution Protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp";
        leaf router-id {
          tailf:info "Configure router Id";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to be used";
          }
        }
        container discovery {
          tailf:info "Configure discovery parameters";
          container instance-tlv {
            tailf:info "Control support for Neighbor instance TLV in Hello messages";
            leaf disable {
              tailf:info "Disable transmit and receive processing for TLV";
              tailf:cli-full-command;
              type empty;
            }
          }
          container hello {
            tailf:info "LDP Link Hellos";
            leaf holdtime {
              tailf:info "Hello holdtime";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
                range "1..65535";
              }
            }
            leaf interval {
              tailf:info "Hello interval";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds)";
                range "1..65535";
              }
            }
          }
          container targeted-hello {
            tailf:info "LDP Targeted Hellos";
            container accept {
              tailf:info "Accept and respond to targeted hellos";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence "true";
              leaf from {
                tailf:info "IP Access list to specify acceptable targeted hello sources";
                type string {
                  tailf:info "WORD;;access-list";
                }
              }
            }
          }
        }
        container igp {
          tailf:info "Configure IGP related parameters";
          container sync {
            tailf:info "Configure LDP-IGP synchronization parameters";
            container delay {
              tailf:info "Configure sync up delay after session up";
              leaf delay-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                  range "5..300";
                }
              }
            }
          }
        }
        leaf nsr {
          tailf:info "Configure Non-Stop Routing";
          tailf:cli-full-command;
          type empty;
        }
        container graceful-restart {
          tailf:info "Configure graceful restart feature";
          tailf:cli-delete-when-empty;
          presence "true";
        }
        container password {
          tailf:info "Configure LDP MD5 password";
          container option {
            tailf:info "LDP password options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf sequence-nr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-32767>;;Sequence number of the LDP password option";
                range "1..32767";
              }
            }
            leaf for {
              tailf:info "IP access-list specifying control on LDP peers";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
              }
            }
            leaf enc-type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum "0" {
                  tailf:info "Specifies an UNENCRYPTED password will follow";
                }
                enum "7" {
                  tailf:info "Specifies a HIDDEN password will follow";
                }
              }
            }
            leaf password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
              }
            }
          }
          container required {
            tailf:info "MD5 password is required for the peer";
            tailf:cli-reset-container;
            presence "true";
            leaf for {
              tailf:info "IP access-list specifying control on LDP peers";
              type string {
                tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
              }
            }
          }
        }
        container label {
          tailf:info "Configure label allocation, advertisement, and acceptance";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-lbl";
          container allocate {
            tailf:info "Configure label allocation control";
            leaf for {
              tailf:info "Limit label allocation to a set of prefixes";
              type string;
            }
          }
          container advertise {
            tailf:info "Configure outbound label advertisement control";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-lbl-advt";
            leaf disable {
              tailf:info "Disable label advertisement to all peers for all prefixes";
              tailf:cli-full-command;
              type empty;
            }
            leaf for {
              tailf:info "Prefix centric outbound label filtering";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;IP access-list name or number (1-99)";
              }
            }
          }
        }
        container log {
          tailf:info "Configure logging of LDP events";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-log";
          leaf neighbor {
            tailf:info "Neighbor events";
            tailf:cli-full-command;
            type empty;
          }
          leaf nsr {
            tailf:info "NSR synchronization events";
            tailf:cli-full-command;
            type empty;
          }
        }
        list interface {
          tailf:info "Enable LDP on an interface and enter interface submode";
          tailf:cli-mode-name "config-ldp-if";
          key "name";
          leaf name {
            type string {
              tailf:info "Interface Name";
            }
          }
        }
      }
      container oam {
        tailf:info "OAM configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-oam";
        container echo {
          tailf:info "Echo request attributes";
          leaf disable-vendor-extension {
            tailf:info "Disable sending vendor extension TLV with echo req";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container static {
        tailf:info "Configure static MPLS forwarding";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpls-static";
        list ipv4 {
          tailf:info "Configure MPLS static IPv4 imposition";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "address mask interface";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 mask";
            }
          }
          leaf interface {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf label {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<16-1048575>;;Outgoing label";
            }
          }
        }
        list interface {
          tailf:info "Enable MPLS Static on an interface";
          key "name";
          tailf:cli-suppress-mode;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          list ipv4 {
            tailf:info "Configure IPv4 Address Family parameters";
            tailf:cli-mode-name "config-mpls-static-af";
            tailf:cli-full-command;
            key "af-modifier";
            leaf af-modifier {
              type enumeration {
                enum "unicast" {
                  tailf:code-name "ipv4_unicast";
                  tailf:info "Unicast";
                }
              }
            }
            list local-label {
              tailf:info "Configure local label assignment and forwarding";
              tailf:cli-mode-name "config-mpls-static-af-lbl";
              tailf:cli-incomplete-command;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "id";
              leaf id {
                tailf:cli-suppress-range;
                type uint32 {
                  tailf:info "<16-1048575>;;Label value";
                  range "16..1048575";
                }
              }
              leaf allocate {
                tailf:info "Label Allocation Option";
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf per-prefix {
                tailf:info "For a given prefix";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type ipv4-prefix {
                  tailf:info "A.B.C.D/length;;IPv4 Prefix";
                }
              }
              container forward {
                tailf:cli-break-sequence-commands;
                tailf:info "Configure forwarding rewrites";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-mpls-static-af-lbl-fwd";
                list path {
                  tailf:info "Configure cross-connect path parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-incomplete-command;
                  key "id";
                  leaf id {
                    type uint16 {
                      tailf:info "<1-1>;;Path count";
                    }
                  }
                  leaf nexthop {
                    tailf:info "nexthop";
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                  leaf nexthop-address {
                    tailf:cli-optional-in-sequence;
                    tailf:cli-incomplete-command;
                    tailf:cli-drop-node-name;
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Next-hop IPv4 address";
                    }
                  }
                  leaf out-label {
                    tailf:info "output label";
                    type union {
                      type uint32 {
                        tailf:info "<16-1048575>;;Output MPLS label value";
                        range "16..1048575";
                      }
                      type enumeration {
                        enum "exp-null" {
                          tailf:info "Set the output label to explicit null";
                        }
                        enum "pop" {
                          tailf:info "Pop off the top of the label stack";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        list vrf {
          tailf:info "Configure VRF parameters";
          tailf:cli-mode-name "config-mpls-static-vrf";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Specify the VRF Name";
            }
          }
          container address-family {
            tailf:info "Configure Address Family and its parameters";
            list ipv4 {
              tailf:info "Configure IPv4 Address Family parameters";
              tailf:cli-mode-name "config-mpls-static-vrf-af";
              tailf:cli-full-command;
              key "af-modifier";
              leaf af-modifier {
                type enumeration {
                  enum "unicast" {
                    tailf:code-name "mpls_static_vrf_ipv4_unicast";
                    tailf:info "Unicast";
                  }
                }
              }
              list local-label {
                tailf:info "Configure local label assignment and forwarding";
                tailf:cli-mode-name "config-mpls-static-vrf-af-lbl";
                tailf:cli-incomplete-command;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                key "id";
                leaf id {
                  tailf:cli-suppress-range;
                  type uint32 {
                    tailf:info "<16-1048575>;;Label value";
                    range "16..1048575";
                  }
                }
                leaf allocate {
                  tailf:info "Label Allocation Option";
                  tailf:cli-incomplete-command;
                  tailf:cli-hide-in-submode;
                  type empty;
                }
                choice allocate-choice {
                  leaf per-prefix {
                    tailf:info "For a given prefix";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type ipv4-prefix {
                      tailf:info "A.B.C.D/length;;IPv4 Prefix";
                    }
                  }
                  leaf per-vrf {
                    tailf:info "For a VRF";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                }
                container forward {
                  when "../per-vrf" {
                    tailf:xpath-root "3";
                  }
                  tailf:cli-break-sequence-commands;
                  tailf:info "Configure forwarding rewrites";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-mpls-static-vrf-af-lbl-fwd";
                  list path {
                    tailf:info "Configure cross-connect path parameters";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    tailf:cli-incomplete-command;
                    key "id";
                    leaf id {
                      tailf:cli-suppress-range;
                      type uint8 {
                        tailf:info "<1-1>;;Path count";
                      }
                    }
                    leaf pop-and-lookup {
                      tailf:info "Pop and lookup";
                      type empty;
                    }
                  }
                }
              }
            }
          }
        }
      }
      container traffic-eng {
        tailf:info "Go into the MPLS-TE submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpls-te";
        container auto-tunnel {
          tailf:info "Automatically created tunnel configuration";
          container backup {
            tailf:info "Enter the auto-tunnel backup configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mpls-te-auto-bk";
            container timers {
              tailf:info "Auto-tunnel backups related timers";
              container removal {
                tailf:info "Auto-tunnel backups removal timers";
                leaf unused {
                  tailf:info "Auto-tunnel backups unused removal timer";
                  type uint16 {
                    tailf:info "<0-10080>;;Auto-tunnel backup unused timeout in minutes (0=never timeout)";
                    range "0..10080";
                  }
                }
              }
            }
            container tunnel-id {
              tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf min {
                tailf:info "Minimum tunnel ID for auto-tunnel backups";
                type uint16 {
                  tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel backups";
                }
              }
              leaf max {
                tailf:info "Maximum tunnel ID for auto-tunnel backups";
                type uint16 {
                  tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel backups";
                }
              }
            }
          }
        }
        list interface {
          tailf:info "Enable MPLS-TE on an interface";
          tailf:cli-mode-name "config-mpls-te-if";
          key "name";
          leaf name {
            type string {
              tailf:info "Interface Name";
            }
          }
          container bfd {
            tailf:info "Configure BFD parameters";
            leaf fast-detect {
              tailf:info "Enable Fast detection";
              type empty;
            }
          }
          container auto-tunnel {
            tailf:info "Auto-tunnel configuration";
            container backup {
              tailf:info "Enable the auto-tunnel backup feature on an interface";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-mpls-te-if-auto-backup";
              presence "true";
              container exclude {
                tailf:info "Restrict auto-tunnel backup path based on specific criteria.";
                container srlg {
                  tailf:info "Backup requires SRLG exclusion from protected interface";
                  tailf:cli-delete-when-empty;
                  tailf:cli-reset-container;
                  presence "true";
                  leaf preferred {
                    tailf:info "SRLG exclusion is preferred but not mandatory";
                    type empty;
                  }
                }
              }
            }
          }
        }
        container logging {
          tailf:info "MPLS Traffic-Eng. logging configuration";
          container events {
            tailf:info "Global logging events";
            leaf frr-protection {
              tailf:info "Enable protection change Syslog";
              tailf:cli-full-command;
              type empty;
            }
            leaf preemption {
              tailf:info "Enable Tunnel Preemption alarms";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        container soft-preemption {
          tailf:info "Enable soft-preemption";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-soft-preemption";
          leaf timeout {
            tailf:info "Specify a timeout for soft-preempted LSP";
            type uint32 {
              tailf:info "<1-300>;;Timeout for soft-preempted LSP in seconds:default 60";
              range "1..300";
            }
          }
        }
        container auto-bw {
          tailf:info "Auto-bandwidth configuration";
          container collect {
            tailf:info "Auto-bandwidth collection parameters";
            leaf frequency {
              tailf:info "Auto-bandwidth collection frequency parameter";
              type uint16 {
                tailf:info "<1-10080>;;Auto-bandwidth collection frequency in minutes";
                range "1..10080";
              }
            }
          }
        }
        container reoptimize {
          tailf:info "MPLS TE Reoptimize config";
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;Reoptimize timers frequency (secs)";
              range "0..604800";
            }
          }
          container timers {
            tailf:info "Reoptimization timers";
            container delay {
              tailf:info "Delay reoptimization action";
              leaf cleanup {
                tailf:info "Delay cleanup of reoptimized LSP";
                type uint16 {
                  tailf:info "<0-300>;;Seconds to delay cleanup of reoptimized LSP";
                  range "0..300";
                }
              }
              leaf installation {
                tailf:info "Delay replacement of current LSP by reoptimized LSP";
                type uint16 {
                  tailf:info "<0-3600>;;Seconds to delay replacement of tunnel LSP";
                  range "0..3600";
                }
              }
              leaf path-protection {
                tailf:info "Time between path protection switchover event and tunnel re-optimization";
                type uint32 {
                  tailf:info "<0-604800>;;Seconds between path protection switchover event and tunnel re-optimization. Set to 0 to disable";
                  range "0..604800";
                }
              }
            }
          }
        }
        container bfd {
          tailf:info "Configure BFD parameters";
          leaf multiplier {
            tailf:info "Detect multiplier";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-10>;;Detect multiplier";
              range "2..10";
            }
          }
          leaf minimum-interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-200>;;hello interval in milli-seconds";
              range "15..200";
            }
          }
        }
        container fast-reroute {
          tailf:info "Fast-reroute config parameters";
          container timers {
            tailf:info "Configure fast-reroute timer";
            leaf promotion {
              tailf:info "Configure how often we scan for LSP backup promotion";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-604800>;;Seconds between promotions (0 disables promotion)";
                range "0..604800";
              }
            }
          }
        }
        container link-management {
          tailf:info "MPLS Link Manager subcommands";
          container timers {
            tailf:info "MPLS Link Manager Timer subcommands";
            container preemption-delay {
              tailf:info "Delay LSP preemption";
              leaf bundle-capacity {
                tailf:info "Bundle capacity change preemption delay timer";
                type uint16 {
                  tailf:info "<0-300>;;Bundle capacity change preemption timer value (seconds)";
                  range "0..300";
                }
              }
            }
          }
        }
      }
      container ip-ttl-propagate {
        tailf:info "Propagate IP TTL into the label stack";
        container disable {
          tailf:info "Disable IP TTL propagation";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence "true";
          leaf disable-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "forwarded" {
                tailf:info "Disable IP TTL propagation for only forwarded MPLS packets";
              }
              enum "local" {
                tailf:info "Disable IP TTL propagation for only locally generated MPLS packets";
              }
            }
          }
        }
      }
    }
    container rsvp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      list interface {
        tailf:info "Enable RSVP on an interface";
        tailf:cli-mode-name "config-rsvp-if";
        key "name";
        leaf name {
          type string {
            tailf:info "Interface Name";
          }
        }
        container bandwidth {
          tailf:info "Configure RSVP bandwidth parameters";
          tailf:cli-delete-when-empty;
          presence "true";
        }
      }
      container signalling {
        tailf:info "Configure global RSVP signalling parameters";
        container graceful-restart {
          tailf:info "Configure RSVP Graceful-Restart parameters";
          tailf:cli-delete-when-empty;
          presence "true";
        }
      }
    }
    container key {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Key management";
      tailf:cli-explicit-exit;
      list chain {
        tailf:info "Key-chain management";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        list key {
          tailf:info "Configure a key";
          tailf:cli-full-command;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<0-2147483647>;;Key identifier";
              range "0..2147483647";
            }
          }
          container accept-lifetime {
            tailf:info "Set accept lifetime of key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf local {
              tailf:info "Specify time in local timezone";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm:ss;;Time to start";
                pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-31>;;Day of the month to start";
                range "1..31";
              }
            }
            leaf start-year {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1993-2035>;;Year to start";
                range "1993..2035";
              }
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  tailf:info "Set key lifetime duration";
                  type uint32 {
                    tailf:info "<1-2147483646>;;Seconds";
                    range "1..2147483646";
                  }
                }
              }
              case stop-time {
                leaf stop-time {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "hh:mm:ss;;Time to stop";
                    pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                  }
                }
                leaf stop-month {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "Jan";
                    enum "Feb";
                    enum "Mar";
                    enum "Apr";
                    enum "May";
                    enum "Jun";
                    enum "Jul";
                    enum "Aug";
                    enum "Sep";
                    enum "Oct";
                    enum "Nov";
                    enum "Dec";
                  }
                }
                leaf stop-day {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-31>;;Day of the month to stop";
                    range "1..31";
                  }
                }
                leaf stop-year {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<1993-2035>;;Year to stop";
                    range "1993..2035";
                  }
                }
              }
              case infinite {
                leaf infinite {
                  tailf:info "Never expires";
                  type empty;
                }
              }
            }
          }
          container key-string {
            tailf:info "Set key string";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf password {
              type string {
                tailf:info "WORD;;The HIDDEN user password string (Maximum 162 characters)";
              }
            }
          }
          container send-lifetime {
            tailf:info "Set send lifetime of key";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf local {
              tailf:info "Specify time in local timezone";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm:ss;;Time to start";
                pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-31>;;Day of the month to start";
                range "1..31";
              }
            }
            leaf start-year {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1993-2035>;;Year to start";
                range "1993..2035";
              }
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  tailf:info "Set key lifetime duration";
                  type uint32 {
                    tailf:info "<1-2147483646>;;Seconds";
                    range "1..2147483646";
                  }
                }
              }
              case stop-time {
                leaf stop-time {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "hh:mm:ss;;Time to stop";
                    pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                  }
                }
                leaf stop-month {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "Jan";
                    enum "Feb";
                    enum "Mar";
                    enum "Apr";
                    enum "May";
                    enum "Jun";
                    enum "Jul";
                    enum "Aug";
                    enum "Sep";
                    enum "Oct";
                    enum "Nov";
                    enum "Dec";
                  }
                }
                leaf stop-day {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-31>;;Day of the month to stop";
                    range "1..31";
                  }
                }
                leaf stop-year {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<1993-2035>;;Year to stop";
                    range "1993..2035";
                  }
                }
              }
              case infinite {
                leaf infinite {
                  tailf:info "Never expires";
                  type empty;
                }
              }
            }
          }
          leaf cryptographic-algorithm {
            type enumeration {
              enum "HMAC-MD5";
            }
          }
        }
      }
    }
    container control-plane {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Control Plane";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ctrl";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container management-plane {
        tailf:cli-add-mode;
        container inband {
          tailf:cli-add-mode;
          list interface {
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            list allow {
              key "proto";
              leaf proto {
                type enumeration {
                  enum "SSH";
                  enum "XML";
                  enum "SNMP";
                }
              }
              leaf peer {
                tailf:cli-hide-in-submode;
                type empty;
              }
              container address {
                list ipv6 {
                  key "prefix";
                  leaf prefix {
                    type ipv6-prefix;
                  }
                }
              }
            }
          }
        }
        container out-of-band {
          tailf:cli-add-mode;
          list interface {
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            list allow {
              key "proto";
              leaf proto {
                type enumeration {
                  enum "SSH";
                  enum "XML";
                  enum "SNMP";
                }
              }
            }
          }
        }
      }
    }
    container dhcp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Dynamic Host Configuration Protocol";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container ipv6 {
        tailf:cli-add-mode;
        container interface-old {
          tailf:cli-drop-node-name;
          list interface {
            tailf:cli-full-command;
            key "ifname type";
            leaf ifname {
              type string {
                tailf:info "Interface Name";
              }
            }
            leaf type {
              type enumeration {
                enum "proxy";
                enum "relay";
                enum "server";
              }
            }
            leaf profile {
              type string;
            }
            leaf destination {
              type inet:ipv6-address;
            }
          }
        }
        container interface {
          tailf:cli-drop-node-name;
          list interface {
            tailf:cli-incomplete-command;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "name type";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            leaf type {
              type enumeration {
                enum "proxy";
                enum "relay";
                enum "server";
              }
            }
            leaf profile {
              type string;
            }
            leaf destination {
              type inet:ipv6-address;
            }
          }
        }
        list profile {
          key "name type";
          leaf name {
            type string;
          }
          leaf type {
            type enumeration {
              enum "proxy";
              enum "relay";
            }
          }
          list helper-address {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address";
            leaf address {
              type inet:ipv6-address;
            }
            leaf vrf {
              type string;
              tailf:cli-prefix-key;
            }
          }
        }
      }
    }
    container diagnostic {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure diagnostic information";
      tailf:cli-explicit-exit;
      container bootup {
        tailf:info "Configure diagnostic for bootup";
        leaf level {
          tailf:info "Select diagnostic level";
          type enumeration {
            enum "complete" {
              tailf:info "Complete level";
            }
            enum "minimal" {
              tailf:info "Minimal level";
            }
          }
        }
      }
    }
    container snmp-server {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "SNMP configuration subcommands";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv4/access-list/named-acl/name";
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv6/access-list/named-acl/name";
      container mroutemib {
        tailf:info "Configurations related to IPMROUTE-MIB";
        leaf send-all-vrf {
          tailf:info "enable sending all vrf interface info for cIpMRouteInterfaceTable";
          type empty;
        }
      }
      container mibs {
        tailf:info "MIB for configurations";
        container cbqosmib {
          tailf:info "Configure CBQoSMIB parameters";
          container cache {
            tailf:info "Enable CBQoSMIB stats data caching";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-cbqosmibcache";
            container refresh {
              tailf:info "Cache refresh interval";
              leaf time {
                tailf:info "Cache refresh time in seconds ";
                type uint16 {
                  tailf:info "<5-60>;;Refresh time in secs";
                  range "5..60";
                }
              }
            }
            container service-policy {
              tailf:info "Maximum number of service policies to cache the statistics for";
              leaf count {
                tailf:info "Number of service-policy stats";
                type uint16 {
                  tailf:info "<1-5000>;;Number of service-policys";
                  range "1..5000";
                }
              }
            }
          }
        }
      }
      list community {
        tailf:info "Enable SNMP; set community string and access privs";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;SNMP community string";
          }
        }
        leaf view {
          tailf:info "Restrict this community to a named MIB view";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;MIB view to which this community has access";
          }
        }
        choice access-choice {
          leaf RO {
            tailf:info "Read-only access with this community string";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf RW {
            tailf:info "Read-write access with this community string";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access-list";
          }
        }
      }
      leaf contact {
        tailf:info "Text for mib Object sysContact";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;identification of the contact person for this managed node";
        }
      }
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key "address";
        leaf address {
          type string {
            tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
          }
        }
        leaf informs {
          tailf:info "Send Inform messages to this host";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf traps {
          tailf:info "Send Trap messages to this host";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf version {
          tailf:info "SNMP version to use for notification messages";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "1" {
              tailf:info "WORD  Use 1 for SNMPv1";
            }
            enum "2c" {
              tailf:info "WORD;;Use 2c for SNMPv2c";
            }
            enum "3" {
              tailf:info "WORD;;Use 3 for SNMPv3";
            }
          }
        }
        leaf security-level {
          when "../version = 3" {
            tailf:xpath-root "3";
            tailf:dependency "../version";
          }
          tailf:cli-drop-node-name;
          type enumeration {
            enum "auth" {
              tailf:info "Using authNoPriv Security Level";
            }
            enum "noauth" {
              tailf:info "Using noAuthNoPriv Security Level";
            }
            enum "priv" {
              tailf:info "Using authPriv Security Level";
            }
          }
        }
        leaf enc {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "clear" {
              tailf:info "Save the community string in encrypted form";
            }
            enum "encrypted" {
              tailf:info "Specifies an ENCRYPTED community string";
            }
          }
        }
        leaf community-string {
          tailf:cli-drop-node-name;
          mandatory true;
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
          }
        }
        leaf udp-port {
          tailf:info "udp port to which notifications should be sent";
          tailf:cli-optional-in-sequence;
          type uint16;
        }
      }
      leaf ifindex {
        tailf:info "Enable ifindex persistence";
        tailf:cli-full-command;
        type enumeration {
          enum "persist" {
            tailf:info "Persist interface indices";
          }
        }
      }
      container ifmib {
        tailf:info "IF-MIB configuration commands";
        container ifalias {
          tailf:info "Modify parameters for ifAlias object";
          leaf long {
            tailf:info "Enable support for ifAlias values longer than 64 characters";
            type empty;
          }
        }
        container stats {
          tailf:info "Modify IF-MIB statistics parameters";
          leaf cache {
            tailf:info "Get cached interface statistics";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      leaf location {
        tailf:info "Text for mib Object sysLocation";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The physical location of this node";
        }
      }
      container trap {
        tailf:info "MIB trap configurations";
        leaf link {
          tailf:info "Link up/down trap configuration";
          tailf:cli-full-command;
          type enumeration {
            enum "ietf" {
              tailf:info "Set the varbind of linkupdown trap to the RFC specified varbinds (default cisco)";
            }
          }
        }
      }
      list user {
        tailf:info "Define a user who can access the SNMP engine";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key "username";
        leaf username {
          type string {
            tailf:info "WORD;;Name of the user";
          }
        }
        leaf groupname {
          tailf:cli-drop-node-name;
          mandatory true;
          type string {
            tailf:info "WORD;;Group to which the user belongs";
          }
        }
        leaf options {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string;
        }
      }
      list view {
        tailf:info "Define an SNMPv2 MIB view";
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key "view-name";
        leaf view-name {
          type string {
            tailf:info "WORD;;Name of the view";
          }
        }
        list oid-list {
          tailf:cli-suppress-mode;
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key "oid-tree";
          leaf oid-tree {
            type string {
              tailf:info "WORD;;MIB view family name";
            }
          }
          leaf viewmode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "excluded" {
                tailf:info "MIB family is excluded from the view";
              }
              enum "included" {
                tailf:info "MIB family is included in the view";
              }
            }
          }
        }
      }
      list group {
        tailf:info "Define a User Security Model group";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name of the group";
          }
        }
        choice version-choice {
          leaf v1 {
            tailf:info "group using the v1 security model";
            type empty;
          }
          leaf v2c {
            tailf:info "group using the v2c security model";
            type empty;
          }
          leaf v3 {
            tailf:info "group using the User Security Model (SNMPv3)";
            type enumeration {
              enum "auth" {
                tailf:info "group using the authNoPriv Security Level";
              }
              enum "noauth" {
                tailf:info "group using the noAuthNoPriv Security Level";
              }
              enum "priv" {
                tailf:info "group using authPriv Security Level";
              }
            }
          }
        }
        leaf read {
          tailf:cli-break-sequence-commands;
          type string {
            length "1..64";
          }
        }
        leaf write {
          type string {
            length "1..64";
          }
        }
        leaf notify {
          type string {
            length "1..64";
          }
        }
        leaf context {
          type string;
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "v1|v2c|v3|read|write|notify|context";
          type string {
            length "1..64";
          }
        }
      }
      container traps {
        tailf:info "Enable SNMP traps";
        leaf bfd {
          tailf:info "Enable BFD traps";
          tailf:cli-full-command;
          type empty;
        }
        container bgp {
          tailf:info "Enable BGP4-MIB and CISCO-BGP4-MIB traps";
          tailf:cli-delete-when-empty;
          presence "true";
          leaf cbgp2 {
            tailf:info "Enable CISCO-BGP4-MIB v2 traps";
            type empty;
          }
        }
        leaf bridgemib {
          tailf:info "Enable SNMP Trap for Bridge MIB";
          tailf:cli-full-command;
          type empty;
        }
        leaf config {
          tailf:info "Enable SNMP config traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf copy-complete {
          tailf:info "Enable CISCO-CONFIG-COPY-MIB ccCopyCompletion traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf ds3 {
          tailf:info "Enable SNMP Cisco DS3 traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf entity {
          tailf:info "Enable SNMP entity traps";
          tailf:cli-full-command;
          type empty;
        }
        container entity-state {
          tailf:info "Enable SNMP entity-state traps";
          leaf operstatus {
            tailf:info "Enable entity oper status enable notification";
            tailf:cli-full-command;
            type empty;
          }
          leaf switchover {
            tailf:info "Enable entity state switchover notifications";
            tailf:cli-full-command;
            type empty;
          }
        }
        container entity-redundancy {
          tailf:info "Enable SNMP CISCO-ENTITY-REDUNDANCY-MIB traps";
          leaf all {
            tailf:info "Enable all CISCO-ENTITY-REDUNDANCY-MIB traps";
            type empty;
          }
        }
        container ethernet {
          tailf:info "Enable SNMP Ethernet traps";
          leaf cfm {
            tailf:info "Enable traps for 802.1ag Connectivity Fault Management";
            tailf:cli-full-command;
            type empty;
          }
          leaf oam {
            tailf:info "Enable link-oam traps";
            tailf:cli-full-command;
            type enumeration {
              enum "events" {
                tailf:info "Enable all OAM event traps";
              }
            }
          }
        }
        container flash {
          tailf:info "Enable  flash-mib traps";
          leaf insertion {
            tailf:info "Enable ciscoFlashDeviceInsertedNotif";
            tailf:cli-full-command;
            type empty;
          }
          leaf removal {
            tailf:info "Enable ciscoFlashDeviceRemovedNotif";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf fru-ctrl {
          tailf:info "Enable SNMP entity FRU control traps";
          tailf:cli-full-command;
          type empty;
        }
        container ipsec {
          tailf:info "Enable SNMP IPSec traps";
          container tunnel {
            tailf:info "Enable SNMP IPsec Tunnel traps";
            leaf stop {
              tailf:info "Enable SNMP IPsec Tunnel Stop trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf start {
              tailf:info "Enable SNMP IPsec Tunnel Start trap";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        container isakmp {
          tailf:info "Enable SNMP ISAKMP traps";
          container tunnel {
            tailf:info "Enable SNMP ISAKMP Tunnel traps";
            leaf stop {
              tailf:info "Enable SNMP ISAKMP Tunnel Stop trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf start {
              tailf:info "Enable SNMP ISAKMP Tunnel Start trap";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        container mpls {
          tailf:info "Enable SNMP MPLS traps";
          container frr {
            tailf:info "Enable MPLS FRR traps";
            leaf all {
              tailf:info "Enable all MPLS FRR MIB traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf protected {
              tailf:info "Enable MPLS FRR tunnel protected traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf unprotected {
              tailf:info "Enable MPLS FRR tunnel unprotected traps";
              tailf:cli-full-command;
              type empty;
            }
          }
          container ldp {
            tailf:info "Enable MPLS LDP traps";
            leaf down {
              tailf:info "Enable MPLS LDP session down traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf threshold {
              tailf:info "Enable MPLS LDP threshold traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf up {
              tailf:info "Enable MPLS LDP session up traps";
              tailf:cli-full-command;
              type empty;
            }
          }
          container l3vpn {
            tailf:info "Enable MPLS L3VPN traps";
            leaf all {
              tailf:info "Enable all MPLS L3VPN traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf vrf-up {
              tailf:info "Enable VRF up traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf vrf-down {
              tailf:info "Enable VRF down traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf max-threshold-cleared {
              tailf:info "Enable max-threshold cleared traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf max-threshold-exceeded {
              tailf:info "Enable max-threshold exceeded traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf mid-threshold-exceeded {
              tailf:info "Enable mid-threshold exceeded traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf max-threshold-reissue-notif-time {
              tailf:info "Time interval (secs) for re-issuing max-threshold notification";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-2147483647>;;Time interval in seconds";
                range "0..2147483647";
              }
            }
          }
          container traffic-eng {
            tailf:info "Enable MPLS TE traps";
            leaf up {
              tailf:info "Enable MPLS TE tunnel up traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf down {
              tailf:info "Enable MPLS TE tunnel down traps";
              tailf:cli-full-command;
              type empty;
            }
            container p2mp {
              tailf:info "Enable MPLS TE P2MP traps";
              leaf down {
                tailf:info "Enable MPLS TE P2MP tunnel destination down traps";
                tailf:cli-full-command;
                type empty;
              }
              leaf up {
                tailf:info "Enable MPLS TE P2MP tunnel destination up traps";
                tailf:cli-full-command;
                type empty;
              }
            }
            leaf reroute {
              tailf:info "Enable MPLS TE tunnel reroute traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf reoptimize {
              tailf:info "Enable MPLS TE tunnel reoptimize traps";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        container msdp {
          tailf:info "Enable SNMP MSDP traps";
          leaf peer-state-change {
            tailf:info "Enable Peer state change trap";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf ntp {
          tailf:info "Enable SNMP Cisco Ntp traps";
          tailf:cli-full-command;
          type empty;
        }
        container ospf {
          tailf:info "Enable SNMP ospf traps";
          container state-change {
            tailf:info "Enable SNMP traps for ospf state change";
            leaf neighbor-state-change {
              tailf:info "Enable SNMP traps for ospf neighbor state change";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        leaf otn {
          tailf:info "Enable SNMP Cisco otn traps";
          tailf:cli-full-command;
          type empty;
        }
        container pim {
          tailf:info "Enable SNMP PIM traps";
          leaf interface-state-change {
            tailf:info "Enable interface state change trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf invalid-message-received {
            tailf:info "Enable invalid message received trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf neighbor-change {
            tailf:info "Enable neighbor change trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf rp-mapping-change {
            tailf:info "Enable rp mapping change trap";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf rf {
          tailf:info "Enable SNMP RF-MIB traps";
          tailf:cli-full-command;
          type empty;
        }
        container rsvp {
          tailf:info "Enable RSVP MIB traps";
          leaf all {
            tailf:info "Enable all RSVP MIB traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf new-flow {
            tailf:info "Enable RSVP new_flow traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf lost-flow {
            tailf:info "Enable RSVP lost_flow traps";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf sensor {
          tailf:info "Enable SNMP entity sensor traps";
          tailf:cli-full-command;
          type empty;
        }
        container snmp {
          tailf:info "Enable SNMPv2-MIB traps";
          tailf:cli-display-separated;
          presence "true";
          leaf coldstart {
            tailf:info "Enable SNMPv2-MIB coldStart trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf linkup {
            tailf:info "Enable SNMPv2-MIB linkUp traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf linkdown {
            tailf:info "Enable SNMPv2-MIB linDownp traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf warmstart {
            tailf:info "Enable SNMPv2-MIB warmStart trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf authentication {
            tailf:info "Enable SNMPv2-MIB authenticationFailure trap";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf system {
          tailf:info "Enable SNMP SYSTEMMIB-MIB traps";
          tailf:cli-full-command;
          type empty;
        }
      }
      container trap-source {
        tailf:info "Assign an interface for the source address of all traps";
        tailf:cli-diff-dependency "../../cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
      container interface {
        tailf:info "Enter the SNMP interface configuration commands";
        list subset {
          tailf:info "Add configuration for an interface subset";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "id";
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;The interface subset number";
            }
          }
          leaf regular-expression {
            tailf:info "Interfaces matching regular expression";
            type string {
              tailf:info "WORD;;Regular expression to match ifName";
            }
          }
          leaf notification {
            tailf:info "Allow an SNMP notification type";
            type enumeration {
              enum "linkupdown" {
                tailf:info "SNMP linkUp and linkDown notifications";
              }
            }
          }
        }
      }
      leaf queue-length {
        tailf:info "Message queue length for each TRAP host";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-5000>;;Queue length (default 100)";
          range "1..5000";
        }
      }
    }
    container srlg {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "SRLG configuration commands";
      tailf:cli-add-mode;
      presence "true";
    }
    list monitor-session {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name "config-mon";
      tailf:cli-explicit-exit;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
      }
      container destination {
        tailf:info "Specify the destination that traffic should be replicated to";
        choice destination-choice {
          leaf pseudowire {
            tailf:info "Specify a pseudowire";
            type empty;
          }
          container interface {
            tailf:info "Specify a destination interface";
            tailf:cli-diff-dependency "../../../cisco-ios-xr:interface";
            uses interface-name-grouping;
          }
        }
      }
    }
    container spanning-tree {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Spanning Tree Subsystem";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container extend {
        tailf:info "Spanning Tree 802.1t extensions";
        leaf system-id {
          tailf:info "Extend system-id into priority portion of the bridge id (PVST & Rapid PVST only)";
          type empty;
        }
      }
      leaf mode {
        tailf:info "Spanning tree operating mode";
        type enumeration {
          enum "mst" {
            tailf:info "Multiple spanning tree mode";
          }
          enum "rapid-pvst" {
            tailf:info "Per-Vlan rapid spanning tree mode";
          }
        }
      }
      container mst {
        tailf:info "Multiple spanning tree configuration";
        list range {
          tailf:cli-drop-node-name;
          tailf:cli-range-list-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint8 {
              tailf:info "WORD;;MST instance range, example: 0-3,5,7-9";
            }
          }
          leaf priority {
            tailf:info "Set the bridge priority for the spanning tree";
            type uint16 {
              tailf:info "<0-61440>;;bridge priority in increments of 4096";
              range "0..61440";
            }
          }
        }
        container configuration {
          tailf:cli-add-mode;
          tailf:info "Enter MST configuration submode";
          leaf name {
            tailf:info "Set configuration name";
            type string {
              tailf:info "WORD;;Configuration name";
            }
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum "disable" {
            tailf:info "Disable portfast for this interface";
          }
          enum "edge" {
            tailf:info "Enable portfast edge on the interface";
          }
          enum "network" {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
      list mstag {
        tailf:info "Configure MST Access Gateway";
        tailf:cli-mode-name "config-mstag";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }
        list interface {
          tailf:cli-mode-name "config-mstag-if";
          key "ifname";
          leaf ifname {
            type string {
              tailf:info "Interface Name";
            }
          }
          leaf name {
            tailf:info "Configuration name";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Configuration name";
            }
          }
          leaf port-id {
            tailf:info "Interface Port ID.";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-4095>;;Interface Port ID.";
              range "1..4095";
            }
          }
          leaf bridge-id {
            tailf:info "Set the Bridge ID this port should use";
            tailf:cli-full-command;
            type string {
              tailf:info "H.H.H;;MAC address";
              pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
            }
          }
          list instance {
            tailf:info "Enable and Configure an instance on this interface.";
            tailf:cli-mode-name "config-mstag-if-inst";
            key "id";
            leaf id {
              type uint16 {
                tailf:info "<0-4094>;;MSTI ID";
                range "0..4094";
              }
            }
            container cost {
              tailf:info "Cost of this port on this MSTI.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf cost-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-200000000>;;Port Cost";
                  range "1..200000000";
                }
              }
              leaf startup-value {
                tailf:info "Set the cost of this port on this MSTI to be used during pre-empt delay";
                type uint32 {
                  tailf:info "<1-200000000>;;Port Cost";
                  range "1..200000000";
                }
              }
            }
            leaf-list vlan-ids {
              tailf:info "Assign ranges of VLANs to the specified MSTI.";
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
              }
            }
            container root-id {
              tailf:info "Set the Bridge ID of the root for this instance";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf root-id-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "H.H.H;;MAC address";
                  pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
                }
              }
              leaf startup-value {
                tailf:info "Set the Bridge ID to be used during pre-empt delay";
                type string {
                  tailf:info "H.H.H;;MAC address";
                  pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
                }
              }
            }
            container priority {
              tailf:info "MSTI Priority.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf priority-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step "4096";
                  }
                }
              }
              leaf startup-value {
                tailf:info "Set the MSTI Priority to be used during pre-empt delay";
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step "4096";
                  }
                }
              }
            }
            container root-priority {
              tailf:info "Priority of the root for this instance.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf priority-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step "4096";
                  }
                }
              }
              leaf startup-value {
                tailf:info "Set the priority of the root for this instance to be used during pre-empt delay";
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step "4096";
                  }
                }
              }
            }
          }
        }
      }
      list repag {
        tailf:info "Configure REP Access Gateway";
        tailf:cli-mode-name "config-repag";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }
        list interface {
          tailf:cli-mode-name "config-repag-if";
          key "ifname";
          leaf ifname {
            type string {
              tailf:info "Interface Name";
            }
          }
        }
      }
    }
    container redundancy {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Interchassis redundancy configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-redundancy";
      tailf:cli-explicit-exit;
      container iccp {
        tailf:info "configure iccp parameter";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-redundancy-iccp";
        list group {
          tailf:info "group configuration";
          tailf:cli-mode-name "config-redundancy-iccp-group";
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter group number";
              range "1..4294967295";
            }
          }
          container mlacp {
            tailf:info "Multi-chassis Link Aggregation Control Protocol commands";
            leaf node {
              tailf:info "Set mLACP node ID to use in this ICCP Group";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Unique node ID in the ICCP Group for this system.";
                range "0..7";
              }
            }
            container system {
              tailf:info "Set the default system parameters for LACP bundles";
              leaf mac {
                tailf:info "The LACP System ID to be used in this ICCP Group.";
                tailf:cli-full-command;
                type string {
                  tailf:info "H.H.H;;Unique ID for this system. Any non-zero value is permitted.";
                }
              }
              leaf priority {
                tailf:info "Set the LACP system priority to be used in this ICCP Group.";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-65535>  Priority for this system. Lower value is higher priority.";
                  range "1..65535";
                }
              }
            }
          }
          container member {
            tailf:info "configure ICCP members";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-redundancy-group-iccp-member";
            leaf neighbor {
              tailf:info "configure interchassis group ICCP members";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;neighbor ip address";
              }
            }
          }
          container isolation {
            tailf:info "Set the isolation parameters";
            leaf recovery-delay {
              tailf:info "Specify delay before clearing isolation condition after recovery from failure";
              type uint16 {
                tailf:info "<30-300>;;Recovery delay in seconds.";
                range "30..300";
              }
            }
          }
        }
      }
    }
    container ssh {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Secure Shell configuration";
      tailf:cli-explicit-exit;
      container client {
        tailf:info "Provide SSH client service";
        container source-interface {
          tailf:info "Source interface for ssh client sessions";
          tailf:cli-diff-dependency "../../../cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
      container server {
        tailf:info "Provide SSH server service";
        leaf logging {
          tailf:info "Enable ssh server logging";
          type empty;
        }
        leaf rate-limit {
          tailf:info "Cisco sshd rate-limit of service requests";
          type uint32;
        }
        leaf session-limit {
          tailf:info "Cisco sshd session-limit of service requests";
          type uint32;
        }
        leaf v2 {
          tailf:info "Cisco sshd force protocol version 2 only";
          type empty;
        }
        list vrf {
          tailf:info "Cisco sshd VRF name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Enter vrf name";
            }
          }
          container ipv6 {
            tailf:info "IPv6 access list for ssh server";
            leaf access-list {
              tailf:info "Configure IPv6 access-list";
              type leafref {
                tailf:info "WORD;;Name of IPv6 access list - Max 32 characters";
                path "../../../../../cisco-ios-xr:ipv6/access-list/named-acl/name";
              }
            }
          }
        }
      }
      leaf timeout {
        tailf:info "Set timeout value for SSH";
        type uint8 {
          tailf:info "<5-120>;;Timeout value between 5-120 seconds";
          range "5..120";
        }
      }
    }
    container ipsla {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "IPSLA configuration commands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:key/chain";
      leaf key-chain {
        tailf:info "Use MD5 authentication for IPSLA control message";
        tailf:cli-full-command;
        type string;
      }
      container responder {
        tailf:info "IPSLA responder configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ipsla-resp";
        presence "true";
      }
    }
    container performance-mgmt {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Performance Management configuration & operation subcommands";
      tailf:cli-explicit-exit;
      container thresholds {
        tailf:info "Configure thresholds for collected data";
        container node {
          tailf:info "Configure thresholds for node";
          container cpu {
            tailf:info "Configure thresholds for cpu";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name "config-threshold-cpu";
              key "name";
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
          container process {
            tailf:info "Configure thresholds for process";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name "config-threshold-proc";
              key "name";
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
        }
      }
      container apply {
        tailf:info "Start data collection and/or threshold monitoring";
        container thresholds {
          tailf:info "Start threshold monitoring using a defined template";
          container node {
            tailf:info "Perform threshold monitoring for node";
            container cpu {
              tailf:info "Perform threshold checking for CPU";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf location {
                tailf:cli-incomplete-command;
                type string;
              }
              leaf template {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Specify an existing template for threshold checking";
                }
              }
            }
            container process {
              tailf:info "Perform threshold checking for process";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf location {
                tailf:cli-incomplete-command;
                type string;
              }
              leaf template {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Specify an existing template for threshold checking";
                }
              }
            }
          }
        }
      }
    }
    container vlan {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Vlan commands";
      tailf:cli-explicit-exit;
      container internal {
        tailf:info "internal VLAN";
        container allocation {
          tailf:info "internal VLAN allocation";
          leaf policy {
            tailf:info "internal VLAN allocation policy";
            type enumeration {
              enum "ascending" {
                tailf:info "Allocate internal VLAN in ascending order";
              }
              enum "descending" {
                tailf:info "Allocate internal VLAN in descending order";
              }
            }
          }
        }
      }
      container access-log {
        tailf:info "Configure VACL logging";
        leaf maxflow {
          tailf:info "Set vacl logging maximum flow number";
          type uint16 {
            tailf:info "<0-2048>;;Maximum flow number";
            range "0..2048";
          }
        }
        leaf ratelimit {
          tailf:info "Set vacl logging rate limiter ";
          type uint16 {
            tailf:info "<0-5000>;;Maximum number of packets logged per second";
            range "0..5000";
          }
        }
        leaf threshold {
          tailf:info "Set vacl log-update threshold";
          type uint32 {
            tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
            range "0..2147483647";
          }
        }
      }
      list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-vlan";
        tailf:cli-range-list-syntax;
        key "id";
        leaf id {
          type uint16 {
            tailf:info "WORD;;ISL VLAN IDs 1-4094";
            range "1..4094";
          }
        }
        leaf name {
          tailf:info "Ascii name of the VLAN";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;The ascii name for the VLAN";
          }
        }
        leaf uni-vlan {
          tailf:info "Configure a UNI VLAN";
          tailf:cli-full-command;
          type enumeration {
            enum "community" {
              tailf:info "UNI/ENI community VLAN";
            }
            enum "isolated" {
              tailf:info "UNI/ENI isolated VLAN";
            }
          }
        }
      }
    }
    container line {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Line subcommands";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv4/access-list/named-acl/name";
      tailf:cli-diff-dependency "../cisco-ios-xr:ipv6/access-list/named-acl/name";
      container console {
        tailf:info "console template";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-line";
        uses line-grouping;
      }
      container default {
        tailf:info "default template";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-line";
        uses line-grouping;
      }
      list template {
        tailf:info "user defined template";
        tailf:cli-mode-name "config-line";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name of template to configure";
          }
        }
        uses line-grouping;
      }
    }
    container lldp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global LLDP configuration subcommands";
      tailf:cli-explicit-exit;
      leaf holdtime {
        tailf:info "Specify the holdtime (in sec) to be sent in packets";
        type uint16 {
          tailf:info "<0-65535>;;Length  of time  (in sec) that receiver must keep this packet ";
          range "0..65535";
        }
      }
      leaf reinit {
        tailf:info "Delay (in sec) for LLDP initialization on any interface";
        type uint8 {
          tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
          range "2..5";
        }
      }
      leaf run {
        tailf:info "Enable LLDP";
        type empty;
      }
      leaf timer {
        tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
        type uint16 {
          tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
          range "5..65534";
        }
      }
    }
    container switch-fabric {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      list service-policy {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name";
        leaf name {
          type leafref {
            tailf:info "WORD;;Name of the service policy";
            path "../../../cisco-ios-xr:policy-map/name";
          }
        }
      }
    }
    container lpts {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "lpts configuration commands";
      tailf:cli-explicit-exit;
      container pifib {
        tailf:info "pre-ifib configuration commands";
        container hardware {
          tailf:info "hardware configuration commands";
          container police {
            tailf:info "ingress policers configuration command";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pifib-policer-global";
            uses lpts-grouping;
            list location {
              tailf:info "Location Specification";
              tailf:cli-mode-name "config-pifib-policer-per-node";
              key "node-id";
              leaf node-id {
                type string {
                  tailf:info "WORD;;Enter Location";
                }
              }
              uses lpts-grouping;
            }
          }
        }
      }
    }
    container hw-module {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure h/w module";
      tailf:cli-explicit-exit;
      container qos {
        container pol-gran {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf granularity {
            tailf:cli-drop-node-name;
            type uint8 {
              range "8..64";
            }
          }
          leaf location {
            type string;
          }
        }
        container queue-auto-defrag {
          container disable {
            list location {
              key "id";
              leaf id {
                type string;
              }
            }
          }
        }
        container account {
          container layer2 {
            container encapsulation {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice encapsulation-choice {
                leaf arpa {
                  type empty;
                }
                leaf dot1q {
                  type empty;
                }
                leaf length {
                  type uint8 {
                    range "1..50";
                  }
                }
              }
              leaf location {
                type string;
              }
            }
          }
        }
        container multicast {
          leaf location {
            type string;
          }
        }
      }
      container pse {
        container allocate {
          container tcam {
            list location {
              key "id";
              leaf id {
                type string;
              }
              list region {
                key "name num";
                leaf name {
                  type string;
                }
                leaf num {
                  type uint32;
                }
              }
            }
          }
        }
      }
    }
    list class-map {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-cmap";
      tailf:cli-exit-command "end-class-map";
      key "name";
      leaf name {
        tailf:cli-disallow-value "end-class-map";
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      leaf prematch {
        tailf:cli-prefix-key;
        tailf:cli-drop-node-name;
        type enumeration {
          enum "match-all" {
            tailf:info "Logical-AND all matching statements under this classmap";
          }
          enum "match-any" {
            tailf:info "Logical-OR all matching statements under this classmap";
          }
        }
        default "match-all";
      }
      leaf description {
        tailf:info "Class-Map description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description of this class-map (up to 200 characters)";
        }
      }
      container match {
        tailf:info "classification criteria";
        uses class-map-match-grouping;
        container not {
          tailf:info "Negate match criteria";
          uses class-map-match-grouping;
        }
      }
    }
    list policy-map {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure a policymap";
      tailf:cli-mode-name "config-pmap";
      tailf:cli-exit-command "end-policy-map" {
        tailf:info "End policy map configuration";
      }
      tailf:cli-diff-dependency "../cisco-ios-xr:class-map";
      key "name";
      leaf name {
        tailf:cli-disallow-value "end-policy-map";
        type string {
          tailf:info "WORD;;Name of the policymap";
        }
      }
      container class {
        tailf:info "Class map";
        list class-ref {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-pmap-c";
          tailf:cli-full-command;
          key "map";
          leaf map {
            tailf:cli-disallow-value "class-default";
            type leafref {
              tailf:info "WORD;;Name of class";
              path "../../../../cisco-ios-xr:class-map/name";
            }
          }
          uses policy-map-class-grouping;
        }
        list class-default {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-pmap-c";
          tailf:cli-full-command;
          key "map";
          leaf map {
            type enumeration {
              enum "class-default" {
                tailf:info "The default class";
              }
            }
          }
          uses policy-map-class-grouping;
        }
      }
      leaf description {
        tailf:info "Set description for this policy-map";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description for this policy-map";
        }
      }
    }
    container clock-interface {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Clock interface configuration commands";
      tailf:cli-explicit-exit;
      list sync {
        tailf:info "Synchronization clock interface";
        tailf:cli-mode-name "config-clock-if";
        key "id location";
        leaf id {
          type uint32 {
            tailf:info "<0-4294967295>;;Clock interface port number";
          }
        }
        leaf location {
          tailf:info "Specify the clock interface location";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        container port-parameters {
          tailf:info "clock port parameter setting";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-clk-parms";
          container bits-input {
            tailf:info "BITS RX interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf mode {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              type enumeration {
                enum "2m" {
                  tailf:info "2m mode";
                }
                enum "64k-input-only" {
                  tailf:info "64k-input-only mode";
                }
                enum "e1" {
                  tailf:info "e1 mode";
                }
                enum "t1" {
                  tailf:info "t1 mode";
                }
              }
            }
            leaf mode1 {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              type enumeration {
                enum "d4" {
                  tailf:info "d4 mode";
                }
                enum "esf" {
                  tailf:info "esf mode";
                }
                enum "crc-4" {
                  tailf:info "crc4 mode";
                }
                enum "non-crc-4" {
                  tailf:info "non-crc-4 mode";
                }
              }
            }
            leaf mode2 {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              type union {
                type enumeration {
                  enum "ami" {
                    tailf:info "ami mode";
                  }
                  enum "b8zs" {
                    tailf:info "b8zs mode";
                  }
                }
                type string;
              }
            }
          }
        }
        container frequency {
          tailf:info "Frequency Synchronization configuration";
          container synchronization {
            tailf:info "Frequency Synchronization configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-clk-freqsync";
            container selection {
              tailf:info "Selection configuration commands";
              leaf input {
                tailf:info "Enable this source for selection";
                type empty;
              }
            }
            leaf priority {
              tailf:info "Source priority";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-254>;;Source priority";
                range "1..254";
              }
            }
            leaf wait-to-restore {
              tailf:info "Set the wait-to-restore time";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-12>;;Wait-to-restore time, in minutes";
                range "0..12";
              }
            }
            container quality {
              tailf:info "Quality level configuration";
              container receive {
                tailf:info "Adjust the received quality level";
                container exact {
                  tailf:info "Specify the exact QL value to use";
                  container itu-t {
                    tailf:info "ITU-T QL options";
                    container option {
                      tailf:info "ITU-T QL options";
                      leaf one {
                        tailf:alt-name "1";
                        tailf:info "ITU-T QL option 1";
                        tailf:cli-full-command;
                        type enumeration {
                          enum "DNU" {
                            tailf:info "This signal should not be used for synchronization";
                          }
                          enum "PRC" {
                            tailf:info "ITU-T Option 1: Primary reference clock";
                          }
                          enum "SEC" {
                            tailf:info "ITU-T Option 1: SONET equipment clock";
                          }
                          enum "SSU-A" {
                            tailf:info "ITU-T Option 1: Type I or V slave clock";
                          }
                          enum "SSU-B" {
                            tailf:info "ITU-T Option 1: Type IV slave clock";
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container l2 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Layer 2 configuration";
      tailf:cli-explicit-exit;
      list vfi {
        tailf:info "Configure a virtual forwarding instance";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;VFI name";
          }
        }
        leaf autodiscovery {
          tailf:info "Multipoint autodiscovery configuration mode";
          tailf:cli-hide-in-submode;
          type empty;
        }
        container vpn {
          tailf:info "VPN configuration";
          leaf id {
            tailf:info "VPN id";
            type uint32 {
              tailf:info "<1-4294967295>;;VPN id value";
              range "1..4294967295";
            }
          }
        }
      }
    }
    container auto {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Automation";
      tailf:cli-explicit-exit;
      leaf qos {
        tailf:info "Configure AutoQoS";
        type enumeration {
          enum "default" {
            tailf:info "Configure AutoQoS Default";
          }
        }
      }
    }
    container ethernet-services {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Ethernet related services";
      tailf:cli-explicit-exit;
      list access-list {
        tailf:cli-mode-name "config-es-acl";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Access list name - maximum 32 characters";
            length "1..32";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-2147483646>;;Sequence number for this entry";
              range "1..2147483646";
            }
          }
          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info
                "deny;;Specify packets to reject
                 permit;;Specify packets to forward
                 remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }
    container interface {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Select an interface to configure";
      tailf:cli-explicit-exit;
      uses interface-grouping;
      container preconfigure {
        tailf:info "Specify a preconfig";
        uses interface-grouping;
      }
    }
    container controller {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Controller configuration subcommands";
      tailf:cli-explicit-exit;
      list dwdm {
        tailf:info "DWDM controller(s)";
        tailf:cli-allow-join-with-key;
        key "id";
        leaf id {
          type string {
            tailf:info "dwdm Interface Instance";
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
          }
        }
        leaf proactive {
          tailf:info "Enable Proactive Protection Feature";
          type empty;
        }
        leaf admin-state {
          tailf:info "Configure the transport admin state of the controller: in-service, out-of-service or maintenance";
          type enumeration {
            enum "in-service" {
              tailf:info "change the admin-state to In-service (IS)";
            }
            enum "maintenance" {
              tailf:info "change the admin-state to Out-of-service-Maintenance (OOS-MT)";
            }
            enum "out-of-service" {
              tailf:info "change the admin-state to Out-of-service (OOS)";
            }
          }
        }
      }
      list MgmtMultilink {
        tailf:info "Controller for the management of multilink interfacess";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-mgmtmultilink";
        key "id";
        leaf id {
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
          }
        }
        list bundle {
          tailf:info "Configure a multilink bundle interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-999999999>;;Bundle Id";
            }
          }
        }
      }
      list T1 {
        tailf:info "T1 Port controller(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-t1";
        key "id";
        leaf id {
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
          }
        }
        leaf framing {
          tailf:info "Configure T1E1 framing";
          type enumeration {
            enum "esf" {
              tailf:info "esf framing: default";
            }
            enum "sf" {
              tailf:info "sf framing mode";
            }
          }
        }
        list channel-group {
          tailf:info "Configure channel group on T1E1";
          tailf:cli-mode-name "config-t1-channel_group";
          key "id";
          leaf id {
            type uint8 {
              tailf:info "<0-23>;;channel group number";
              range "0..23";
            }
          }
          leaf speed {
            tailf:info "speed of the ds0 channel";
            tailf:cli-full-command;
            type enumeration {
              enum "56" {
                tailf:info "56 Kbits";
              }
              enum "64" {
                tailf:info "64 Kbits";
              }
            }
          }
          leaf timeslots {
            tailf:info "List of timeslots in the channel group";
            type string {
              tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 24. (:) indicates individual timeslot and (-) represent range";
            }
          }
        }
        container clock {
          tailf:info "Configure clock source";
          container source {
            tailf:info "Configure t1/e1  TX clock source";
            choice source-choice {
              leaf internal {
                tailf:info "Select internal clock";
                type empty;
              }
              leaf line {
                tailf:info "Select clock recovered from line";
                type empty;
              }
            }
          }
        }
      }
      list T3 {
        tailf:info "T3 Port controller(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-t3";
        key "id";
        leaf id {
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
          }
        }
        leaf mode {
          tailf:info "Configure mode for the port";
          tailf:cli-full-command;
          type enumeration {
            enum "atm" {
              tailf:info "clear channel carrying atm";
            }
            enum "e1" {
              tailf:info "channelize into 21 E1s";
            }
            enum "serial" {
              tailf:info "clear channel carrying hdlc like payload";
            }
            enum "t1" {
              tailf:info "channelized into 28 T1s";
            }
          }
        }
        container delay {
          leaf trigger {
            tailf:info "trigger time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-60000>;;time in msec to soak before declaring the alarm";
              range "0..60000";
            }
          }
        }
        container clock {
          tailf:info "Configure clock source";
          container source {
            tailf:info "Configure t3/e3  TX clock source";
            choice source-choice {
              leaf internal {
                tailf:info "Select internal clock";
                type empty;
              }
              leaf line {
                tailf:info "Select clock recovered from line";
                type empty;
              }
            }
          }
        }
      }
      list sonet {
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-sonet";
        key "id";
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
          }
        }
        leaf description {
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string;
        }
        leaf ais-shut {
          tailf:cli-full-command;
          type empty;
        }
        leaf framing {
          tailf:cli-full-command;
          type enumeration {
            enum "sdh";
            enum "sonet";
          }
        }
        list sts {
          tailf:cli-mode-name "config-stsPath";
          key "id";
          leaf id {
            type uint32;
          }
          leaf width {
            type uint32;
          }
          leaf mode {
            type string;
          }
          container delay {
            leaf trigger {
              type uint32;
            }
          }
        }
        container threshold {
          leaf sf-ber {
            tailf:cli-full-command;
            type uint8;
          }
        }
        container clock {
          leaf source {
            type enumeration {
              enum "internal";
              enum "line";
            }
          }
        }
      }
    }
    container l2vpn {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure l2vpn commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container load-balancing {
        tailf:info "Global L2VPN Load Balancing";
        leaf flow {
          tailf:info "Enable Flow based load balancing";
          type enumeration {
            enum "src-dst-ip" {
              tailf:info "Use source and destination IP addresses for hashing";
            }
            enum "src-dst-mac" {
              tailf:info "Use source and destination MAC addresses for hashing";
            }
          }
        }
      }
      list pw-class {
        tailf:info "Pseudowire class template";
        tailf:cli-mode-name "config-l2vpn-pwc";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }
        container encapsulation {
          tailf:info "Pseudowire encapsulation";
          container l2tpv3 {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-l2tpv3";
            leaf protocol {
              tailf:info "Set the dynamic pseudowire signaling protocol";
              type enumeration {
                enum "l2tpv3" {
                  tailf:info "Set L2TPv3 as the signaling protocol for this pseudowire class";
                }
              }
            }
            leaf ttl {
              tailf:info "Set the Time To Live (TTL)";
              type uint8 {
                tailf:info "<1-255>;;TTL value";
                range "1..255";
              }
            }
          }
          container mpls {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-mpls";
            container transport-mode {
              tailf:info "Remote transport mode";
              choice transport-mode-choice {
                leaf ethernet {
                  tailf:info "Ethernet port mode";
                  type empty;
                }
                container vlan {
                  tailf:info "Vlan tagged mode";
                  tailf:cli-delete-when-empty;
                  presence "true";
                  leaf passthrough {
                    tailf:info "passthrough incoming tags";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
      container xconnect {
        tailf:info "Configure cross connect commands";
        list group {
          tailf:info "Specify the group the cross connects belong to";
          tailf:cli-mode-name "config-l2vpn-xc";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;Name of the cross connects group";
            }
          }
          list p2p {
            tailf:info "Configure point to point cross connect commands";
            tailf:cli-mode-name "config-l2vpn-xc-p2p";
            key "name";
            leaf name {
              type string {
                tailf:info "WORD;;Name of the point to point cross connect";
              }
            }
            list interface {
              tailf:info "Specify the attachment circuit";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "name";
              leaf name {
                type string {
                  tailf:info "Interface Name";
                }
              }
            }
            leaf monitor-session {
              tailf:info "Specify the monitor session";
              type leafref {
                tailf:info "WORD;;Name of the monitor session";
                path "../../../../../cisco-ios-xr:monitor-session/name";
              }
            }
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                }
              }
              leaf ip-version {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type enumeration {
                  enum "ipv4" {
                    tailf:info "Specify IPv4 address or hostname";
                  }
                  enum "ipv6" {
                    tailf:info "Specify IPv6 address or host name";
                  }
                }
              }
              container mpls {
                tailf:info "MPLS L2VPN PW command";
                container static {
                  tailf:info "MPLS L2VPN static settings";
                  container label {
                    tailf:info "MPLS L2VPN static labels";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf local {
                      tailf:info "Local pseudowire label";
                      tailf:cli-incomplete-command;
                      type uint16 {
                        tailf:info "<4017-15999>;;Local pseudowire label";
                        range "4017..15999";
                      }
                    }
                    leaf remote {
                      tailf:info "Remote pseudowire label";
                      type uint32 {
                        tailf:info "<16-1048575>;;Remote pseudowire label";
                        range "16..1048575";
                      }
                    }
                  }
                }
              }
              leaf pw-class {
                tailf:info "PW class template name to use for this XC";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }
              container l2tp {
                tailf:info "L2TP PW";
                container static {
                  tailf:info "L2TP PW static";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-l2tp";
                  container local {
                    tailf:info "L2TP PW static local";
                    container cookie {
                      tailf:info "L2TP PW static local cookie settings";
                      tailf:cli-compact-syntax;
                      tailf:cli-flatten-container;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf size {
                        tailf:info "L2TP PW static local cookie size settings";
                        type enumeration {
                          enum "0" {
                            tailf:info "The cookie size is zero bytes";
                          }
                          enum "4" {
                            tailf:info "The cookie size is four bytes";
                          }
                          enum "8" {
                            tailf:info "The cookie size is eight bytes";
                          }
                        }
                      }
                      container value {
                        tailf:info "The value of the cookie";
                        tailf:cli-sequence-commands;
                        tailf:cli-compact-syntax;
                        tailf:cli-flatten-container;
                        when "../size != 0" {
                          tailf:xpath-root "3";
                        }
                        leaf value_1 {
                          tailf:cli-drop-node-name;
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                          }
                        }
                        leaf value_2 {
                          tailf:cli-drop-node-name;
                          when "../../size != 4" {
                            tailf:xpath-root "3";
                          }
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                          }
                        }
                      }
                    }
                  }
                  container remote {
                    tailf:info "L2TP PW static remote";
                    container cookie {
                      tailf:info "L2TP PW static remote cookie settings";
                      tailf:cli-compact-syntax;
                      tailf:cli-flatten-container;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf size {
                        tailf:info "L2TP PW static remote cookie size settings";
                        type enumeration {
                          enum "0" {
                            tailf:info "The cookie size is zero bytes";
                          }
                          enum "4" {
                            tailf:info "The cookie size is four bytes";
                          }
                          enum "8" {
                            tailf:info "The cookie size is eight bytes";
                          }
                        }
                      }
                      container value {
                        tailf:info "The value of the cookie";
                        tailf:cli-sequence-commands;
                        tailf:cli-compact-syntax;
                        tailf:cli-flatten-container;
                        when "../size != 0" {
                          tailf:xpath-root "3";
                        }
                        leaf value_1 {
                          tailf:cli-drop-node-name;
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                          }
                        }
                        leaf value_2 {
                          tailf:cli-drop-node-name;
                          when "../../size != 4" {
                            tailf:xpath-root "3";
                          }
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                          }
                        }
                      }
                    }
                  }
                }
              }
              leaf source {
                tailf:info "Source address of PW";
                type inet:ipv6-address {
                  tailf:info "X:X::X;;Source IPv6 address of PW";
                }
              }
            }
          }
        }
      }
      container bridge {
        tailf:info "Configure bridge commands";
        list group {
          tailf:info "Specify the group the bridge belongs to";
          tailf:cli-mode-name "config-l2vpn-bg";
          key "group-name";
          leaf group-name {
            type string {
              tailf:info "WORD;;Name of the bridge group";
            }
          }
          list bridge-domain {
            tailf:info "Configure bridge domain";
            tailf:cli-mode-name "config-l2vpn-bg-bd";
            key "bridge-domain-name";
            leaf bridge-domain-name {
              type string;
            }
            list interface {
              tailf:info "Assign interface to bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-ac";
              key "name";
              leaf name {
                type string {
                  tailf:info "Interface Name";
                }
              }
              container storm-control {
                tailf:info "Storm Control";
                container broadcast {
                  tailf:info "Broadcast Storm Control";
                  leaf pps {
                    tailf:info "Set the storm control pps";
                    type uint32 {
                      tailf:info "<1-160000>;;storm control pps value";
                      range "1..160000";
                    }
                  }
                }
                container multicast {
                  tailf:info "Multicast Storm Control";
                  leaf pps {
                    tailf:info "Set the storm control pps";
                    type uint32 {
                      tailf:info "<1-160000>;;storm control pps value";
                      range "1..160000";
                    }
                  }
                }
                container unknown-unicast {
                  tailf:info "Unknown-unicast Storm Control";
                  leaf pps {
                    tailf:info "Set the storm control pps";
                    type uint32 {
                      tailf:info "<1-160000>;;storm control pps value";
                      range "1..160000";
                    }
                  }
                }
              }
            }
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-pw";
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                  range "1..4294967295";
                }
              }
              container mpls {
                tailf:info "MPLS L2VPN PW command";
                container static {
                  tailf:info "MPLS L2VPN static settings";
                  container label {
                    tailf:info "MPLS L2VPN static labels";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf local {
                      tailf:info "Local pseudowire label";
                      tailf:cli-incomplete-command;
                      type uint16 {
                        tailf:info "<4017-15999>;;Local pseudowire label";
                        range "4017..15999";
                      }
                    }
                    leaf remote {
                      tailf:info "Remote pseudowire label";
                      type uint32 {
                        tailf:info "<16-1048575>;;Remote pseudowire label";
                        range "16..1048575";
                      }
                    }
                  }
                }
              }
              leaf pw-class {
                tailf:info "PW class template name to use for this pseudowire";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }
            }
            container mac {
              tailf:info "MAC configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-mac";
              container withdraw {
                tailf:info "MAC withdraw";
                leaf state-down {
                  tailf:info "MAC withdraw sent on bridge port down";
                  type empty;
                }
              }
            }
            leaf mtu {
              tailf:info "Maximum transmission unit (payload) for this Bridge Domain";
              type uint16 {
                tailf:info "<46-65535>;;Maximum transmission unit size (payload) in bytes";
                range "46..65535";
              }
            }
            container routed {
              tailf:info "Bridge domain L3 interface";
              list interface {
                tailf:info "Assign interface to bridge domain";
                key "name";
                leaf name {
                  type string {
                    tailf:info "BVI;;Bridge-Group Virtual Interface";
                  }
                }
              }
            }
            list vfi {
              tailf:info "Specify the virtual forwarding interface name";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vfix";
              key "name";
              leaf name {
                tailf:info "WORD;;Name of the Virtual Forwarding Interface";
                type string;
              }
              leaf vpn-id {
                tailf:info "VPN Identifier (VPN ID)";
                type uint32 {
                  tailf:info "<1-65535>;;Value of the VPN ID";
                  range "1..65535";
                }
              }
              container autodiscovery {
                tailf:info "Enable auto-discovery in this VFI";
                container bgp {
                  tailf:info "Enable BGP auto-discovery in this VFI";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad";
                  leaf rd {
                    tailf:info "route distinguisher";
                    type string;
                  }
                  list route-target {
                    tailf:info "Route Target";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key "name";
                    leaf name {
                      type string;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container extcommunity-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define an extended community set";
      list rt {
        tailf:info "BGP Route Target (RT) extended community";
        tailf:cli-mode-name "config-ext";
        tailf:cli-reset-container;
        tailf:cli-exit-command "end-set";
        tailf:cli-full-command;
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Route Target type extcommunity set name";
          }
        }
        list set {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by "user";
          key "value";
          leaf value {
            type string;
            tailf:cli-multi-word-key;
            tailf:cli-disallow-value "end-set";
          }
        }
      }
    }
    list rd-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a BGP VPN route-distinguisher set";
      tailf:cli-mode-name "config-rd";
      tailf:cli-reset-container;
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Route Distinguisher set name";
        }
      }
      list set {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key "value";
        leaf value {
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "end-set";
          type string;
        }
      }
    }
    list prefix-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a prefix set";
      tailf:cli-mode-name "config-pfx";
      tailf:cli-reset-container;
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Prefix setname";
        }
      }
      list set {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key "value";
        leaf value {
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "end-set";
          type string;
        }
      }
    }
    list community-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a community set";
      tailf:cli-mode-name "config-comm";
      tailf:cli-reset-container;
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Community set name";
        }
      }
      list set {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key "value";
        leaf value {
          type string;
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "end-set";
        }
      }
    }
    list route-policy {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a route policy";
      tailf:cli-mode-name "config-rpl";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      tailf:cli-exit-command "end-policy";
      tailf:cli-full-command;
      key "name";
      leaf name {
        type string {
          tailf:info "WORD;;Route Policy name";
        }
      }
      list cmd {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key "value";
        leaf value {
          type string;
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "end-policy";
        }
      }
    }
    container router {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable a routing process";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container static {
        tailf:info "Static route configuration subcommands";
        tailf:cli-add-mode;
        container address-family {
          tailf:info "Static route address family configuration subcommands";
          container ipv4 {
            tailf:info "IPv4 commands";
            container unicast {
              tailf:info "Unicast commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-static-afi";
              list routes {
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                key "net interface";
                leaf net {
                  type ipv4-prefix {
                    tailf:info "A.B.C.D/length;;Destination prefix";
                  }
                }
                leaf interface {
                  type string {
                    tailf:info "Interface Name";
                  }
                }
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type inet:ipv4-address {
                    tailf:info "Forwarding router's address";
                  }
                }
                leaf tag {
                  tailf:info "Set tag for this route";
                  type uint16;
                }
                leaf description {
                  tailf:info "description of the static route";
                  type string;
                }
              }
            }
          }
          container ipv6 {
            tailf:info "IPv6 commands";
            container unicast {
              tailf:info "Unicast commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-static-afi";
              list routes {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                key "net interface";
                leaf net {
                  type ipv6-prefix {
                    tailf:info "X:X::X/length;;Destination prefix";
                  }
                }
                leaf interface {
                  type string {
                    tailf:info "Interface Name";
                  }
                }
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type inet:ipv6-address {
                    tailf:info "X:X::X;;Forwarding router's address";
                  }
                }
                leaf tag {
                  tailf:info "Set tag for this route";
                  tailf:cli-optional-in-sequence;
                  type uint16;
                }
                leaf description {
                  tailf:info "description of the static route";
                  type string;
                }
              }
            }
          }
        }
      }
      container igmp {
        tailf:cli-add-mode;
        presence "true";
      }
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-incomplete-command;
        list tag {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-isis";
          key "name";
          leaf name {
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf is-type {
            tailf:info "IS Level for this routing process (OSI only)";
            type enumeration {
              enum "level-1" {
                tailf:info "Act as a station router only";
              }
              enum "level-1-2" {
                tailf:info "Act as both a station router and an area router";
              }
              enum "level-2-only" {
                tailf:info "Act as an area router only";
              }
            }
          }
          leaf net {
            tailf:info "A Network Entity Title for this process (OSI only)";
            type string {
              tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
            }
          }
          container address-family {
            tailf:info "Enter the IS-IS address-family configuration submode";
            uses router-isis-address-family-grouping;
          }
          list interface {
            tailf:info "Enter the IS-IS interface configuration submode";
            tailf:cli-mode-name "config-isis-if";
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            leaf interface-type {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type enumeration {
                enum "active";
                enum "passive" {
                  tailf:info "Do not establish adjacencies over this interface";
                }
                enum "suppressed" {
                  tailf:info "Do not advertise connected prefixes of this interface";
                }
                enum "shutdown" {
                  tailf:info "Shutdown IS-IS on this interface";
                }
              }
            }
            container bfd {
              tailf:info "Configure BFD parameters";
              leaf fast-detect {
                tailf:info "Enable Fast detection";
                tailf:cli-full-command;
                type enumeration {
                  enum "ipv4" {
                    tailf:info "Address Family";
                  }
                  enum "ipv6" {
                    tailf:info "Address Family";
                  }
                  enum "disable";
                }
              }
              leaf minimum-interval {
                tailf:info "Hello interval";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<15-30000>;;hello interval in milli-seconds";
                }
              }
              leaf multiplier {
                tailf:info "Detect multiplier";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<2-50>;;Detect multiplier";
                }
              }
            }
            leaf point-to-point {
              tailf:info "Treat active LAN interface as point-to-point";
              tailf:cli-full-command;
              type empty;
            }
            leaf hello-padding {
              tailf:info "Add padding to IS-IS hello packets";
              tailf:cli-full-command;
              type enumeration {
                enum "disabled" {
                  tailf:info "Disable hello-padding";
                }
                enum "enabled" {
                  tailf:info "Enable hello-padding during adjacency formation only";
                }
              }
            }
            container hello-password {
              tailf:info "Configure the IIH password";
              leaf keychain {
                tailf:info "Specifies a Key Chain name will follow";
                type leafref {
                  path "../../../../../../cisco-ios-xr:key/chain/name";
                }
              }
              container hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
                leaf encrypted {
                  tailf:info "Specifies an encrypted password will follow";
                  type string {
                    tailf:info "WORD;;The encrypted hello password";
                  }
                }
              }
            }
            container link-down {
              tailf:info "Configure interface down event parameters";
              leaf fast-detect {
                tailf:info "Enable high priority detection";
                type empty;
              }
            }
            container address-family {
              tailf:info "Enter the IS-IS interface address-family configuration submode";
              uses router-isis-address-family-grouping;
            }
          }
          container authentication {
            tailf:info "ISIS authentication for LSPs";
            container key-chain {
              tailf:cli-reset-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:info "Authentication key-chain";
              leaf ref {
                tailf:cli-drop-node-name;
                type leafref {
                  path "../../../../../../cisco-ios-xr:key/chain/name";
                }
              }
              leaf level {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum "level-1" {
                    tailf:info "ISIS authentication for level-1";
                  }
                  enum "level-2" {
                    tailf:info "ISIS authentication for level-2";
                  }
                }
              }
            }
            container mode {
              tailf:info "Authentication mode";
              choice mode-choice {
                container md5 {
                  tailf:info "Keyed message digest";
                  presence "true";
                  leaf level {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum "level-1" {
                        tailf:info "ISIS authentication for level-1";
                      }
                      enum "level-2" {
                        tailf:info "ISIS authentication for level-2";
                      }
                    }
                  }
                }
                container text {
                  tailf:info "Clear text password";
                  presence "true";
                  leaf level {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum "level-1" {
                        tailf:info "ISIS authentication for level-1";
                      }
                      enum "level-2" {
                        tailf:info "ISIS authentication for level-2";
                      }
                    }
                  }
                }
              }
            }
          }
          leaf metric-style {
            tailf:info "Use old-style (ISO 10589) or new-style packet formats";
            type enumeration {
              enum "narrow" {
                tailf:info "Use old style of TLVs with narrow metric";
              }
              enum "transition" {
                tailf:info "Send and accept both styles of TLVs during transition";
              }
              enum "wide" {
                tailf:info "Use new style of TLVs to carry wider metric";
              }
            }
          }
          container set-overload-bit {
            tailf:info "Signal other routers not to use us in SPF";
            presence "true";
            leaf on-startup {
              tailf:info "Set overload-bit only temporarily after reboot";
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;   Time in seconds to advertise ourself as overloaded after reboot";
                  range "5..86400";
                }
                type enumeration {
                  enum "wait-for-bgp" {
                    tailf:info "Let BGP decide when to unset the overload bit";
                  }
                }
              }
            }
            container suppress {
              tailf:info "If overload-bit set, suppress the following types of IP prefixes";
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "If overload-bit set, don't advertise IP prefixes learned from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "If overload-bit set, don't advertise IP prefixes learned from another ISIS level";
                type empty;
              }
            }
          }
          container lsp-gen-interval {
            tailf:info "System and Pseudonode LSP generation scheduling parameters";
            leaf maximum-wait {
              type uint16 {
                range "1..65535";
              }
            }
            leaf initial-wait {
              type uint16 {
                range "1..65535";
              }
            }
            leaf secondary-wait {
              type uint16 {
                range "1..65535";
              }
            }
          }
          leaf lsp-refresh-interval {
            tailf:info "Set LSP refresh interval";
            type uint16 {
              range "1..65535";
            }
          }
          leaf max-lsp-lifetime {
            tailf:info "Set maximum LSP lifetime";
            type uint16 {
              tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
              range "1..65535";
            }
          }
          container log {
            tailf:info "Log changes in adjacency state";
            container adjacency {
              leaf changes {
                tailf:info "Include changes generated by non-IIH event";
                type empty;
              }
            }
          }
          container nsf {
            tailf:info "Non-stop forwarding";
            choice nsf-choice {
              container advertise {
                tailf:info "Send information to neighbors";
                leaf holdtime {
                  tailf:info "Adjust holdtime advertised in IIH when RR set";
                  type uint16 {
                    tailf:info "<5-3600>;;Seconds";
                    range "5..3600";
                  }
                }
              }
              leaf cisco {
                tailf:info "Checkpoint method";
                type empty;
              }
              leaf ietf {
                tailf:info "IETF method";
                type empty;
              }
              container interface {
                tailf:info "Interface properties";
                leaf wait {
                  tailf:info "Maximum time to wait for interface up";
                  type uint8 {
                    tailf:info "<1-60>;;Seconds";
                    range "1..60";
                  }
                }
              }
              leaf interval {
                tailf:info "Minimum required stable interval between restarts";
                type uint16 {
                  tailf:info "<0-1440>;;Minutes";
                  range "0..1440";
                }
              }
              container t3 {
                tailf:info "Time to set overload-bit if LSPDB synchronization not completed (T3 expiration)";
                choice t3-choice {
                  leaf adjacency {
                    tailf:info "Use minimum advertised adjacency holdtime for NSF T3 timeout";
                    type empty;
                  }
                  leaf manual {
                    tailf:info "Manually configure NSF T3 timeout";
                    type uint16 {
                      tailf:info "<5-3600>;;Seconds";
                      range "5..3600";
                    }
                  }
                }
              }
            }
          }
          container bfd {
            tailf:info "BFD configuration commands";
            leaf all-interfaces {
              tailf:info "Enable BFD on all interfaces";
              type empty;
            }
            leaf check-ctrl-plane-failure {
              tailf:info "BFD check control plane failure";
              type empty;
            }
          }
          container mpls {
            tailf:info "Configure MPLS routing protocol parameters";
            leaf ldp {
              tailf:info "routing protocol commands for MPLS LDP";
              type enumeration {
                enum "sync" {
                  tailf:info "Configure LDP-IGP Synchronization";
                }
              }
            }
            container traffic-eng {
              tailf:info "routing protocol commands for MPLS Traffic Engineering";
              leaf level-1 {
                tailf:info "Run MPLS TE on IS-IS level 1 only";
                type empty;
              }
              leaf level-2 {
                tailf:info "Run MPLS TE on IS-IS level 2 only";
                type empty;
              }
              leaf multicast-intact {
                tailf:info "MPLS TE and PIM interaction";
                type empty;
              }
              leaf router-id {
                tailf:info "Traffic Engineering stable IP address for system";
                type empty;
              }
              leaf scanner {
                tailf:info "Timer parameters for TE database";
                type empty;
              }
            }
          }
        }
      }
      list ospf {
        tailf:info "OSPF configuration subcommands";
        tailf:cli-mode-name "config-ospf";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPF process";
          }
        }
        leaf nsr {
          tailf:info "Enable NSR for all VRFs in this process";
          tailf:cli-full-command;
          type empty;
        }
        container log {
          tailf:info "Log ospf info";
          container adjacency {
            tailf:info "Log adjacency state info";
            container changes {
              tailf:info "Log changes";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence "true";
              leaf changes-state {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum "detail" {
                    tailf:info "Log all state changes";
                  }
                  enum "disable" {
                    tailf:info "Disable logging";
                  }
                }
              }
            }
          }
        }
        leaf router-id {
          tailf:info "Specify the router-id for this OSPF process";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
          }
        }
        container network {
          tailf:info "Network type";
          choice network-choice {
            leaf broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
              type empty;
            }
            leaf non-broadcast {
              tailf:info "Specify OSPF NBMA network";
              type empty;
            }
            container point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence "true";
              leaf non-broadcast {
                tailf:info "Specify OSPF non-broadcast point-to-multipoint network";
                type empty;
              }
            }
            leaf point-to-point {
              tailf:info "Specify OSPF point-to-point network";
              type empty;
            }
          }
        }
        container bfd {
          tailf:info "Configure BFD parameters";
          leaf fast-detect {
            tailf:info "Enable Fast detection";
            tailf:cli-full-command;
            type empty;
          }
          leaf minimum-interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-30000>;;hello interval in milli-seconds";
              range "0..30000";
            }
          }
          leaf multiplier {
            tailf:info "Detect multiplier";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-30>;;Detect multiplier";
            }
          }
        }
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          container traffic-eng {
            tailf:info "Routing protocol commands for MPLS Traffic Engineering";
            container router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              tailf:cli-diff-dependency "../../../../../cisco-ios-xr:interface";
              uses interface-name-grouping;
            }
          }
          container ldp {
            tailf:info "Configure LDP parameters";
            leaf sync {
              tailf:info "Enable LDP IGP synchronization";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        container nsf {
          tailf:info "Enable Cisco Non Stop Forwarding";
          container ietf {
            tailf:info "Enable ietf graceful restart";
            tailf:cli-display-separated;
            presence "true";
            container helper {
              tailf:info "router's helper support level";
              leaf disable {
                tailf:info "router's helper support disabled";
                type empty;
              }
            }
          }
        }
        container timers {
          tailf:info "Adjust routing timers";
          container throttle {
            tailf:info "OSPF throttle timers";
            container lsa {
              tailf:info "LSA throttle timers";
              container all {
                tailf:info "For all types of OSPF LSAs";
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf delay {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<0-600000>;;Delay to generate first occurrence of LSA in milliseconds";
                    range "0..600000";
                  }
                }
                leaf min-delay {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-600000>;;Minimum delay between originating the same LSA in milliseconds";
                    range "1..600000";
                  }
                }
                leaf max-delay {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<1-600000>;;Maximum delay between originating the same LSA in milliseconds";
                    range "1..600000";
                  }
                }
              }
            }
            container spf {
              tailf:info "OSPF SPF throttle timers";
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf delay {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  range "1..600000";
                  tailf:info "<1-600000>;;Delay between receiving a change to SPF calculation in milliseconds";
                }
              }
              leaf min-delay {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  range "1..600000";
                  tailf:info "<1-600000>;;Delay between first and second SPF calculation in milliseconds";
                }
              }
              leaf max-delay {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "1..600000";
                  tailf:info "<1-600000>;;Maximum wait time in milliseconds for SPF calculations";
                }
              }
            }
          }
          container lsa {
            tailf:info "OSPF global LSA timers";
            leaf min-arrival {
              tailf:info "OSPF MinLSArrival timer";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-600000>;;The minimum interval in millisec between accepting the same LSA";
                range "0..600000";
              }
            }
          }
        }
        container spf {
          tailf:info "SPF configuration";
          container prefix-priority {
            tailf:info "Configure SPF prefix priority route policy";
            leaf route-policy {
              tailf:info "Specify the route-policy to prioritize route install";
              type leafref {
                tailf:info "WORD;;Name of the policy";
                path "../../../../../cisco-ios-xr:route-policy/name";
              }
            }
          }
        }
        container auto-cost {
          tailf:info "Calculate OSPF interface cost according to bandwidth";
          leaf reference-bandwidth {
            tailf:info "Specify reference bandwidth for OSPF cost computations";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-4294967>;;The reference bandwidth in terms of Mbits per second";
              range "1..4294967";
            }
          }
        }
        container max-metric {
          tailf:info "Set maximum metric";
          container router-lsa {
            tailf:info "Maximum metric in self-originated router-LSAs";
            tailf:cli-compact-syntax;
            leaf on-startup {
              tailf:info "On startup";
              tailf:cli-optional-in-sequence;
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
                  range "5..86400";
                }
                type enumeration {
                  enum "wait-for-bgp" {
                    tailf:info "Let BGP decide when to originate router-LSA with normal metric";
                  }
                }
              }
            }
            leaf include-stub {
              tailf:info "Set maximum metric for stub links in router-LSAs";
              type empty;
            }
            choice external-lsa-choice {
              container external-lsa-container {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                leaf external-lsa {
                  type uint32 {
                    tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
                    range "1..16777215";
                  }
                }
              }
              leaf external-lsa {
                tailf:info "Override external-lsa metric with max-metric";
                type empty;
              }
            }
            choice summary-lsa-choice {
              container summary-lsa-container {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                leaf summary-lsa {
                  type uint32 {
                    tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
                    range "1..16777215";
                  }
                }
              }
              leaf summary-lsa {
                tailf:info "Override summary-lsa metric with max-metric value";
                type empty;
              }
            }
          }
        }
        list area {
          tailf:info "Enter the OSPF area configuration submode";
          tailf:cli-mode-name "config-ospf-ar";
          key "id";
          leaf id {
            tailf:cli-suppress-range;
            type ospf-area-type;
          }
          uses ospf-area-grouping;
          list interface {
            tailf:info "Enable routing on an interface";
            tailf:cli-mode-name "config-ospf-ar-if";
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            uses ospf-area-grouping;
          }
        }
      }
      container bgp {
        list bgp-no-instance {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-bgp";
          key "id";
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;Autonomous system number";
                range "1..4294967295";
              }
              type string {
                tailf:info "<1.0-XX.YY>;;Autonomous system number";
                pattern "[0-9]+\\.[0-9]+";
              }
            }
          }
          uses router-bgp-grouping;
        }
        list bgp-instance {
          tailf:cli-drop-node-name;
          tailf:info "Border Gateway Protocol (BGP)";
          key "id instance";
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;Autonomous system number";
                range "1..4294967295";
              }
              type string {
                tailf:info "<1.0-XX.YY>;;Autonomous system number";
                pattern "[0-9]+\\.[0-9]+";
              }
            }
          }
          leaf instance {
            tailf:cli-expose-key-name;
            type string;
          }
          uses router-bgp-grouping;
        }
      }
      container mld {
        tailf:info "IPv6 address family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mld";
        list interface {
          tailf:info "MLD interface configuration subcommands";
          tailf:cli-mode-name "config-mld-default-if";
          key "name";
          leaf name {
            type string;
          }
          leaf router {
            tailf:info "Enable/Disable Router side functionality in MLD";
            tailf:cli-full-command;
            type enumeration {
              enum "enable" {
                tailf:info "Enable Router side functionality in MLD";
              }
              enum "disable" {
                tailf:info "Disable Router side functionality in MLD";
              }
            }
          }
        }
        leaf version {
          tailf:info "MLD version";
          type uint8 {
            tailf:info "<1-2>;;version number";
            range "1..2";
          }
        }
      }
      container pim {
        tailf:info "PIM configuration subcommands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim";
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv4 {
            tailf:info "Enter ipv4 Address Family command mode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pim-default-ipv4";
            list rp-address {
              tailf:info "Configure Rendezvous Point";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "name";
              leaf name {
                type inet:host {
                  tailf:info "IP name or address of Rendezvous Point";
                }
              }
              leaf group-access-list {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;Access list of groups that should map to given RP";
                }
              }
              leaf override {
                tailf:info "Static RP config overrides auto-rp and BSR";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf bidir {
                tailf:info "Specify keyword bidir to configure a bidir RP";
                type empty;
              }
            }
            container spt-threshold {
              tailf:info "Configure threshold for switching to SPT on last-hop";
              container infinity {
                tailf:info "Always stay on shared-tree";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence "true";
                leaf group-list {
                  tailf:info "Only stay on the shared-tree for specified groups";
                  type string {
                    tailf:info "WORD;;Access-list of threshold limited groups";
                  }
                }
              }
            }
            container log {
              tailf:info "Enable PIM logging";
              container neighbor {
                tailf:info "Enable PIM neighbor logging";
                leaf changes {
                  tailf:info "Enable PIM neighbor state logging";
                  type empty;
                }
              }
            }
          }
          container ipv6 {
            tailf:info "Enter ipv6 Address Family command mode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mcast-default-ipv6";
            list interface {
              tailf:info "PIM interface configuration subcommands";
              tailf:cli-mode-name "config-pim-ipv6-if";
              key "name";
              leaf name {
                type string;
              }
              leaf enable {
                tailf:info "Enable PIM processing on this interface";
                tailf:cli-full-command;
                type empty;
              }
            }
            leaf neighbor-check-on-recv {
              tailf:info "Check for PIM neighbor before rcv'ing control messages";
              tailf:cli-full-command;
              type enumeration {
                enum "enable" {
                  tailf:info "Enable this feature";
                }
              }
            }
            leaf neighbor-check-on-send {
              tailf:info "Check for PIM neighbor before sending control messages";
              tailf:cli-full-command;
              type enumeration {
                enum "enable" {
                  tailf:info "Enable this feature";
                }
              }
            }
          }
        }
      }
      container vrrp {
        tailf:info "VRRP configuration subcommands";
        tailf:cli-add-mode;
        list interface {
          tailf:cli-mode-name "config-vrrp-if";
          key "name";
          leaf name {
            type string {
              tailf:info "Interface Name";
            }
          }
          container address-family {
            tailf:info "VRRP address family";
            container ipv4 {
              tailf:info "IPv4 address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-vrrp-address-family";
              list vrrp {
                tailf:cli-mode-name "config-vrrp-virtual-router";
                key "id";
                leaf id {
                  type uint8 {
                    tailf:info "<1-255>;;VRID Virtual Router Identifier";
                    range "1..255";
                  }
                }
                leaf priority {
                  tailf:info "Set priority level";
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-254>;;Priority value";
                  }
                }
                container preempt {
                  tailf:info "Preempt Master router if higher priority";
                  choice preempt-choice {
                    leaf delay {
                      tailf:info "Wait before preempting";
                      tailf:cli-optional-in-sequence;
                      type uint16 {
                        tailf:info "<1-3600>;;Number of seconds to delay";
                        range "1..3600";
                      }
                    }
                    leaf disable {
                      tailf:info "Disable preemption";
                      type empty;
                    }
                  }
                }
                container timer {
                  tailf:info "Set advertisement timer";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  choice timer-choice {
                    leaf time-value {
                      tailf:cli-no-keyword;
                      tailf:cli-drop-node-name;
                      type uint8 {
                        tailf:info "<1-255>;;Advertisement time in seconds";
                      }
                    }
                    leaf msec {
                      tailf:info "Configure in milliseconds";
                      tailf:cli-incomplete-command;
                      type uint16 {
                        tailf:info "<100-3000>;;Advertisement time in milliseconds (100-3000)";
                      }
                    }
                  }
                  leaf force {
                    tailf:info "Force the configured values to be used (required for msec)";
                    type empty;
                  }
                }
                list address {
                  tailf:info "Enable VRRP and specify IP address(es)";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "ip";
                  leaf ip {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;VRRP IPv4 address";
                    }
                  }
                  leaf seconday {
                    tailf:info "Set Secondary VRRP IP address";
                    type empty;
                  }
                }
                leaf text-authentication {
                  tailf:info "Set plain text authentication string";
                  type string {
                    tailf:info "WORD;;Authentication password, 8 chars max";
                    length "1..8";
                  }
                }
              }
            }
          }
        }
      }
    }
    container multicast-routing {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mcast";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../cisco-ios-xr:interface";
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "IPv6 Address Family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mcast-default-ipv4";
          list interface {
            tailf:info "Multicast interface configuration subcommands";
            tailf:cli-mode-name "config-mcast-default-ipv4-if";
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            leaf enable {
              tailf:info "Enable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
            leaf boundary {
              tailf:info "Boundary for administratively scoped multicast addresses";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Access list specifying scoped multicast groups";
              }
            }
          }
          leaf nsf {
            tailf:cli-full-command;
            type empty;
          }
          container mdt {
            tailf:info "MVPN configuration";
            container source {
              tailf:info "Interface used to set MDT source address";
              tailf:cli-diff-dependency "../../../../../cisco-ios-xr:interface";
              uses interface-name-grouping;
            }
          }
          container multipath {
            tailf:info "Enable equal-cost multipath routing";
            presence "true";
          }
          container ssm {
            tailf:info "Configure a group range for Source-Specific use";
            leaf range {
              tailf:info "Provide ACL that specifies non-standard SSM range";
              type leafref {
                tailf:info "WORD;;Access list specifying SSM group range";
                path "../../../../../cisco-ios-xr:ipv4/access-list/named-acl/name";
              }
            }
          }
          leaf rate-per-route {
            tailf:info "Enable/disable per (S,G) rate calculation";
            tailf:cli-full-command;
            type empty;
          }
        }
        container ipv6 {
          tailf:info "IPv6 Address Family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pim-default-ipv6";
          list interface {
            tailf:info "Multicast interface configuration subcommands";
            tailf:cli-mode-name "config-mcast-default-ipv6-if";
            key "name";
            leaf name {
              type string {
                tailf:info "Interface Name";
              }
            }
            leaf enable {
              tailf:info "Enable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
          }
          container multipath {
            tailf:info "Enable equal-cost multipath routing";
            presence "true";
          }
        }
      }
    }
  }
  augment /ncs:devices/ncs:template/ncs:config {
    container service {
      container alignment {
        leaf detection {
          type empty;
        }
        leaf logging {
          type empty;
        }
      }
      leaf call-home {
        type empty;
      }
      leaf compress-config {
        type empty;
      }
      container counters {
        container max {
          leaf age {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf dhcp {
        type empty;
      }
      leaf disable-ip-fast-frag {
        type empty;
      }
      leaf exec-callback {
        type empty;
      }
      leaf exec-wait {
        type empty;
      }
      leaf finger {
        type empty;
      }
      container heartbeat {
        leaf fatal-count {
          type string;   // NCS patched all types to string
        }
        leaf interrupt-interval {
          type string;   // NCS patched all types to string
        }
        leaf interrupt-max {
          type string;   // NCS patched all types to string
        }
        leaf transmit-interval {
          type string;   // NCS patched all types to string
        }
        leaf warning-timeout {
          type string;   // NCS patched all types to string
        }
      }
      leaf hide-telnet-addresses {
        type empty;
      }
      leaf linenumber {
        type empty;
      }
      leaf nagle {
        type empty;
      }
      leaf old-slip-prompts {
        type empty;
      }
      container pad {
        presence "true";
        leaf cmns {
          type empty;
        }
        leaf from-xot {
          type empty;
        }
        leaf to-xot {
          type empty;
        }
      }
      leaf password-encryption {
        type empty;
      }
      container prompt {
        leaf config {
          type empty;
        }
      }
      leaf pt-vty-logging {
        type empty;
      }
      leaf sequence-numbers {
        type empty;
      }
      leaf slave-log {
        type empty;
      }
      leaf tcp-keepalives-in {
        type empty;
      }
      leaf tcp-keepalives-out {
        type empty;
      }
      container tcp-small-servers {
        presence "true";
        leaf max-servers {
          type string;   // NCS patched all types to string
        }
      }
      leaf telnet-zeroidle {
        type empty;
      }
      container timestamps {
        presence "true";
        container debug {
          choice log-time-choice {
            container datetime {
              presence "true";
              leaf localtime {
                type empty;
              }
              leaf msec {
                type empty;
              }
              leaf show-timezone {
                type empty;
              }
              leaf year {
                type empty;
              }
            }
            leaf uptime {
              type empty;
            }
          }
        }
        container log {
          choice log-time-choice {
            container datetime {
              presence "true";
              leaf localtime {
                type empty;
              }
              leaf msec {
                type empty;
              }
              leaf show-timezone {
                type empty;
              }
              leaf year {
                type empty;
              }
            }
            leaf uptime {
              type empty;
            }
          }
        }
      }
      container udp-small-servers {
        presence "true";
        leaf max-servers {
          type string;   // NCS patched all types to string
        }
      }
      leaf unsupported-transceiver {
        type empty;
      }
    }
    container configuration {
      container display {
        container interface {
          leaf slot-order {
            type empty;
          }
        }
      }
    }
    leaf hostname {
      type string;   // NCS patched all types to string
    }
    container clock {
      leaf calendar-valid {
        type empty;
      }
      container summer-time {
        leaf zone {
          type string;   // NCS patched all types to string
        }
        choice summer {
          case a {
            container date {
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              type string;   // NCS patched all types to string
            }
            leaf start-day {
              type string;   // NCS patched all types to string
            }
            leaf start-month {
              type string;   // NCS patched all types to string
            }
            leaf start-time {
              type string;   // NCS patched all types to string
            }
            leaf end {
              type string;   // NCS patched all types to string
            }
            leaf end-day {
              type string;   // NCS patched all types to string
            }
            leaf end-month {
              type string;   // NCS patched all types to string
            }
            leaf end-time {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container timezone {
        leaf zone {
          type string;   // NCS patched all types to string
        }
        leaf offset {
          type string;   // NCS patched all types to string
        }
      }
    }
    container banner {
      presence "In NCS this element is now optional";
      container login {
        leaf start-marker {
          type string;   // NCS patched all types to string
        }
        leaf message {
          type string;   // NCS patched all types to string
        }
        leaf end-marker {
          type string;   // NCS patched all types to string
          // NCS drop path statement here
        }
      }
    }
    container exception {
      container exception-filepath {
        leaf choice {
          type string;   // NCS patched all types to string
        }
        leaf compress {
          type string;   // NCS patched all types to string
        }
        container filename {
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf limit {
            type string;   // NCS patched all types to string
          }
        }
        leaf filepath {
          type string;   // NCS patched all types to string
        }
      }
      leaf sparse {
        type string;   // NCS patched all types to string
      }
      leaf sprsize {
        type string;   // NCS patched all types to string
      }
      leaf coresize {
        type string;   // NCS patched all types to string
      }
    }
    container vrf {
      list vrf-list {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf description {
          type string;   // NCS patched all types to string
        }
        leaf rd {
          type string;   // NCS patched all types to string
        }
        container address-family {
          container ipv4 {
            container unicast {
              presence "true";
              container import {
                container route-target {
                  uses template_ncs_vrf-route-target-grouping;
                }
              }
              container export {
                container route-target {
                  uses template_ncs_vrf-route-target-grouping;
                }
              }
              container maximum {
                container prefix {
                  leaf limit {
                    type string;   // NCS patched all types to string
                  }
                  leaf mid-thresh {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
          container ipv6 {
            container unicast {
              presence "true";
              container import {
                container route-target {
                  uses template_ncs_vrf-route-target-grouping;
                }
              }
              container export {
                container route-target {
                  uses template_ncs_vrf-route-target-grouping;
                }
              }
              container maximum {
                container prefix {
                  leaf limit {
                    type string;   // NCS patched all types to string
                  }
                  leaf mid-thresh {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
        }
      }
    }
    container logging {
      container buffered {
        leaf type {
          type string;   // NCS patched all types to string
        }
      }
      container cns-events {
        presence "true";
        leaf severity {
          type string;   // NCS patched all types to string
        }
      }
      leaf console {
        type string;   // NCS patched all types to string
      }
      leaf count {
        type empty;
      }
      container events {
        leaf level {
          type string;   // NCS patched all types to string
        }
        leaf link-status {
          type string;   // NCS patched all types to string
        }
      }
      leaf facility {
        type string;   // NCS patched all types to string
      }
      leaf history {
        type string;   // NCS patched all types to string
      }
      leaf monitor {
        type string;   // NCS patched all types to string
      }
      container persistent {
        presence "true";
        leaf url {
          type string;   // NCS patched all types to string
        }
        leaf size {
          type string;   // NCS patched all types to string
        }
        leaf filesize {
          type string;   // NCS patched all types to string
        }
        leaf batch {
          type string;   // NCS patched all types to string
        }
      }
      container source-interface {
        uses template_ncs_interface-name-grouping;
      }
      container suppress {
        leaf duplicates {
          type empty;
        }
        list rule {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          list alarm {
            ordered-by "user";  // NCS patched to keep predictable order
            key "msg-category group-name msg-code";
            leaf msg-category {
              type string;   // NCS patched all types to string
            }
            leaf group-name {
              type string;   // NCS patched all types to string
            }
            leaf msg-code {
              type string;   // NCS patched all types to string
            }
          }
        }
        container apply {
          list rule {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf all-of-router {
              type empty;
            }
          }
        }
      }
      leaf trap {
        type string;   // NCS patched all types to string
      }
      leaf hostnameprefix {
        type string;   // NCS patched all types to string
      }
      list host {
        ordered-by "user";  // NCS patched to keep predictable order
        key "address";
        leaf address {
          type string;   // NCS patched all types to string
        }
        leaf vrf {
          type string;   // NCS patched all types to string
        }
        leaf severity {
          type string;   // NCS patched all types to string
        }
      }
    }
    container event {
      container manager {
        container directory {
          container user {
            choice emdu-choice {
              leaf policy {
                type string;   // NCS patched all types to string
              }
              leaf library {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        list policy {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf username {
            type string;   // NCS patched all types to string
          }
          leaf persist-time {
            type string;   // NCS patched all types to string
          }
          leaf type {
            type string;   // NCS patched all types to string
          }
        }
        list environment {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf var-value {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container domain {
      container ipv6 {
        list host {
          ordered-by "user";  // NCS patched to keep predictable order
          key "host-name";
          leaf host-name {
            type string;   // NCS patched all types to string
          }
          leaf-list address {
            ordered-by "user";  // NCS patched to keep predictable order
            // NCS drop  (ordered-by) statement
            max-elements "4";
            type string;   // NCS patched all types to string
          }
        }
      }
      container lookup {
        leaf disable {
          type empty;
        }
        container source-interface {
          uses template_ncs_interface-name-grouping;
        }
      }
      leaf name {
        type string;   // NCS patched all types to string
      }
      list name-server {
        ordered-by "user";  // NCS patched to keep predictable order
        // NCS drop  (ordered-by) statement
        key "address";
        leaf address {
          type string;   // NCS patched all types to string
        }
      }
      list vrf {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
        container lookup {
          leaf disable {
            type empty;
          }
        }
      }
    }
    list taskgroup {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      container task {
        list execute {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
        list read {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
      }
      container inherit {
        list taskgroup {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf description {
        type string;   // NCS patched all types to string
      }
    }
    list usergroup {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf-list taskgroup {
        ordered-by "user";  // NCS patched to keep predictable order
        type string;   // NCS patched all types to string
      }
    }
    container cdp {
      presence "true";
      leaf timer {
        type string;   // NCS patched all types to string
      }
    }
    container netconf {
      container agent {
        container tty {
          container session {
            leaf timeout {
              type string;   // NCS patched all types to string
            }
          }
          container throttle {
            leaf memory {
              type string;   // NCS patched all types to string
            }
            leaf process-rate {
              type string;   // NCS patched all types to string
            }
          }
        }
        leaf ssh {
          type empty;
        }
      }
    }
    container nsr {
      leaf process-failures {
        type string;   // NCS patched all types to string
      }
    }
    container ftp {
      container client {
        leaf passive {
          type empty;
        }
        container source-interface {
          uses template_ncs_interface-name-grouping;
        }
      }
    }
    container icmp {
      container ipv4 {
        container source {
          leaf rfc {
            type empty;
          }
          leaf vrf {
            type empty;
          }
        }
      }
    }
    container ntp {
      leaf max-associations {
        type string;   // NCS patched all types to string
      }
      list server {
        ordered-by "user";  // NCS patched to keep predictable order
        key "address";
        leaf address {
          type string;   // NCS patched all types to string
        }
        leaf vrf {
          type string;   // NCS patched all types to string
        }
        leaf ip-version {
          type string;   // NCS patched all types to string
        }
        leaf version {
          type string;   // NCS patched all types to string
        }
        container source {
          uses template_ncs_interface-name-grouping;
        }
      }
      list access-group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "type name";
        leaf type {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf vrf {
          type string;   // NCS patched all types to string
        }
        leaf version {
          type string;   // NCS patched all types to string
        }
      }
      leaf master {
        type string;   // NCS patched all types to string
      }
      container source {
        uses template_ncs_interface-name-grouping;
      }
      leaf update-calendar {
        type empty;
      }
    }
    list alias {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf line {
        type string;   // NCS patched all types to string
      }
    }
    container bfd {
      container echo {
        leaf disable {
          type empty;
        }
      }
      container trap {
        container singlehop {
          leaf pre-mapped {
            type empty;
          }
        }
      }
    }
    container tftp {
      container client {
        container source-interface {
          uses template_ncs_interface-name-grouping;
        }
      }
      uses template_ncs_tftp-server-grouping;
      list vrf {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_tftp-server-grouping;
      }
    }
    container nv {
      container optical {
        list satellite {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          container ipv6 {
            leaf address {
              type string;   // NCS patched all types to string
            }
          }
          leaf username {
            type string;   // NCS patched all types to string
          }
          leaf password {
            type string;   // NCS patched all types to string
          }
          container trunk {
            list slot {
              ordered-by "user";  // NCS patched to keep predictable order
              key "slot-number";
              leaf slot-number {
                type string;   // NCS patched all types to string
              }
              leaf port {
                type string;   // NCS patched all types to string
              }
              leaf local-port {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      container controller {
        list dwdm {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf admin-state {
            type string;   // NCS patched all types to string
          }
          leaf description {
            type string;   // NCS patched all types to string
          }
          container g709 {
            leaf fec {
              type string;   // NCS patched all types to string
            }
          }
          container proactive {
            container revert {
              container threshold {
                leaf x-coefficient {
                  type string;   // NCS patched all types to string
                }
                leaf y-power {
                  type string;   // NCS patched all types to string
                }
              }
              leaf window {
                type string;   // NCS patched all types to string
              }
            }
            container trigger {
              container threshold {
                leaf x-coefficient {
                  type string;   // NCS patched all types to string
                }
                leaf y-power {
                  type string;   // NCS patched all types to string
                }
              }
              leaf window {
                type string;   // NCS patched all types to string
              }
            }
          }
          leaf transmit-power {
            type string;   // NCS patched all types to string
          }
          leaf transmit-shutdown {
            type empty;
          }
          container wavelength {
            leaf channel-number {
              type string;   // NCS patched all types to string
            }
            leaf frequency {
              type string;   // NCS patched all types to string
            }
            leaf update {
              type string;   // NCS patched all types to string
            }
          }
        }
        list HundredGigE {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf admin-state {
            type string;   // NCS patched all types to string
          }
        }
      }
      list satellite {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf type {
          type string;   // NCS patched all types to string
        }
        container ipv4 {
          leaf address {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container tcp {
      leaf mss {
        type string;   // NCS patched all types to string
      }
      container path-mtu-discovery {
        presence "true";
        leaf age-timer {
          type string;   // NCS patched all types to string
        }
      }
      container directory {
        leaf directory {
          type string;   // NCS patched all types to string
        }
        leaf files {
          type string;   // NCS patched all types to string
        }
        leaf size {
          type string;   // NCS patched all types to string
        }
      }
    }
    container enable {
      container password {
      }
      container secret {
        leaf type {
          type string;   // NCS patched all types to string
        }
        leaf secret {
          type string;   // NCS patched all types to string
        }
      }
    }
    list username {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      list group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
      container password {
        leaf encryption {
          type string;   // NCS patched all types to string
        }
        leaf password {
          type string;   // NCS patched all types to string
        }
      }
      leaf privilege {
        type string;   // NCS patched all types to string
      }
      container secret {
        leaf encryption {
          type string;   // NCS patched all types to string
        }
        leaf password {
          type string;   // NCS patched all types to string
        }
      }
    }
    container tacacs-server {
      list host {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name port";
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf port {
          type string;   // NCS patched all types to string
        }
        container key {
          leaf encryption {
            type string;   // NCS patched all types to string
          }
          leaf key {
            type string;   // NCS patched all types to string
          }
        }
      }
      container key {
        leaf encryption {
          type string;   // NCS patched all types to string
        }
        leaf key {
          type string;   // NCS patched all types to string
        }
      }
      leaf timeout {
        type string;   // NCS patched all types to string
      }
    }
    container tacacs {
      container source-interface {
        uses template_ncs_interface-name-grouping;
        leaf vrf {
          type string;   // NCS patched all types to string
        }
      }
    }
    container aaa {
      leaf new-model {
        type empty;
      }
      container group {
        container server {
          list radius {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            container server {
              list name {
                ordered-by "user";  // NCS patched to keep predictable order
                key "name";
                leaf name {
                  type string;   // NCS patched all types to string
                }
              }
              list direct {
                ordered-by "user";  // NCS patched to keep predictable order
                key "name";
                leaf name {
                  type string;   // NCS patched all types to string
                }
                leaf auth-port {
                  type string;   // NCS patched all types to string
                }
                leaf acct-port {
                  type string;   // NCS patched all types to string
                }
              }
            }
            container ip {
              container vrf {
                leaf forwarding {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
          list tacacs {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf-list server {
              ordered-by "user";  // NCS patched to keep predictable order
              type string;   // NCS patched all types to string
            }
            leaf vrf {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container authentication {
        list login {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf local {
            type empty;
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf none {
            type empty;
          }
        }
      }
      container authorization {
        list commands {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
        list exec {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
        list eventmanager {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
      }
      container accounting {
        list exec {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf notice {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf none {
            type empty;
          }
        }
        list system {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf start-stop {
            type empty;
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf none {
            type empty;
          }
        }
        list network {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf notice {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf none {
            type empty;
          }
        }
        list commands {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf notice {
            type string;   // NCS patched all types to string
          }
          leaf group {
            type string;   // NCS patched all types to string
          }
          leaf none {
            type empty;
          }
        }
      }
      leaf session-id {
        type string;   // NCS patched all types to string
      }
      leaf default-taskgroup {
        type string;   // NCS patched all types to string
      }
    }
    container aps {
      list group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        container timers {
          leaf hello {
            type string;   // NCS patched all types to string
          }
          leaf hold {
            type string;   // NCS patched all types to string
          }
        }
        list channel {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id location";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf location {
            type string;   // NCS patched all types to string
          }
          leaf preconfigure {
            type empty;
          }
          leaf sonet {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container platform {
      container ip {
        container cef {
          leaf load-sharing {
            type string;   // NCS patched all types to string
          }
        }
      }
      container qos {
        leaf qos-10g-only {
          type empty;
        }
        list protocol {
          ordered-by "user";  // NCS patched to keep predictable order
          key "proto";
          leaf proto {
            type string;   // NCS patched all types to string
          }
          choice proto-choice {
            leaf pass-through {
              type empty;
            }
            container police {
              leaf bit-rate {
                type string;   // NCS patched all types to string
              }
              leaf burst {
                type string;   // NCS patched all types to string
              }
            }
            container precedence {
              leaf cos {
                type string;   // NCS patched all types to string
              }
              leaf bit-rate {
                type string;   // NCS patched all types to string
              }
              leaf burst {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
    }
    container ip {
      container domain-lookup {
        leaf do-lookup {
          type string;   // NCS patched all types to string
          // NCS drop  (default) statement
        }
        leaf nsap {
          type empty;
        }
      }
      leaf domain-name {
        type string;   // NCS patched all types to string
      }
      container forward-protocol {
        leaf nd {
          type empty;
        }
        leaf sdns {
          type empty;
        }
        leaf spanning-tree {
          type empty;
        }
        leaf turbo-flood {
          type empty;
        }
        leaf udp {
          type empty;
        }
      }
      container http {
        leaf server {
          type string;   // NCS patched all types to string
          // NCS drop  (default) statement
        }
        leaf secure-server {
          type string;   // NCS patched all types to string
          // NCS drop  (default) statement
        }
      }
      container pim {
        container ssm {
          choice ssm-choice {
            leaf default {
              type empty;
            }
            leaf range {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container route {
        container vrf {
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf dest {
            type string;   // NCS patched all types to string
          }
          leaf dest-mask {
            type string;   // NCS patched all types to string
          }
          choice vrf-choice {
            leaf forwarding-address {
              type string;   // NCS patched all types to string
            }
            leaf GigabitEthernet {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container multicast-routing {
        presence "true";
        leaf-list vrf {
          ordered-by "user";  // NCS patched to keep predictable order
          type string;   // NCS patched all types to string
        }
      }
      container multicast {
        list vrf {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          container route-limit {
            leaf nr-routes {
              type string;   // NCS patched all types to string
            }
            leaf threshold {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container tftp {
        container source-interface {
          uses template_ncs_interface-name-grouping;
        }
      }
      container ssh {
        leaf logging {
          type string;   // NCS patched all types to string
        }
        leaf version {
          type string;   // NCS patched all types to string
        }
      }
    }
    container ipv4 {
      container access-list {
        list named-acl {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          list rule {
            ordered-by "user";  // NCS patched to keep predictable order
            key "id";
            leaf id {
              type string;   // NCS patched all types to string
            }
            leaf line {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container unnumbered {
        container mpls {
          container traffic-eng {
            uses template_ncs_interface-name-grouping;
          }
        }
      }
      container virtual {
        container address-src {
          container address {
            leaf use-as-src-addr {
              type empty;
            }
          }
        }
        container address {
          list address-list {
            ordered-by "user";  // NCS patched to keep predictable order
            key "address mask";
            leaf address {
              type string;   // NCS patched all types to string
            }
            leaf mask {
              type string;   // NCS patched all types to string
            }
          }
          list vrf {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            list address-list {
              ordered-by "user";  // NCS patched to keep predictable order
              key "address mask";
              leaf address {
                type string;   // NCS patched all types to string
              }
              leaf mask {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      leaf conflict-policy {
        type string;   // NCS patched all types to string
      }
    }
    container ipv6 {
      container access-list {
        list named-acl {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          list rule {
            ordered-by "user";  // NCS patched to keep predictable order
            key "id";
            leaf id {
              type string;   // NCS patched all types to string
            }
            leaf line {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container multicast {
        container rpf {
          container backoff {
            leaf initial {
              type string;   // NCS patched all types to string
            }
            leaf max-backoff-delay {
              type string;   // NCS patched all types to string
            }
          }
          leaf use-bgp {
            type empty;
          }
        }
      }
      leaf unicast-routing {
        type empty;
      }
    }
    container frequency {
      container synchronization {
        container quality {
          container itu-t {
            leaf option {
              type string;   // NCS patched all types to string
            }
            leaf generation {
              // NCS drop path statement here
              type string;   // NCS patched all types to string
            }
          }
        }
        container clock-interface {
          leaf timing-mode {
            type string;   // NCS patched all types to string
          }
        }
        container system {
          leaf timing-mode {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container error-disable {
      container recovery {
        container cause {
          container udld-timeout {
            presence "true";
            leaf interval {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
    }
    container vtp {
      leaf mode {
        type string;   // NCS patched all types to string
      }
    }
    container vty-pool {
      container default {
        uses template_ncs_vty-pool-grouping;
      }
      container eem {
        uses template_ncs_vty-pool-grouping;
      }
      list pool-name-list {
        ordered-by "user";  // NCS patched to keep predictable order
        key "pool-name";
        leaf pool-name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_vty-pool-grouping;
      }
    }
    container arp {
      uses template_ncs_arp-grouping;
      list vrf {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_arp-grouping;
      }
    }
    container telnet {
      container ipv4 {
        container client {
          container source-interface {
            uses template_ncs_interface-name-grouping;
          }
        }
      }
      uses template_ncs_telnet-server-grouping;
      list vrf {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_telnet-server-grouping;
      }
    }
    container cinetd {
      leaf rate-limit {
        type string;   // NCS patched all types to string
      }
    }
    container xxml {
      container tty-agent {
        container agent {
          container tty {
            container iteration {
              leaf off {
                type empty;
              }
            }
            leaf ipv4 {
              type string;   // NCS patched all types to string
            }
            leaf ipv6 {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container other-agent {
        container agent {
          leaf ipv4 {
            type string;   // NCS patched all types to string
          }
          leaf ipv6 {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container switch {
      container virtual {
        list domain {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf mac-address {
            type string;   // NCS patched all types to string
          }
          container switch {
            leaf mode {
              type string;   // NCS patched all types to string
            }
            list nr {
              ordered-by "user";  // NCS patched to keep predictable order
              key "id";
              leaf id {
                type string;   // NCS patched all types to string
              }
              leaf location {
                type string;   // NCS patched all types to string
              }
              leaf priority {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
    }
    container mpls {
      container label {
        leaf protocol {
          type string;   // NCS patched all types to string
        }
        container range {
          leaf min {
            type string;   // NCS patched all types to string
          }
          leaf max {
            type string;   // NCS patched all types to string
          }
        }
      }
      container ldp {
        leaf router-id {
          type string;   // NCS patched all types to string
        }
        container discovery {
          container instance-tlv {
            leaf disable {
              type empty;
            }
          }
          container hello {
            leaf holdtime {
              type string;   // NCS patched all types to string
            }
            leaf interval {
              type string;   // NCS patched all types to string
            }
          }
          container targeted-hello {
            container accept {
              presence "true";
              leaf from {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        container igp {
          container sync {
            container delay {
              leaf delay-value {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        leaf nsr {
          type empty;
        }
        container graceful-restart {
          presence "true";
        }
        container password {
          container option {
            leaf sequence-nr {
              type string;   // NCS patched all types to string
            }
            leaf for {
              type string;   // NCS patched all types to string
            }
            leaf enc-type {
              type string;   // NCS patched all types to string
            }
            leaf password {
              type string;   // NCS patched all types to string
            }
          }
          container required {
            presence "true";
            leaf for {
              type string;   // NCS patched all types to string
            }
          }
        }
        container label {
          container allocate {
            leaf for {
              type string;   // NCS patched all types to string
            }
          }
          container advertise {
            leaf disable {
              type empty;
            }
            leaf for {
              type string;   // NCS patched all types to string
            }
          }
        }
        container log {
          leaf neighbor {
            type empty;
          }
          leaf nsr {
            type empty;
          }
        }
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
      }
      container oam {
        container echo {
          leaf disable-vendor-extension {
            type empty;
          }
        }
      }
      container static {
        list ipv4 {
          ordered-by "user";  // NCS patched to keep predictable order
          key "address mask interface";
          leaf address {
            type string;   // NCS patched all types to string
          }
          leaf mask {
            type string;   // NCS patched all types to string
          }
          leaf interface {
            type string;   // NCS patched all types to string
          }
          leaf label {
            type string;   // NCS patched all types to string
          }
        }
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
        container address-family {
          list ipv4 {
            ordered-by "user";  // NCS patched to keep predictable order
            key "af-modifier";
            leaf af-modifier {
              type string;   // NCS patched all types to string
            }
            list local-label {
              ordered-by "user";  // NCS patched to keep predictable order
              key "id";
              leaf id {
                type string;   // NCS patched all types to string
              }
              leaf allocate {
                type empty;
              }
              leaf per-prefix {
                type string;   // NCS patched all types to string
              }
              container forward {
                list path {
                  ordered-by "user";  // NCS patched to keep predictable order
                  key "id";
                  leaf id {
                    type string;   // NCS patched all types to string
                  }
                  leaf nexthop {
                    type string;   // NCS patched all types to string
                  }
                  leaf nexthop-address {
                    type string;   // NCS patched all types to string
                  }
                  leaf out-label {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
        }
        list vrf {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          container address-family {
            list ipv4 {
              ordered-by "user";  // NCS patched to keep predictable order
              key "af-modifier";
              leaf af-modifier {
                type string;   // NCS patched all types to string
              }
              list local-label {
                ordered-by "user";  // NCS patched to keep predictable order
                key "id";
                leaf id {
                  type string;   // NCS patched all types to string
                }
                leaf allocate {
                  type empty;
                }
                choice allocate-choice {
                  leaf per-prefix {
                    type string;   // NCS patched all types to string
                  }
                  leaf per-vrf {
                    type empty;
                  }
                }
                container forward {
                  // NCS drop path statement here
                  list path {
                    ordered-by "user";  // NCS patched to keep predictable order
                    key "id";
                    leaf id {
                      type string;   // NCS patched all types to string
                    }
                    leaf pop-and-lookup {
                      type empty;
                    }
                  }
                }
              }
            }
          }
        }
      }
      container traffic-eng {
        container auto-tunnel {
          container backup {
            container timers {
              container removal {
                leaf unused {
                  type string;   // NCS patched all types to string
                }
              }
            }
            container tunnel-id {
              leaf min {
                type string;   // NCS patched all types to string
              }
              leaf max {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          container bfd {
            leaf fast-detect {
              type empty;
            }
          }
          container auto-tunnel {
            container backup {
              presence "true";
              container exclude {
                container srlg {
                  presence "true";
                  leaf preferred {
                    type empty;
                  }
                }
              }
            }
          }
        }
        container logging {
          container events {
            leaf frr-protection {
              type empty;
            }
            leaf preemption {
              type empty;
            }
          }
        }
        container soft-preemption {
          leaf timeout {
            type string;   // NCS patched all types to string
          }
        }
        container auto-bw {
          container collect {
            leaf frequency {
              type string;   // NCS patched all types to string
            }
          }
        }
        container reoptimize {
          leaf value {
            type string;   // NCS patched all types to string
          }
          container timers {
            container delay {
              leaf cleanup {
                type string;   // NCS patched all types to string
              }
              leaf installation {
                type string;   // NCS patched all types to string
              }
              leaf path-protection {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        container bfd {
          leaf multiplier {
            type string;   // NCS patched all types to string
          }
          leaf minimum-interval {
            type string;   // NCS patched all types to string
          }
        }
        container fast-reroute {
          container timers {
            leaf promotion {
              type string;   // NCS patched all types to string
            }
          }
        }
        container link-management {
          container timers {
            container preemption-delay {
              leaf bundle-capacity {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      container ip-ttl-propagate {
        container disable {
          presence "true";
          leaf disable-type {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container rsvp {
      list interface {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        container bandwidth {
          presence "true";
        }
      }
      container signalling {
        container graceful-restart {
          presence "true";
        }
      }
    }
    container key {
      list chain {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        list key {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          container accept-lifetime {
            leaf local {
              type empty;
            }
            leaf start-time {
              type string;   // NCS patched all types to string
            }
            leaf start-month {
              type string;   // NCS patched all types to string
            }
            leaf start-day {
              type string;   // NCS patched all types to string
            }
            leaf start-year {
              type string;   // NCS patched all types to string
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  type string;   // NCS patched all types to string
                }
              }
              case stop-time {
                leaf stop-time {
                  type string;   // NCS patched all types to string
                }
                leaf stop-month {
                  type string;   // NCS patched all types to string
                }
                leaf stop-day {
                  type string;   // NCS patched all types to string
                }
                leaf stop-year {
                  type string;   // NCS patched all types to string
                }
              }
              case infinite {
                leaf infinite {
                  type empty;
                }
              }
            }
          }
          container key-string {
            leaf password {
              type string;   // NCS patched all types to string
            }
          }
          container send-lifetime {
            leaf local {
              type empty;
            }
            leaf start-time {
              type string;   // NCS patched all types to string
            }
            leaf start-month {
              type string;   // NCS patched all types to string
            }
            leaf start-day {
              type string;   // NCS patched all types to string
            }
            leaf start-year {
              type string;   // NCS patched all types to string
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  type string;   // NCS patched all types to string
                }
              }
              case stop-time {
                leaf stop-time {
                  type string;   // NCS patched all types to string
                }
                leaf stop-month {
                  type string;   // NCS patched all types to string
                }
                leaf stop-day {
                  type string;   // NCS patched all types to string
                }
                leaf stop-year {
                  type string;   // NCS patched all types to string
                }
              }
              case infinite {
                leaf infinite {
                  type empty;
                }
              }
            }
          }
          leaf cryptographic-algorithm {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container control-plane {
      container management-plane {
        container inband {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            list allow {
              ordered-by "user";  // NCS patched to keep predictable order
              key "proto";
              leaf proto {
                type string;   // NCS patched all types to string
              }
              leaf peer {
                type empty;
              }
              container address {
                list ipv6 {
                  ordered-by "user";  // NCS patched to keep predictable order
                  key "prefix";
                  leaf prefix {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
        }
        container out-of-band {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            list allow {
              ordered-by "user";  // NCS patched to keep predictable order
              key "proto";
              leaf proto {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
    }
    container dhcp {
      container ipv6 {
        container interface-old {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "ifname type";
            leaf ifname {
              type string;   // NCS patched all types to string
            }
            leaf type {
              type string;   // NCS patched all types to string
            }
            leaf profile {
              type string;   // NCS patched all types to string
            }
            leaf destination {
              type string;   // NCS patched all types to string
            }
          }
        }
        container interface {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name type";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf type {
              type string;   // NCS patched all types to string
            }
            leaf profile {
              type string;   // NCS patched all types to string
            }
            leaf destination {
              type string;   // NCS patched all types to string
            }
          }
        }
        list profile {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name type";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf type {
            type string;   // NCS patched all types to string
          }
          list helper-address {
            ordered-by "user";  // NCS patched to keep predictable order
            key "address";
            leaf address {
              type string;   // NCS patched all types to string
            }
            leaf vrf {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
    }
    container diagnostic {
      container bootup {
        leaf level {
          type string;   // NCS patched all types to string
        }
      }
    }
    container snmp-server {
      container mroutemib {
        leaf send-all-vrf {
          type empty;
        }
      }
      container mibs {
        container cbqosmib {
          container cache {
            container refresh {
              leaf time {
                type string;   // NCS patched all types to string
              }
            }
            container service-policy {
              leaf count {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      list community {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf view {
          type string;   // NCS patched all types to string
        }
        choice access-choice {
          leaf RO {
            type empty;
          }
          leaf RW {
            type empty;
          }
        }
        leaf access-list {
          type string;   // NCS patched all types to string
        }
      }
      leaf contact {
        type string;   // NCS patched all types to string
      }
      list host {
        ordered-by "user";  // NCS patched to keep predictable order
        key "address";
        leaf address {
          type string;   // NCS patched all types to string
        }
        leaf informs {
          type empty;
        }
        leaf traps {
          type empty;
        }
        leaf version {
          type string;   // NCS patched all types to string
        }
        leaf security-level {
          // NCS drop path statement here
          type string;   // NCS patched all types to string
        }
        leaf enc {
          type string;   // NCS patched all types to string
        }
        leaf community-string {
          // NCS drop  (mandatory) statement
          type string;   // NCS patched all types to string
        }
        leaf udp-port {
          type string;   // NCS patched all types to string
        }
      }
      leaf ifindex {
        type string;   // NCS patched all types to string
      }
      container ifmib {
        container ifalias {
          leaf long {
            type empty;
          }
        }
        container stats {
          leaf cache {
            type empty;
          }
        }
      }
      leaf location {
        type string;   // NCS patched all types to string
      }
      container trap {
        leaf link {
          type string;   // NCS patched all types to string
        }
      }
      list user {
        ordered-by "user";  // NCS patched to keep predictable order
        key "username";
        leaf username {
          type string;   // NCS patched all types to string
        }
        leaf groupname {
          // NCS drop  (mandatory) statement
          type string;   // NCS patched all types to string
        }
        leaf options {
          type string;   // NCS patched all types to string
        }
      }
      list view {
        ordered-by "user";  // NCS patched to keep predictable order
        key "view-name";
        leaf view-name {
          type string;   // NCS patched all types to string
        }
        list oid-list {
          ordered-by "user";  // NCS patched to keep predictable order
          key "oid-tree";
          leaf oid-tree {
            type string;   // NCS patched all types to string
          }
          leaf viewmode {
            type string;   // NCS patched all types to string
          }
        }
      }
      list group {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        choice version-choice {
          leaf v1 {
            type empty;
          }
          leaf v2c {
            type empty;
          }
          leaf v3 {
            type string;   // NCS patched all types to string
          }
        }
        leaf read {
          type string;   // NCS patched all types to string
        }
        leaf write {
          type string;   // NCS patched all types to string
        }
        leaf notify {
          type string;   // NCS patched all types to string
        }
        leaf context {
          type string;   // NCS patched all types to string
        }
        leaf access-list {
          type string;   // NCS patched all types to string
        }
      }
      container traps {
        leaf bfd {
          type empty;
        }
        container bgp {
          presence "true";
          leaf cbgp2 {
            type empty;
          }
        }
        leaf bridgemib {
          type empty;
        }
        leaf config {
          type empty;
        }
        leaf copy-complete {
          type empty;
        }
        leaf ds3 {
          type empty;
        }
        leaf entity {
          type empty;
        }
        container entity-state {
          leaf operstatus {
            type empty;
          }
          leaf switchover {
            type empty;
          }
        }
        container entity-redundancy {
          leaf all {
            type empty;
          }
        }
        container ethernet {
          leaf cfm {
            type empty;
          }
          leaf oam {
            type string;   // NCS patched all types to string
          }
        }
        container flash {
          leaf insertion {
            type empty;
          }
          leaf removal {
            type empty;
          }
        }
        leaf fru-ctrl {
          type empty;
        }
        container ipsec {
          container tunnel {
            leaf stop {
              type empty;
            }
            leaf start {
              type empty;
            }
          }
        }
        container isakmp {
          container tunnel {
            leaf stop {
              type empty;
            }
            leaf start {
              type empty;
            }
          }
        }
        container mpls {
          container frr {
            leaf all {
              type empty;
            }
            leaf protected {
              type empty;
            }
            leaf unprotected {
              type empty;
            }
          }
          container ldp {
            leaf down {
              type empty;
            }
            leaf threshold {
              type empty;
            }
            leaf up {
              type empty;
            }
          }
          container l3vpn {
            leaf all {
              type empty;
            }
            leaf vrf-up {
              type empty;
            }
            leaf vrf-down {
              type empty;
            }
            leaf max-threshold-cleared {
              type empty;
            }
            leaf max-threshold-exceeded {
              type empty;
            }
            leaf mid-threshold-exceeded {
              type empty;
            }
            leaf max-threshold-reissue-notif-time {
              type string;   // NCS patched all types to string
            }
          }
          container traffic-eng {
            leaf up {
              type empty;
            }
            leaf down {
              type empty;
            }
            container p2mp {
              leaf down {
                type empty;
              }
              leaf up {
                type empty;
              }
            }
            leaf reroute {
              type empty;
            }
            leaf reoptimize {
              type empty;
            }
          }
        }
        container msdp {
          leaf peer-state-change {
            type empty;
          }
        }
        leaf ntp {
          type empty;
        }
        container ospf {
          container state-change {
            leaf neighbor-state-change {
              type empty;
            }
          }
        }
        leaf otn {
          type empty;
        }
        container pim {
          leaf interface-state-change {
            type empty;
          }
          leaf invalid-message-received {
            type empty;
          }
          leaf neighbor-change {
            type empty;
          }
          leaf rp-mapping-change {
            type empty;
          }
        }
        leaf rf {
          type empty;
        }
        container rsvp {
          leaf all {
            type empty;
          }
          leaf new-flow {
            type empty;
          }
          leaf lost-flow {
            type empty;
          }
        }
        leaf sensor {
          type empty;
        }
        container snmp {
          presence "true";
          leaf coldstart {
            type empty;
          }
          leaf linkup {
            type empty;
          }
          leaf linkdown {
            type empty;
          }
          leaf warmstart {
            type empty;
          }
          leaf authentication {
            type empty;
          }
        }
        leaf system {
          type empty;
        }
      }
      container trap-source {
        uses template_ncs_interface-name-grouping;
      }
      container interface {
        list subset {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf regular-expression {
            type string;   // NCS patched all types to string
          }
          leaf notification {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf queue-length {
        type string;   // NCS patched all types to string
      }
    }
    container srlg {
      presence "true";
    }
    list monitor-session {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      container destination {
        choice destination-choice {
          leaf pseudowire {
            type empty;
          }
          container interface {
            uses template_ncs_interface-name-grouping;
          }
        }
      }
    }
    container spanning-tree {
      container extend {
        leaf system-id {
          type empty;
        }
      }
      leaf mode {
        type string;   // NCS patched all types to string
      }
      container mst {
        list range {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf priority {
            type string;   // NCS patched all types to string
          }
        }
        container configuration {
          leaf name {
            type string;   // NCS patched all types to string
          }
        }
      }
      leaf portfast {
        type string;   // NCS patched all types to string
      }
      list mstag {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "ifname";
          leaf ifname {
            type string;   // NCS patched all types to string
          }
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf port-id {
            type string;   // NCS patched all types to string
          }
          leaf bridge-id {
            type string;   // NCS patched all types to string
          }
          list instance {
            ordered-by "user";  // NCS patched to keep predictable order
            key "id";
            leaf id {
              type string;   // NCS patched all types to string
            }
            container cost {
              leaf cost-value {
                type string;   // NCS patched all types to string
              }
              leaf startup-value {
                type string;   // NCS patched all types to string
              }
            }
            leaf-list vlan-ids {
              ordered-by "user";  // NCS patched to keep predictable order
              type string;   // NCS patched all types to string
            }
            container root-id {
              leaf root-id-value {
                type string;   // NCS patched all types to string
              }
              leaf startup-value {
                type string;   // NCS patched all types to string
              }
            }
            container priority {
              leaf priority-value {
                type string;   // NCS patched all types to string
              }
              leaf startup-value {
                type string;   // NCS patched all types to string
              }
            }
            container root-priority {
              leaf priority-value {
                type string;   // NCS patched all types to string
              }
              leaf startup-value {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      list repag {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "ifname";
          leaf ifname {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container redundancy {
      container iccp {
        list group {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          container mlacp {
            leaf node {
              type string;   // NCS patched all types to string
            }
            container system {
              leaf mac {
                type string;   // NCS patched all types to string
              }
              leaf priority {
                type string;   // NCS patched all types to string
              }
            }
          }
          container member {
            leaf neighbor {
              type string;   // NCS patched all types to string
            }
          }
          container isolation {
            leaf recovery-delay {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
    }
    container ssh {
      container client {
        container source-interface {
          uses template_ncs_interface-name-grouping;
        }
      }
      container server {
        leaf logging {
          type empty;
        }
        leaf rate-limit {
          type string;   // NCS patched all types to string
        }
        leaf session-limit {
          type string;   // NCS patched all types to string
        }
        leaf v2 {
          type empty;
        }
        list vrf {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          container ipv6 {
            leaf access-list {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      leaf timeout {
        type string;   // NCS patched all types to string
      }
    }
    container ipsla {
      leaf key-chain {
        type string;   // NCS patched all types to string
      }
      container responder {
        presence "true";
      }
    }
    container performance-mgmt {
      container thresholds {
        container node {
          container cpu {
            list template {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              uses template_ncs_performance-mgmt-grouping;
            }
          }
          container process {
            list template {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              uses template_ncs_performance-mgmt-grouping;
            }
          }
        }
      }
      container apply {
        container thresholds {
          container node {
            container cpu {
              leaf location {
                type string;   // NCS patched all types to string
              }
              leaf template {
                type string;   // NCS patched all types to string
              }
            }
            container process {
              leaf location {
                type string;   // NCS patched all types to string
              }
              leaf template {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
    }
    container vlan {
      container internal {
        container allocation {
          leaf policy {
            type string;   // NCS patched all types to string
          }
        }
      }
      container access-log {
        leaf maxflow {
          type string;   // NCS patched all types to string
        }
        leaf ratelimit {
          type string;   // NCS patched all types to string
        }
        leaf threshold {
          type string;   // NCS patched all types to string
        }
      }
      list vlan-list {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf uni-vlan {
          type string;   // NCS patched all types to string
        }
      }
    }
    container line {
      container console {
        uses template_ncs_line-grouping;
      }
      container default {
        uses template_ncs_line-grouping;
      }
      list template {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        uses template_ncs_line-grouping;
      }
    }
    container lldp {
      leaf holdtime {
        type string;   // NCS patched all types to string
      }
      leaf reinit {
        type string;   // NCS patched all types to string
      }
      leaf run {
        type empty;
      }
      leaf timer {
        type string;   // NCS patched all types to string
      }
    }
    container switch-fabric {
      list service-policy {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
      }
    }
    container lpts {
      container pifib {
        container hardware {
          container police {
            uses template_ncs_lpts-grouping;
            list location {
              ordered-by "user";  // NCS patched to keep predictable order
              key "node-id";
              leaf node-id {
                type string;   // NCS patched all types to string
              }
              uses template_ncs_lpts-grouping;
            }
          }
        }
      }
    }
    container hw-module {
      container qos {
        container pol-gran {
          leaf granularity {
            type string;   // NCS patched all types to string
          }
          leaf location {
            type string;   // NCS patched all types to string
          }
        }
        container queue-auto-defrag {
          container disable {
            list location {
              ordered-by "user";  // NCS patched to keep predictable order
              key "id";
              leaf id {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        container account {
          container layer2 {
            container encapsulation {
              choice encapsulation-choice {
                leaf arpa {
                  type empty;
                }
                leaf dot1q {
                  type empty;
                }
                leaf length {
                  type string;   // NCS patched all types to string
                }
              }
              leaf location {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        container multicast {
          leaf location {
            type string;   // NCS patched all types to string
          }
        }
      }
      container pse {
        container allocate {
          container tcam {
            list location {
              ordered-by "user";  // NCS patched to keep predictable order
              key "id";
              leaf id {
                type string;   // NCS patched all types to string
              }
              list region {
                ordered-by "user";  // NCS patched to keep predictable order
                key "name num";
                leaf name {
                  type string;   // NCS patched all types to string
                }
                leaf num {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
        }
      }
    }
    list class-map {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      leaf prematch {
        type string;   // NCS patched all types to string
        // NCS drop  (default) statement
      }
      leaf description {
        type string;   // NCS patched all types to string
      }
      container match {
        uses template_ncs_class-map-match-grouping;
        container not {
          uses template_ncs_class-map-match-grouping;
        }
      }
    }
    list policy-map {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      container class {
        list class-ref {
          ordered-by "user";  // NCS patched to keep predictable order
          key "map";
          leaf map {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_policy-map-class-grouping;
        }
        list class-default {
          ordered-by "user";  // NCS patched to keep predictable order
          key "map";
          leaf map {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_policy-map-class-grouping;
        }
      }
      leaf description {
        type string;   // NCS patched all types to string
      }
    }
    container clock-interface {
      list sync {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id location";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf location {
          type string;   // NCS patched all types to string
        }
        container port-parameters {
          container bits-input {
            leaf mode {
              type string;   // NCS patched all types to string
            }
            leaf mode1 {
              type string;   // NCS patched all types to string
            }
            leaf mode2 {
              type string;   // NCS patched all types to string
            }
          }
        }
        container frequency {
          container synchronization {
            container selection {
              leaf input {
                type empty;
              }
            }
            leaf priority {
              type string;   // NCS patched all types to string
            }
            leaf wait-to-restore {
              type string;   // NCS patched all types to string
            }
            container quality {
              container receive {
                container exact {
                  container itu-t {
                    container option {
                      leaf one {
                        type string;   // NCS patched all types to string
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container l2 {
      list vfi {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf autodiscovery {
          type empty;
        }
        container vpn {
          leaf id {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container auto {
      leaf qos {
        type string;   // NCS patched all types to string
      }
    }
    container ethernet-services {
      list access-list {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        list rule {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf line {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container interface {
      uses template_ncs_interface-grouping;
      container preconfigure {
        uses template_ncs_interface-grouping;
      }
    }
    container controller {
      list dwdm {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf proactive {
          type empty;
        }
        leaf admin-state {
          type string;   // NCS patched all types to string
        }
      }
      list MgmtMultilink {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        list bundle {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
        }
      }
      list T1 {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf framing {
          type string;   // NCS patched all types to string
        }
        list channel-group {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf speed {
            type string;   // NCS patched all types to string
          }
          leaf timeslots {
            type string;   // NCS patched all types to string
          }
        }
        container clock {
          container source {
            choice source-choice {
              leaf internal {
                type empty;
              }
              leaf line {
                type empty;
              }
            }
          }
        }
      }
      list T3 {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf mode {
          type string;   // NCS patched all types to string
        }
        container delay {
          leaf trigger {
            type string;   // NCS patched all types to string
          }
        }
        container clock {
          container source {
            choice source-choice {
              leaf internal {
                type empty;
              }
              leaf line {
                type empty;
              }
            }
          }
        }
      }
      list sonet {
        ordered-by "user";  // NCS patched to keep predictable order
        key "id";
        leaf id {
          type string;   // NCS patched all types to string
        }
        leaf description {
          type string;   // NCS patched all types to string
        }
        leaf ais-shut {
          type empty;
        }
        leaf framing {
          type string;   // NCS patched all types to string
        }
        list sts {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf width {
            type string;   // NCS patched all types to string
          }
          leaf mode {
            type string;   // NCS patched all types to string
          }
          container delay {
            leaf trigger {
              type string;   // NCS patched all types to string
            }
          }
        }
        container threshold {
          leaf sf-ber {
            type string;   // NCS patched all types to string
          }
        }
        container clock {
          leaf source {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    container l2vpn {
      container load-balancing {
        leaf flow {
          type string;   // NCS patched all types to string
        }
      }
      list pw-class {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        container encapsulation {
          container l2tpv3 {
            leaf protocol {
              type string;   // NCS patched all types to string
            }
            leaf ttl {
              type string;   // NCS patched all types to string
            }
          }
          container mpls {
            container transport-mode {
              choice transport-mode-choice {
                leaf ethernet {
                  type empty;
                }
                container vlan {
                  presence "true";
                  leaf passthrough {
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
      container xconnect {
        list group {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          list p2p {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            list interface {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
            }
            leaf monitor-session {
              type string;   // NCS patched all types to string
            }
            list neighbor {
              ordered-by "user";  // NCS patched to keep predictable order
              key "address pw-id";
              leaf address {
                type string;   // NCS patched all types to string
              }
              leaf pw-id {
                type string;   // NCS patched all types to string
              }
              leaf ip-version {
                type string;   // NCS patched all types to string
              }
              container mpls {
                container static {
                  container label {
                    leaf local {
                      type string;   // NCS patched all types to string
                    }
                    leaf remote {
                      type string;   // NCS patched all types to string
                    }
                  }
                }
              }
              leaf pw-class {
                type string;   // NCS patched all types to string
              }
              container l2tp {
                container static {
                  container local {
                    container cookie {
                      leaf size {
                        type string;   // NCS patched all types to string
                      }
                      container value {
                        // NCS drop path statement here
                        leaf value_1 {
                          type string;   // NCS patched all types to string
                        }
                        leaf value_2 {
                          // NCS drop path statement here
                          type string;   // NCS patched all types to string
                        }
                      }
                    }
                  }
                  container remote {
                    container cookie {
                      leaf size {
                        type string;   // NCS patched all types to string
                      }
                      container value {
                        // NCS drop path statement here
                        leaf value_1 {
                          type string;   // NCS patched all types to string
                        }
                        leaf value_2 {
                          // NCS drop path statement here
                          type string;   // NCS patched all types to string
                        }
                      }
                    }
                  }
                }
              }
              leaf source {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
      }
      container bridge {
        list group {
          ordered-by "user";  // NCS patched to keep predictable order
          key "group-name";
          leaf group-name {
            type string;   // NCS patched all types to string
          }
          list bridge-domain {
            ordered-by "user";  // NCS patched to keep predictable order
            key "bridge-domain-name";
            leaf bridge-domain-name {
              type string;   // NCS patched all types to string
            }
            list interface {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              container storm-control {
                container broadcast {
                  leaf pps {
                    type string;   // NCS patched all types to string
                  }
                }
                container multicast {
                  leaf pps {
                    type string;   // NCS patched all types to string
                  }
                }
                container unknown-unicast {
                  leaf pps {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
            list neighbor {
              ordered-by "user";  // NCS patched to keep predictable order
              key "address pw-id";
              leaf address {
                type string;   // NCS patched all types to string
              }
              leaf pw-id {
                type string;   // NCS patched all types to string
              }
              container mpls {
                container static {
                  container label {
                    leaf local {
                      type string;   // NCS patched all types to string
                    }
                    leaf remote {
                      type string;   // NCS patched all types to string
                    }
                  }
                }
              }
              leaf pw-class {
                type string;   // NCS patched all types to string
              }
            }
            container mac {
              container withdraw {
                leaf state-down {
                  type empty;
                }
              }
            }
            leaf mtu {
              type string;   // NCS patched all types to string
            }
            container routed {
              list interface {
                ordered-by "user";  // NCS patched to keep predictable order
                key "name";
                leaf name {
                  type string;   // NCS patched all types to string
                }
              }
            }
            list vfi {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              leaf vpn-id {
                type string;   // NCS patched all types to string
              }
              container autodiscovery {
                container bgp {
                  leaf rd {
                    type string;   // NCS patched all types to string
                  }
                  list route-target {
                    ordered-by "user";  // NCS patched to keep predictable order
                    key "name";
                    leaf name {
                      type string;   // NCS patched all types to string
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container extcommunity-set {
      list rt {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        list set {
          ordered-by "user";  // NCS patched to keep predictable order
          // NCS drop  (ordered-by) statement
          key "value";
          leaf value {
            type string;   // NCS patched all types to string
          }
        }
      }
    }
    list rd-set {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      list set {
        ordered-by "user";  // NCS patched to keep predictable order
        // NCS drop  (ordered-by) statement
        key "value";
        leaf value {
          type string;   // NCS patched all types to string
        }
      }
    }
    list prefix-set {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      list set {
        ordered-by "user";  // NCS patched to keep predictable order
        // NCS drop  (ordered-by) statement
        key "value";
        leaf value {
          type string;   // NCS patched all types to string
        }
      }
    }
    list community-set {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      list set {
        ordered-by "user";  // NCS patched to keep predictable order
        // NCS drop  (ordered-by) statement
        key "value";
        leaf value {
          type string;   // NCS patched all types to string
        }
      }
    }
    list route-policy {
      ordered-by "user";  // NCS patched to keep predictable order
      key "name";
      leaf name {
        type string;   // NCS patched all types to string
      }
      list cmd {
        ordered-by "user";  // NCS patched to keep predictable order
        // NCS drop  (ordered-by) statement
        key "value";
        leaf value {
          type string;   // NCS patched all types to string
        }
      }
    }
    container router {
      container static {
        container address-family {
          container ipv4 {
            container unicast {
              list routes {
                ordered-by "user";  // NCS patched to keep predictable order
                key "net interface";
                leaf net {
                  type string;   // NCS patched all types to string
                }
                leaf interface {
                  type string;   // NCS patched all types to string
                }
                leaf address {
                  type string;   // NCS patched all types to string
                }
                leaf tag {
                  type string;   // NCS patched all types to string
                }
                leaf description {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
          container ipv6 {
            container unicast {
              list routes {
                ordered-by "user";  // NCS patched to keep predictable order
                key "net interface";
                leaf net {
                  type string;   // NCS patched all types to string
                }
                leaf interface {
                  type string;   // NCS patched all types to string
                }
                leaf address {
                  type string;   // NCS patched all types to string
                }
                leaf tag {
                  type string;   // NCS patched all types to string
                }
                leaf description {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
        }
      }
      container igmp {
        presence "true";
      }
      container isis {
        list tag {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf is-type {
            type string;   // NCS patched all types to string
          }
          leaf net {
            type string;   // NCS patched all types to string
          }
          container address-family {
            uses template_ncs_router-isis-address-family-grouping;
          }
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf interface-type {
              type string;   // NCS patched all types to string
            }
            container bfd {
              leaf fast-detect {
                type string;   // NCS patched all types to string
              }
              leaf minimum-interval {
                type string;   // NCS patched all types to string
              }
              leaf multiplier {
                type string;   // NCS patched all types to string
              }
            }
            leaf point-to-point {
              type empty;
            }
            leaf hello-padding {
              type string;   // NCS patched all types to string
            }
            container hello-password {
              leaf keychain {
                type string;   // NCS patched all types to string
              }
              container hmac-md5 {
                leaf encrypted {
                  type string;   // NCS patched all types to string
                }
              }
            }
            container link-down {
              leaf fast-detect {
                type empty;
              }
            }
            container address-family {
              uses template_ncs_router-isis-address-family-grouping;
            }
          }
          container authentication {
            container key-chain {
              leaf ref {
                type string;   // NCS patched all types to string
              }
              leaf level {
                type string;   // NCS patched all types to string
              }
            }
            container mode {
              choice mode-choice {
                container md5 {
                  presence "true";
                  leaf level {
                    type string;   // NCS patched all types to string
                  }
                }
                container text {
                  presence "true";
                  leaf level {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
          leaf metric-style {
            type string;   // NCS patched all types to string
          }
          container set-overload-bit {
            presence "true";
            leaf on-startup {
              type string;   // NCS patched all types to string
            }
            container suppress {
              leaf external {
                type empty;
              }
              leaf interlevel {
                type empty;
              }
            }
          }
          container lsp-gen-interval {
            leaf maximum-wait {
              type string;   // NCS patched all types to string
            }
            leaf initial-wait {
              type string;   // NCS patched all types to string
            }
            leaf secondary-wait {
              type string;   // NCS patched all types to string
            }
          }
          leaf lsp-refresh-interval {
            type string;   // NCS patched all types to string
          }
          leaf max-lsp-lifetime {
            type string;   // NCS patched all types to string
          }
          container log {
            container adjacency {
              leaf changes {
                type empty;
              }
            }
          }
          container nsf {
            choice nsf-choice {
              container advertise {
                leaf holdtime {
                  type string;   // NCS patched all types to string
                }
              }
              leaf cisco {
                type empty;
              }
              leaf ietf {
                type empty;
              }
              container interface {
                leaf wait {
                  type string;   // NCS patched all types to string
                }
              }
              leaf interval {
                type string;   // NCS patched all types to string
              }
              container t3 {
                choice t3-choice {
                  leaf adjacency {
                    type empty;
                  }
                  leaf manual {
                    type string;   // NCS patched all types to string
                  }
                }
              }
            }
          }
          container bfd {
            leaf all-interfaces {
              type empty;
            }
            leaf check-ctrl-plane-failure {
              type empty;
            }
          }
          container mpls {
            leaf ldp {
              type string;   // NCS patched all types to string
            }
            container traffic-eng {
              leaf level-1 {
                type empty;
              }
              leaf level-2 {
                type empty;
              }
              leaf multicast-intact {
                type empty;
              }
              leaf router-id {
                type empty;
              }
              leaf scanner {
                type empty;
              }
            }
          }
        }
      }
      list ospf {
        ordered-by "user";  // NCS patched to keep predictable order
        key "name";
        leaf name {
          type string;   // NCS patched all types to string
        }
        leaf nsr {
          type empty;
        }
        container log {
          container adjacency {
            container changes {
              presence "true";
              leaf changes-state {
                type string;   // NCS patched all types to string
              }
            }
          }
        }
        leaf router-id {
          type string;   // NCS patched all types to string
        }
        container network {
          choice network-choice {
            leaf broadcast {
              type empty;
            }
            leaf non-broadcast {
              type empty;
            }
            container point-to-multipoint {
              presence "true";
              leaf non-broadcast {
                type empty;
              }
            }
            leaf point-to-point {
              type empty;
            }
          }
        }
        container bfd {
          leaf fast-detect {
            type empty;
          }
          leaf minimum-interval {
            type string;   // NCS patched all types to string
          }
          leaf multiplier {
            type string;   // NCS patched all types to string
          }
        }
        container mpls {
          container traffic-eng {
            container router-id {
              uses template_ncs_interface-name-grouping;
            }
          }
          container ldp {
            leaf sync {
              type empty;
            }
          }
        }
        container nsf {
          container ietf {
            presence "true";
            container helper {
              leaf disable {
                type empty;
              }
            }
          }
        }
        container timers {
          container throttle {
            container lsa {
              container all {
                leaf delay {
                  type string;   // NCS patched all types to string
                }
                leaf min-delay {
                  type string;   // NCS patched all types to string
                }
                leaf max-delay {
                  type string;   // NCS patched all types to string
                }
              }
            }
            container spf {
              leaf delay {
                type string;   // NCS patched all types to string
              }
              leaf min-delay {
                type string;   // NCS patched all types to string
              }
              leaf max-delay {
                type string;   // NCS patched all types to string
              }
            }
          }
          container lsa {
            leaf min-arrival {
              type string;   // NCS patched all types to string
            }
          }
        }
        container spf {
          container prefix-priority {
            leaf route-policy {
              type string;   // NCS patched all types to string
            }
          }
        }
        container auto-cost {
          leaf reference-bandwidth {
            type string;   // NCS patched all types to string
          }
        }
        container max-metric {
          container router-lsa {
            leaf on-startup {
              type string;   // NCS patched all types to string
            }
            leaf include-stub {
              type empty;
            }
            choice external-lsa-choice {
              container external-lsa-container {
                leaf external-lsa {
                  type string;   // NCS patched all types to string
                }
              }
              leaf external-lsa {
                type empty;
              }
            }
            choice summary-lsa-choice {
              container summary-lsa-container {
                leaf summary-lsa {
                  type string;   // NCS patched all types to string
                }
              }
              leaf summary-lsa {
                type empty;
              }
            }
          }
        }
        list area {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_ospf-area-grouping;
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            uses template_ncs_ospf-area-grouping;
          }
        }
      }
      container bgp {
        list bgp-no-instance {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id";
          leaf id {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_router-bgp-grouping;
        }
        list bgp-instance {
          ordered-by "user";  // NCS patched to keep predictable order
          key "id instance";
          leaf id {
            type string;   // NCS patched all types to string
          }
          leaf instance {
            type string;   // NCS patched all types to string
          }
          uses template_ncs_router-bgp-grouping;
        }
      }
      container mld {
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          leaf router {
            type string;   // NCS patched all types to string
          }
        }
        leaf version {
          type string;   // NCS patched all types to string
        }
      }
      container pim {
        container address-family {
          container ipv4 {
            list rp-address {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              leaf group-access-list {
                type string;   // NCS patched all types to string
              }
              leaf override {
                type empty;
              }
              leaf bidir {
                type empty;
              }
            }
            container spt-threshold {
              container infinity {
                presence "true";
                leaf group-list {
                  type string;   // NCS patched all types to string
                }
              }
            }
            container log {
              container neighbor {
                leaf changes {
                  type empty;
                }
              }
            }
          }
          container ipv6 {
            list interface {
              ordered-by "user";  // NCS patched to keep predictable order
              key "name";
              leaf name {
                type string;   // NCS patched all types to string
              }
              leaf enable {
                type empty;
              }
            }
            leaf neighbor-check-on-recv {
              type string;   // NCS patched all types to string
            }
            leaf neighbor-check-on-send {
              type string;   // NCS patched all types to string
            }
          }
        }
      }
      container vrrp {
        list interface {
          ordered-by "user";  // NCS patched to keep predictable order
          key "name";
          leaf name {
            type string;   // NCS patched all types to string
          }
          container address-family {
            container ipv4 {
              list vrrp {
                ordered-by "user";  // NCS patched to keep predictable order
                key "id";
                leaf id {
                  type string;   // NCS patched all types to string
                }
                leaf priority {
                  type string;   // NCS patched all types to string
                }
                container preempt {
                  choice preempt-choice {
                    leaf delay {
                      type string;   // NCS patched all types to string
                    }
                    leaf disable {
                      type empty;
                    }
                  }
                }
                container timer {
                  choice timer-choice {
                    leaf time-value {
                      type string;   // NCS patched all types to string
                    }
                    leaf msec {
                      type string;   // NCS patched all types to string
                    }
                  }
                  leaf force {
                    type empty;
                  }
                }
                list address {
                  ordered-by "user";  // NCS patched to keep predictable order
                  key "ip";
                  leaf ip {
                    type string;   // NCS patched all types to string
                  }
                  leaf seconday {
                    type empty;
                  }
                }
                leaf text-authentication {
                  type string;   // NCS patched all types to string
                }
              }
            }
          }
        }
      }
    }
    container multicast-routing {
      container address-family {
        container ipv4 {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf enable {
              type empty;
            }
            leaf boundary {
              type string;   // NCS patched all types to string
            }
          }
          leaf nsf {
            type empty;
          }
          container mdt {
            container source {
              uses template_ncs_interface-name-grouping;
            }
          }
          container multipath {
            presence "true";
          }
          container ssm {
            leaf range {
              type string;   // NCS patched all types to string
            }
          }
          leaf rate-per-route {
            type empty;
          }
        }
        container ipv6 {
          list interface {
            ordered-by "user";  // NCS patched to keep predictable order
            key "name";
            leaf name {
              type string;   // NCS patched all types to string
            }
            leaf enable {
              type empty;
            }
          }
          container multipath {
            presence "true";
          }
        }
      }
    }
  }

  // Skip entire stats tree due to --ncs-skip-statistics flag

}
